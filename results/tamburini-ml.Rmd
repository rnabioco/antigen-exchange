---
title: "Antigen Tracking Figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc:            true
    toc_float:      true
    toc_depth:      4
    df_print:       "paged"
    code_folding:   "hide"
    self_contained: true
    highlight:      "kate"
params:
  template_dir:  "src"                                                                      # Directory containing template Rmarkdowns
  so_dir:        "~/Dropbox/Ryan/Projects/antigen-exchange/results/sobjs"                   # Directory for loading/saving Seurat objects
  mod_dir:       "~/Dropbox/Ryan/Projects/antigen-exchange/results/models"                  # Directory for loading/saving ML models
  ref_dir:       "ref"                                                                      # Directory to use for loading/saving clustifyr references
  sample_info:   "sample_info.xlsx"
  chikv_so:      "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs/so_merge.qs"
  res_dir:                                                
    value:
      exp-0: "~/Projects/antigen-tracking/results"
      exp-1: "~/Projects/tamburini-antigen-tracking/results/2022-03-11"
      exp-2: "~/Projects/tamburini-antigen-tracking/results/2022-10-28"
editor_options: 
  chunk_output_type: console
---

---

<br>

## Summary

* The goal of this project is to use machine learning to predict Ag archiving
  capacity (or ability) in LECs from naive mice.
* For a proof of principle analysis, Ag-tracking data for d14 cLECs was used to
  train a random forest classifier to predict Ag status
* Using this model we defined a gene program that correlates with Ag status at
  various timepoints
* Archiving "competent" cLECs can be predicted in the CHIKV LN scRNA-seq data
* There is a reduction in archiving-competent cLECs in CHIKV-infected mice and
  a broad downregulation of the Ag-archiving gene program
* The central goal for this project is to optimize the model
  (and expand to other cell types) and use it to assess archiving capacity in
  public LN datasets to identify perturbations/treatments etc that are predicted
  to impair archiving

```{r "setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# Run setup chunks
knitr::knit(here::here(params$template_dir, "setup.Rmd"), "")

# Set Ag-low/high groups
# split separately for each cell type
# exclude d2 since it hase very few cells
lec_so <- lec_so %>%
  subset(mouse != "d2") %>%
  mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
  cluster_signal(
    data_column  = "Ag_score",
    grp_column   = "mouse_type",
    clust_column = "Ag_class_2",
    method       = "km"
  )

rm(dc_so, all_meta)

# Theme elements
pred_clrs <- c(
  low         = "#6A51A3",
  `high-pred` = "#E69F00",
  high        = "#D7301F"
)

base_theme <- djvdj_theme() +
  theme(axis.text = element_text(color = "black"))

# RF parameters
rf_dat_clmn  <- "Ag_class_2"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"

# Check for RF predictions
run_rf <- !file.exists(here(params$mod_dir, "ag-high_preds.tsv.gz"))
```

```{r "RF functions"}
# Function to predict
rf_predict <- function(mod, dat, data_clmn = NULL, return_stats = TRUE) {
  
  prds <- mod %>%
    predict(dat, seed = 42) %>%
    ranger::predictions()
  
  res <- dat %>%
    as_tibble(rownames = ".cell_id") %>%
    mutate(pred = prds)
  
  if (is.null(data_clmn)) return(res)
  
  res <- res %>%
    dplyr::select(.cell_id, all_of(data_clmn), pred) %>%
    mutate(correct = pred == !!sym(data_clmn)) %>%
    group_by(pred) %>%
    mutate(frac_correct = sum(correct) / n()) %>%
    ungroup()
  
  if (!return_stats) return(column_to_rownames(res, ".cell_id"))
  
  res <- res %>%
    distinct(pred, frac_correct) %>%
    pivot_wider(names_from = pred, values_from = frac_correct)
  
  res
}

#' Generate RF models using given data and parameters
#' 
#' @param df_in data.frame containing features as columns and observations as
#' rows
#' @param data_clmn column in df_in containing response variable
#' @param param_lst list of RF parameters to expand and test
#' @param sample_size number of cells to use for each group in data_clmn, want
#' number of cells in each group to be equal when training model
#' @param feat_p p-value cutoff for selecting best features
#' @param min_feats minimum number of features to allow after feature selection
#' @param min_cells minimum number of cells required for each group in data_clmn
#' @param scale_data Should independent variables be scaled
#' @param select_feats should features be filtered based on p-value
#' @param df_list list of data.frames containing data for each mouse to use for
#' comparing the fraction of predicted Ag-high cells. Want a model where the
#' fraction of predicted Ag-high cells is roughly the same for all samples.
#' @param frac_grp group in data_clmn that should be used for calculating and
#' comparing fractions using data in df_list
#' @param balance_groups downsample so groups have the same number of cells
#' @param sample_info addition columns to include in data
#' @param degs data.frame of DEGs, used to determine which DEGs are markers
#' for each group, this is used to balance the features equally between groups
#' @param ... additional parameters to pass to ranger::ranger()
train_rf <- function(df_in, data_clmn, param_lst, sample_size = 135,
                     feat_p = 0.05, min_feats = 20, min_cells = 30,
                     scale_data = FALSE, select_feats = TRUE, df_list = NULL,
                     frac_grp = "high", balance_groups = TRUE,
                     sample_info = NULL, degs = NULL, ...) {
  
  # Format train/test data
  rf_dat <- df_in %>%
    dplyr::select(
      all_of(c(data_clmn, sample_info)),
      where(~ !all(.x == 0))
    ) %>%
    mutate(!!sym(data_clmn) := factor(!!sym(data_clmn))) %>%
    rename_with(~ str_replace_all(.x, "-", "_")) %>%
    rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
    rename_with(~ str_c("x", .x), matches("^[0-9]"))
  
  # # Reverse class weights to account for imbalanced data
  # # class_weights <- class_weights / sum(class_weights)
  # class_weights <- table(rf_dat[[data_clmn]])
  # class_weights <- class_weights / min(class_weights)
  # 
  # lvls <- levels(rf_dat[[data_clmn]])
  # 
  # class_weights <- set_names(
  #   rev(class_weights),
  #   lvls
  # )
  
  # Scale data
  if (scale_data) {
    rf_dat <- rf_dat %>%
      mutate(
        across(-any_of(c(data_clmn, sample_info)), ~ as.numeric(scale(.x)))
      )
  }
  
  # Adjust groups so they are balanced
  # Split into train/test data
  # sam_sz <- min(sample_size, min(table(rf_dat[[data_clmn]])))
  if (balance_groups) {
    if (any(sample_size < min_cells)) {
      cli::cli_abort("All groups must have at least {min_cells} cells")
    }
    
    rf_train <- rf_dat %>%
      rownames_to_column(".cell_id") %>%
      split(.[[data_clmn]]) %>%
      imap_dfr(~ {
        sz <- sample_size[[.y]] 
        
        set.seed(42)
        
        .x %>%
          dplyr::sample_n(sz) %>%
          column_to_rownames(".cell_id")
      })
    
    rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
    
  } else {
    set.seed(42)
    
    rf_split <- initial_split(rf_dat, prop = 0.5)
    rf_train <- training(rf_split)
    rf_test  <- testing(rf_split)
  }
  
  rf_train <- rf_train %>%
    dplyr::select(-any_of(sample_info))
  
  # Train models
  rf_params <- expand.grid(param_lst)
  rf_params <- bind_cols(rf_params, list(...))
  
  res <- pmap_dfr(rf_params, ~ {
    args <- list(...)
    
    if (args$mtry > (ncol(rf_train) - 1)) return(NULL)
    
    args$formula       <- as.formula(str_c(data_clmn, " ~ ."))
    args$data          <- rf_train
    args$importance    <- args$importance %||% "impurity_corrected"
    args$seed          <- 42
    # args$class.weights <- args$class.weights %||% class_weights
    # args$class.weights <- c(high = 1, low = 200)
    
    set.seed(42)
    
    raw_mod <- mod <- lift_dl(ranger)(args)
    
    raw_err   <- raw_mod$prediction.error
    key_feats <- importance(raw_mod)
    
    # Feature selection
    if (select_feats) {
      key_feats <- raw_mod %>%
        importance_pvalues() %>%
        .[, "pvalue"] %>%
        sort()
      
      max_p <- key_feats %>%
        head(min_feats) %>%
        max()
      
      feat_p <- max(max_p, feat_p)
      
      key_feats <- key_feats[key_feats < feat_p] %>%
        names()
      
      n_feats <- length(key_feats)
      
      # Re-train model
      args$mtry       <- min(args$mtry, n_feats)
      args$data       <- rf_train[, c(data_clmn, key_feats)]
      args$importance <- "none"
      
      set.seed(42)
      
      mod <- lift_dl(ranger)(args)
    }
    
    err <- mod$prediction.error
    
    # Compare fraction predicted groups with ground truth from training data
    frac_stats <- df_list %>%
      imap_dfr(~ {
        mod %>%
          rf_predict(.x, data_clmn = data_clmn, return_stats = FALSE) %>%
          mutate(sample = .y)
      }) %>%
      group_by(sample) %>%
      summarize(
        frac_high = sum(pred == frac_grp) / n(),
        .groups   = "drop"
      ) %>%
      summarize(
        frac_mean = mean(frac_high),
        frac_sd   = sd(frac_high)
      )
    
    # Test model
    prds <- mod %>%
      rf_predict(
        dat          = rf_test,
        data_clmn    = data_clmn,
        return_stats = TRUE
      )
                                         # only used for continuous
    # err <- sqrt(res$prediction.error)  # response variables
    
    # Format output table
    tibble(
      raw_mod   = list(raw_mod),
      mod       = list(mod),
      feats     = list(key_feats),
      n_train   = nrow(rf_train),
      n_test    = nrow(rf_test),
      # train_bcs = list(rownames(rf_train)),
      # test_bcs  = list(rownames(rf_test)),
      ...,
      n_feats = length(key_feats),
      oob_raw = raw_err,
      oob     = err
    ) %>%
      bind_cols(frac_stats) %>%
      bind_cols(prds)
  })
  
  res <- res %>%
    arrange(oob)
  
  res
}

create_gn_plots <- function(so_in, gns, plt_clrs, p_alt = "greater", n_gns = 10) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  gn_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns))
  
  plt_dat <- gn_dat %>%
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(
      med = median(value),
      q1  = quantile(value, 0.25),
      q3  = quantile(value, 0.75),
      .groups = "drop"
    ) %>%
    mutate(pred_grp = fct_relevel(pred_grp, names(plt_clrs))) %>%
    group_by(name, mouse, subtype) %>%
    
    filter(sum(med) > 0) %>%
    mutate(cor = cor(as.numeric(pred_grp), med)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse) == n_mice) %>%
    ungroup()
  
  # Calculate p-values
  clmn2 <- names(pred_clrs[2])
  clmn3 <- names(pred_clrs[3])
  
  p_clmns <- c(clmn2, clmn3)
  
  p_dat <- gn_dat %>%
    group_by(mouse, subtype, pred_grp, name) %>%
    mutate(y = quantile(value, 0.75)) %>%
    group_by(mouse, subtype, name) %>%
    summarize(
      y = max(y),
      
      !!sym(clmn2) := wilcox.test(
        value[pred_grp == clmn2], value[pred_grp == "low"],
        alternative = p_alt
      )$p.value,
      !!sym(clmn3) := wilcox.test(
        value[pred_grp == clmn3], value[pred_grp == "low"],
        alternative = p_alt
      )$p.value,
      .groups = "drop"
    ) %>%
    group_by(name) %>%
    mutate(y = max(y)) %>%
    
    group_by(mouse, subtype) %>%
    mutate(across(all_of(p_clmns), ~ p.adjust(.x, method = "bonferroni"))) %>%
    ungroup() %>%
    
    pivot_longer(all_of(p_clmns), names_to = "pred_grp", values_to = "p") %>%
    filter(p < 0.05)
  
  # Rank genes by number of significant p-values
  gns <- p_dat %>%
    group_by(name) %>%
    summarize(n = n()) %>%
    filter(name %in% plt_dat$name) %>%
    arrange(desc(n)) %>%
    head(n_gns) %>%
    pull(name) %>%
    as.character()
  
  # Create plots
  res <- plt_dat %>%
    filter(name %in% gns) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    ggplot(aes(pred_grp, med, color = mouse)) +
    geom_segment(
      aes(x = pred_grp, xend = pred_grp, y = q1, yend = q3),
      linewidth = 1, color = ln_col
    ) +
    geom_point(aes(size = pred_grp)) +
    geom_smooth(
      aes(x = as.numeric(as.factor(pred_grp))),
      method = "lm", linewidth = 0.25, linetype = 2,
      se = FALSE, formula = y ~ x
    ) +
    geom_point(
      aes(y = y),
      data = filter(p_dat, name %in% gns),
      position = position_nudge(y = 0.2),
      color = "black", shape = 6, size = 1
    ) +
    facet_grid(name ~ mouse, scales = "free_y", switch = "y") +
    scale_size_manual(values = c(1, 1.25, 1.25)) +
    scale_color_manual(values = m_clrs) +
    scale_y_continuous(breaks = ~ c(ceiling(min(.x)), floor(max(.x)))) +
    djvdj_theme() +
    theme(
      aspect.ratio    = 1,
      legend.position = "none",
      panel.border    = element_rect(color = "grey75"),
      strip.placement = "outside",
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1)
    )
  
  res
}

create_sig_umap <- function(so_in, dat_col, clrs) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = "mouse",
      outline     = TRUE,
      plot_colors = clrs,
      panel_nrow  = 1,
      size        = 0.15,
      stroke      = 0.6
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    djvdj_theme() +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_grp_umap <- function(so_in, dat_col, clrs) {
  so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = "mouse",
      outline     = TRUE,
      plot_colors = clrs,
      plot_lvls   = c("high-pred", "low", "high", "other"),
      panel_nrow  = 1,
      size        = 0.25,
      stroke      = 0.8,
      color = ln_col,
      trace_position = "bottom"
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    djvdj_theme() +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F")) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(pred_grp = fct_relevel(pred_grp, lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = "pred_grp", values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character()
  
  # Create heatmaps
  res <- heat_dat %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(pred_grp, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    djvdj_theme() +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, lvls = names(pred_clrs),
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", "lec_type", "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(lec_type == "cLEC") %>%
    group_by(treatment, name, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  # Create heatmaps
  res <- heat_dat %>%
    group_by(name, lec_type) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ lec_type) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    djvdj_theme() +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.6
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL) {
  res <- df_in %>%
    filter(tm == "24hpi") %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, notch = TRUE
    ) +
    facet_wrap(~ lec_type, nrow = 1, scales = "free_y") +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = pred_clrs) +
    labs(title = ttl) +
    djvdj_theme() +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}
```

```{r "identify Ag DEGs", eval = run_rf}
# Identify Ag markers for all LECs for each mouse
fc  <- 0

deg_so <- lec_so %>%
  SplitObject("mouse")

degs_1 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = "all", mouse = .y) %>%
      arrange(padj)
  })

# Identify Ag markers for subtype
deg_so <- lec_so %>%
  SplitObject("subtype")

degs_2 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y, mouse = "all") %>%
      arrange(padj)
  })

rm(deg_so)

# Identify markers for subtype and mouse
degs_3 <- lec_so@meta.data %>%
  distinct(subtype, mouse) %>%
  pmap_dfr(~ {
    res <- lec_so %>%
      subset(subtype == ..1 & mouse == ..2)
    
    if (n_distinct(res[[rf_dat_clmn]]) < 2) return(NULL)
    
    res <- res %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = ..1, mouse = ..2) %>%
      arrange(padj)
  })

degs <- bind_rows(degs_1, degs_2, degs_3) %>%
  filter(
    padj < 0.05, logFC > fc,
    !grepl("^(mt-|R[pls])", feature),
    feature != "Malat1"
  )

# Write table
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "train RF models", eval = run_rf}
# Params for RF
other_info <- c("subtype", "mouse")

# Select LEC subsets
typs <- lec_so@meta.data %>%
  filter(mouse == rf_mouse) %>%
  group_by(subtype, Ag_class_2) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(subtype) %>%
  filter(all(n > 60)) %>%
  ungroup() %>%
  pull(subtype) %>%
  unique()

# Select features
# cLEC DEGs from all timepoints
feats <- degs %>%
  filter(subtype == rf_cell_type) %>%
  pull(feature) %>%
  unique()

# Train models for each LEC subtype
type_mods <- typs %>%
  map_dfr(~ {
    rf_dat <- lec_so %>%
      subset(subtype == .x & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, other_info, feats)))
    
    all_dat <- lec_so %>%
      subset(subtype == .x) %>%
      FetchData(unique(c(rf_dat_clmn, other_info, feats))) %>%
      rename_with(~ str_replace_all(.x, "-", "_")) %>%
      rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
      rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
      split(.$mouse)
    
    group_size  <- table(rf_dat[[rf_dat_clmn]])
    target_frac <- group_size[["high"]] / sum(group_size)
    sam_size    <- floor(min(group_size) / 2)
    
    sam_size <- set_names(
      rep(sam_size, length(group_size)),
      names(group_size)
    )
    
    # # Select features
    # # calculate proportion of features identified for each group
    # feats <- degs %>%
    #   filter(subtype == .x)
    # 
    # feat_frac <- table(feats$group)
    # feat_frac <- feat_frac / sum(feat_frac)
    # 
    # feats <- feats %>%
    #   pull(feature) %>%
    #   unique()
    
    # Set RF params
    param_lst <- list(
      mtry          = seq(1, length(feats), floor(length(feats) / 15)),
      # min.node.size = 1:10,
      # num.trees     = seq(50, 1000, 100)
      min.node.size = c(1, 3, 5),
      num.trees     = c(50, 400, 1000)
    )
    
    # Train model
    res <- rf_dat %>%
      train_rf(
        data_clmn   = rf_dat_clmn,
        param_lst   = param_lst,
        sample_info = other_info,
        df_list     = all_dat[names(all_dat) != rf_mouse],
        scale_data  = FALSE,
        sample_size = sam_size
      )

    # Identify best models
    res <- res %>%
      arrange(
        desc(frac_mean < target_frac + 0.05 & frac_mean > target_frac - 0.05),
        desc(frac_mean < target_frac + 0.1 & frac_mean > target_frac - 0.1),
        desc(frac_sd < 0.1),
        oob,
        desc(low),
        desc(high)
      ) %>%
      mutate(
        subtype = .x,
        rank = row_number()
      )
      
    res
  })

# Save RF models
type_mods %>%
  qsave(here(params$mod_dir, "ag-high_models.qs"))
```

```{r "load models", eval = !run_rf}
# Load save models
type_mods <- qread(here(params$mod_dir, "ag-high_models.qs"))
degs      <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

type_preds <- read_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")
```

```{r "RF features"}
# Identify best models
best_mods <- type_mods %>%
  arrange(desc(low), desc(high)) %>%
  group_by(subtype) %>%
  slice(1)

rm(type_mods)

# Pull best features
best_feats <- best_mods %>%
  pmap(~ {
    args <- list(...)
    
    fts <- args$feats %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    degs %>%
      filter(feature %in% fts) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
  })

names(best_feats) <- best_mods$subtype

all_feats <- best_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Save top features
best_feats %>%
  qsave(here(params$mod_dir, "ag-high_features.qs"))
```

```{r "predict Ag class", eval = run_rf}
# Predict Ag class
pred_dat <- lec_so %>%
  FetchData(unique(c(rf_dat_clmn, other_info, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  column_to_rownames(".cell_id")

type_preds <- best_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse)
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Write table with predictions
type_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz"))
```

```{r "format data"}
# Format prediction labels
lec_so <- lec_so %>%
  AddMetaData(type_preds, col.name = c("type_pred", "type_correct"))

lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    pred_grp = case_when(
      Ag_class_2 == "high" ~ Ag_class_2,
      type_pred  == "high" ~ "high-pred",
      TRUE                 ~ Ag_class_2
    ),
    mouse = fct_relevel(mouse, mice)
  )

# Add module scores
best_feats %>%
  iwalk(~ {
    clmn_nms <- str_c(.y, "_", names(.x))

    lec_so <<- lec_so %>%
      AddModuleScore(
        features = .x,
        name     = clmn_nms
      )
  })
```

```{r "predict CHIKV"}
# Load CHIKV data
chikv_so <- qread(params$chikv_so)

# Format RF data
# need to add zeros for missing genes
# scaling genes across entire dataset yields predications more in line with
# Ag data (e.g. fraction Ag-high is roughly the same)
clmns <- c(
  "orig.ident", "rep", "treatment", "tm",
  "cell_type_2", "cell_type", "lec_type", "subtype",
  "UMAP_1", "UMAP_2"
)

chikv_dat <- chikv_so %>%
  FetchData(c(clmns, all_feats)) %>%
  mutate(across(any_of(all_feats), ~ as.numeric(scale(.x))))

missing_gns <- all_feats[!all_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Predict using cLEC model
best_mod <- best_mods %>%
  filter(subtype == rf_cell_type) %>%
  pull(mod) %>%
  .[[1]]

chikv_preds <- best_mod %>%
  rf_predict(dat = chikv_dat, return_stats = FALSE) %>%
  dplyr::select(.cell_id, pred) %>%
  column_to_rownames(".cell_id")

chikv_so <- chikv_so %>%
  AddMetaData(chikv_preds) %>%
  AddModuleScore(features = best_feats$cLEC, name = names(best_feats$cLEC))

# Save predictions
chikv_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz"))
```

<br>

## Classifying Ag-high

Ag-low and -high cells were identified by separatly clustering each LEC subset
for each sample into two groups based on Ag-score. Ag-low/high classifications
used for the analysis are shown below.

```{r "Ag signal", fig.width = 10, fig.height = 5}
# Cell types to plot
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

plt_clmn <- "Ag_class_2"

# Format plotting data
plt_dat <- lec_so@meta.data %>%
  filter(subtype %in% plt_typs)

# Format plot labels
plt_labs <- plt_dat %>%
  group_by(subtype, mouse, !!sym(plt_clmn)) %>%
  summarize(
    n = label_comma()(n()),
    .groups = "drop"
  ) %>%
  mutate(
    n = str_c(!!sym(plt_clmn), ": ", n, " cells"),
    !!sym(plt_clmn) := fct_relevel(!!sym(plt_clmn), names(pred_clrs))
  ) %>%
  group_by(subtype, mouse) %>%
  arrange(!!sym(plt_clmn)) %>%
  mutate(n = str_c(n, collapse = "\n"))
  
# Create histograms
plt_dat %>%
  ggplot(aes(Ag_score, after_stat(count) + 1, fill = mouse, alpha = !!sym(plt_clmn))) +
  geom_histogram(bins = 30) +
  geom_text(
    aes(Inf, Inf, label = n),
    data = plt_labs,
    check_overlap = TRUE,
    alpha = 1,
    hjust = 1.1,
    vjust = 1.1,
    size  = txt_pt1 / .pt * 0.65
  ) +
  facet_grid(subtype ~ mouse, scales = "free") +
  guides(fill = "none", alpha = guide_legend(title = "Ag group")) +
  scale_alpha_manual(values = c(low = 0.25, high = 0.75)) +
  scale_fill_manual(values = m_clrs) +
  scale_y_log10(expand = expansion(c(0.05, 0.2))) +
  labs(x = "Ag-score", y = "number of cells") +
  djvdj_theme() +
  theme(aspect.ratio = 0.7)
```

<br>

A random forest classifier was trained using data for d14 cLECs. The model was
then used to predict Ag-high cells in the other Ag datasets.

The fraction of cells belonging to each predicted Ag group is shown on the left
for cLECs from each sample.
The fraction of cells incorrectly predicted to be Ag high (high-pred) is shown
on the right for each sample.

* The model is fairly accurate in predicting Ag-high cells in the training and
  test data (d14 cLECs), but does not perform as well when predicting Ag-low
  cells, this can be improved with more optimization
* Since we want to identify gene signatures that are expressed
  in naive mice and continue to be expressed after
  Ag levels have fallen, we expect to observe an increasing fraction of false
  positive Ag-high cells for the later timepoints.

```{r "fraction Ag-high", fig.width = 8, fig.height = 3.5}
# Format data
plt_typs <- "cLEC"

bar_dat <- lec_so@meta.data %>%
  filter(subtype %in% plt_typs) %>%
  rename(prediction = type_pred, correct = type_correct) %>%
  mutate(correct = fct_relevel(as.character(correct), c("TRUE", "FALSE")))

bar_thm <- djvdj_theme() +
  theme(
    aspect.ratio = 1.4,
    axis.title.y = element_blank()
  )

# Plot fraction predicted groups
bar_1 <- bar_dat %>%
  ggplot(aes(mouse, fill = prediction, alpha = correct)) +
  geom_bar(position = "fill") +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
  scale_fill_manual(values = pred_clrs) +
  facet_grid(~ subtype) +
  bar_thm

bar_2 <- bar_dat %>%
  ggplot(aes(mouse, fill = pred_grp)) +
  geom_bar(position = "fill", alpha = 0.85) +
  facet_grid(~ subtype) +
  scale_fill_manual(values = pred_clrs) +
  bar_thm +
  theme(legend.title = element_blank())

plot_grid(
  bar_1, bar_2, 
  nrow = 1,
  align = "tb",
  axis  = "trbl"
)
```

---

<br>

<br>

## Ag modules

The top positive (top) and negative (bottom) gene modules that are most
predictive of Ag signal are shown below.

* There is a notable correlation between the expression of these genes
  and the Ag class
* False positive Ag high cells (high-pred) show
  an intermediate level of expression that falls roughly between the true Ag-low
  and true Ag-high cells.
* The false positive Ag high cells are potentially cells that are
  archiving-competent but have now lost/released most Ag at the later timepoints

```{r "modules", fig.width = 10, fig.height = 6}
# Boxplots
modules <- c(
  cLEC_high1 = "cLEC Ag-high module",
  cLEC_low2  = "cLEC Ag-low module"
)

plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

modules %>%
  imap(~ {
    lec_so %>%
      FetchData(c("subtype", "mouse", "pred_grp", .y)) %>%
      filter(subtype %in% plt_typs) %>%
      mutate(
        subtype = fct_relevel(subtype, plt_typs),
        pred_grp = fct_relevel(pred_grp, names(pred_clrs))
      ) %>%
      ggplot(aes(mouse, !!sym(.y), fill = pred_grp)) +
      geom_boxplot(outlier.size = 0.1, key_glyph = draw_key_point) +
      scale_fill_manual(values = pred_clrs) +
      facet_wrap(~ subtype, nrow = 1) +
      ggtitle(.x) +
      guides(fill = guide_legend(override.aes = list(shape = 22, size = 4))) +
      djvdj_theme() +
      theme(
        aspect.ratio = 0.75,
        plot.title   = element_text(hjust = 0.5),
        legend.title = element_blank(),
        axis.title.y = element_blank()
      )
  }) %>%
  wrap_plots(guides = "collect", ncol = 1) &
  theme(legend.position = "bottom")
```

<br>

UMAP projections show Ag-high module expression for each sample, the main cLEC
cluster is circled.

```{r "module scores", fig.width = 10, fig.height = 4}
# Set coordinates for drawing circle
circ_dat <- lec_so@meta.data %>%
  filter(subtype == rf_cell_type) %>%
  group_by(mouse) %>%
  summarize(across(c(hUMAP_1, hUMAP_2), mean))

# Plot module scores
ag_mod_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    lec_so %>%
      subset(mouse == .x) %>%
      create_sig_umap(
        dat_col = "cLEC_high1",
        clrs = c("lightblue", "white", pred_clrs[["high"]])
      ) +
      geom_circle(
        aes(x0 = hUMAP_1, y0 = hUMAP_2, fill = NULL, color = NULL, r = 2),
        data = filter(circ_dat, mouse == .x),
        linetype = 2
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "cLEC Ag-high module",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

ag_mod_u
```

<br>

UMAP projections show true Ag-low and true Ag-high cLECs.

* Ag-high cells occupy the far right portion of the cLEC cluster which coincides
  with highest expression of the Ag-high gene module

```{r "low vs high", fig.width = 10, fig.height = 5}
# Plot Ag-low vs Ag-high
clrs <- rev(pred_clrs)
clrs[c("low", "high-pred")] <- "#56B4E9"
clrs["other"]               <- "white"

u_so <- lec_so %>%
  mutate_meta(
    mutate,
    pred_grp  = ifelse(subtype == rf_cell_type, pred_grp, "other"),
    pred_grp1 = ifelse(pred_grp %in% c("high", "low"), pred_grp, "other"),
    pred_grp2 = ifelse(pred_grp %in% c("high", "high-pred"), pred_grp, "other")
  )

ag_low_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    u_so %>%
      subset(mouse == .x) %>%
      create_grp_umap(
        dat_col = "pred_grp1",
        clrs    = clrs
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "Ag-low vs Ag-high",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

ag_low_u
```

<br>

UMAP projections show false positive Ag-high and true Ag-high cLECs.

* False positive Ag-high cells (high-pred) show strong overlap with true
  Ag-high cells

```{r "high-pred vs high", fig.width = 10, fig.height = 5}
# Plot Ag-high vs predicted Ag-high
ag_high_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    u_so %>%
      subset(mouse == .x) %>%
      create_grp_umap(
        dat_col = "pred_grp2",
        clrs    = clrs
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "Ag-high predicted vs Ag-high",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

ag_high_u
```

---

<br>

<br>

## Ag features

```{r "top features heatmaps"}
heats <- best_feats$cLEC %>%
  imap(~ {
    lec_so %>%
      subset(subtype == rf_cell_type) %>%
      create_heats(
        gns = .x,
        sort_gns = switch(.y, high = "up", low = "down")
      ) +
      theme(
        panel.border = element_rect(color = "grey30")
      )
  })
```

```{r "top features examples", fig.height = 8, fig.width = 8}
plt_args <- list(
  gns   = best_feats$cLEC,
  p_alt = c("greater", "less"),
  n_gns = c(10, 7)
)
gn_plots <- plt_args %>%
  pmap(~ {
    args <- list(...)
    lec_so %>%
      subset(subtype == rf_cell_type) %>%
      create_gn_plots(
        gns      = args$gns,
        plt_clrs = pred_clrs,
        p_alt    = args$p_alt,
        n_gns    = args$n_gns
      )
  })
```

Mean expression in cLECs is shown on the left for genes from the Ag-high module for
true Ag-low, true Ag-high, and false positive Ag-high (predicted, high-pred)
cells.
Expression is shown on the right for select top features.

Points show median expression, grey bars show interquartile range, dotted line
shows the trend, and arrows indicate the gene is significantly up or down
regulated when compared to Ag-low cells.

```{r "Ag-high examples", fig.height = 8, fig.width = 10}
plot_grid(heats[[1]], gn_plots[[1]])
```

<br>

Expression of the Ag-low module is shown as described above.

```{r "Ag-low examples", fig.height = 6, fig.width = 10}
plot_grid(heats[[2]], gn_plots[[2]])
```

---

<br>

<br>

## Ag archiving in CHIKV

```{r "CHIKV data"}
# Format plotting data
treat_clrs <- c(mock = "#009E73", CHIKV = "#6A51A3")
n_reps     <- n_distinct(chikv_so$rep)

plt_dat <- chikv_so@meta.data %>%
  mutate(
    treatment = fct_relevel(treatment, names(treat_clrs)),
    pred      = fct_relevel(pred, names(pred_clrs))
  ) %>%
  filter(cell_type_2 == "LEC")

# Cell types to plot
chikv_typs <- plt_dat %>%
  group_by(treatment, lec_type, tm, rep) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(lec_type, tm) %>%
  filter(
    all(n > 20),
    !lec_type %in% c("unassigned-LEC")
  ) %>%
  ungroup() %>%
  pull(lec_type) %>%
  unique()

plt_dat <- plt_dat %>%
  filter(lec_type %in% chikv_typs)
```

The fraction of cells predicted to be Ag-high (i.e. archiving competent) is
shown below for each cell type. p-values < 0.05 are shown.

* There is a reduction in archiving-competent cells in CHIKV-infected LN samples

```{r "CHIKV fraction Ag", fig.width = 10, fig.height = 4}
# Format plotting data
bar_dat <- plt_dat %>%
  group_by(orig.ident, lec_type, rep, treatment, tm) %>%
  summarize(
    frac_high = sum(pred == "high") / n(),
    .groups = "drop"
  )

# Format p-values
p_dat <- bar_dat %>%
  group_by(lec_type, tm) %>%
  summarize(
    p = t.test(
      frac_high[treatment == names(treat_clrs)[1]],
      frac_high[treatment == names(treat_clrs)[2]]
    )$p.value,
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    padj = p.adjust(p, method = "bonferroni"),
    plab = .format_pvalue(padj),
    plab = str_c("italic(p) == ", plab) 
  ) %>%
  filter(padj < 0.05)

# Create bargraphs
bar_dat %>%
  ggplot(aes(treatment, frac_high, fill = treatment, alpha = rep)) +
  geom_col(position = position_dodge2(preserve = "single")) +
  geom_text(
    aes(y = Inf, x = 1.5, label = plab, fill = NULL),
    data = p_dat,
    alpha = 1,
    parse = TRUE,
    size  = txt_pt1 / .pt * 0.8,
    vjust = 1.1
  ) +
  facet_grid(tm ~ lec_type) +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  scale_alpha_manual(values = rep(1, n_reps)) +
  scale_fill_manual(values = treat_clrs) +
  labs(y = "fraction predicted Ag-high") +
  djvdj_theme() +
  theme(
    aspect.ratio    = 1.25, 
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )
```

<br>

Expression of the Ag-high (top) and Ag-low (bottom) gene modules is shown below
for each predicted Ag class for the 24 hpi timepoint.

* Cells predicted to
  be archiving-competent show upregulation of the Ag-high gene module
* The Ag-low gene module shows similar expression between samples

```{r "CHIKV module scores", fig.width = 9, fig.height = 5.5}
# Module scores for each prediction group
chikv_modules <- c(
  high1 = "Ag-high module",
  low2  = "Ag-low module"
)

chikv_boxes <- chikv_modules %>%
  imap(~ {
    plt_dat %>%
      create_chikv_boxes(
        dat_col = .y,
        ttl     = .x
      )
  })

chikv_boxes %>%
  wrap_plots(ncol = 1, guides = "collect")
```

<br>

Mean expression is shown for genes from the Ag-high module for mock- and
CHIKV-infected mice from the 24 hpi timepoint.

* CHIKV-infected mice broadly downregulate the Ag-high module

```{r "CHIKV heatmaps", fig.width = 6, fig.height = 8.5}
# Heatmap
chikv_heats <- best_feats$cLEC %>%
  imap(~ {
    chikv_so %>%
      subset(lec_type %in% plt_typs & tm == "24hpi") %>%
      create_chikv_heats(gns = .x) +
      theme(
        panel.border = element_rect(color = "grey30"),
        axis.text.x  = element_text(angle = 90, vjust = 0.5)
      )
  })

chikv_heats[[1]]
```

---

<br>

<br>

## Session info
```{r "session info"}
sessionInfo()
```
