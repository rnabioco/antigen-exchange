---
title: "Predicting Ag-archiving Capacity"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc:            true
    toc_float:      true
    toc_depth:      4
    df_print:       "paged"
    code_folding:   "hide"
    self_contained: true
    highlight:      "kate"
params:
  template_dir:  "src"                                                                      # Directory containing template Rmarkdowns
  so_dir:        "~/Dropbox/Ryan/Projects/antigen-exchange/results/sobjs"                   # Directory for loading/saving Seurat objects
  mod_dir:       "~/Dropbox/Ryan/Projects/antigen-exchange/results/models"                  # Directory for loading/saving ML models
  ref_dir:       "ref"                                                                      # Directory to use for loading/saving clustifyr references
  sample_info:   "sample_info.xlsx"
  chikv_so:      "~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs/so_merge.qs"
  res_dir:                                                
    value:
      exp-0: "~/Projects/antigen-tracking/results"
      exp-1: "~/Projects/tamburini-antigen-tracking/results/2022-03-11"
      exp-2: "~/Projects/tamburini-antigen-tracking/results/2022-10-28"
editor_options: 
  chunk_output_type: console
---

```{r "setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# RF parameters
rf_dat_clmn  <- "Ag_class_3"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"

# Run setup chunks
knitr::knit(here::here(params$template_dir, "setup.Rmd"), "")

rm(dc_so, all_meta)

# Set Ag-low/high groups
# * exclude d2 since it has very few cells
# * split for each cell type from each mouse
# * set subtype cutoff for all mice using d14 cutoff
ag_clmns <- c(
  Ag_class_3   = "Ag_score",
  Ag_class_3wk = "Ag_score_3",
  Ag_class_6wk = "Ag_score_6"
)

ag_clmns %>%
  iwalk(~ {
    lec_so <- lec_so %>%
      mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
      cluster_signal(
        data_column  = .x,
        grp_column   = "mouse_type",
        clust_column = .y,
        method       = "km"
      )
    
    # The threshold will be the same for each column since this is set using
    # only the d14 mouse
    threshold <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, !!sym(.y) == "high") %>%
      group_by(subtype) %>%
      summarize(threshold = min(!!sym(.x)), .groups = "drop")
    
    threshold <- set_names(threshold$threshold, threshold$subtype)
    
    lec_so <<- lec_so %>%
      mutate_meta(
        mutate,
        !!sym(.y) := ifelse(!!sym(.x) >= threshold[subtype], "high", "low")
      )
  })

# Identify double-positive cells for the 6wk-3wk mouse
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    Ag_class_6wk_3wk = case_when(
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" & Ag_class_6wk == "high") ~ "double-high",
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" | Ag_class_6wk == "high") ~ "single-high",
      # mouse == "6wk-3wk" & Ag_class_6wk == "high"                            ~ "6wk-single",
      # mouse == "6wk-3wk" & Ag_class_3wk == "high"                            ~ "3wk-single",
      mouse == "6wk"     & Ag_class_6wk == "high"                            ~ "6wk-high",
      mouse == "3wk"     & Ag_class_3wk == "high"                            ~ "3wk-high",
      # mouse == "6wk-3wk" & (Ag_class_3wk == "low" & Ag_class_6wk == "low")   ~ "double-low",
      TRUE                                                                   ~ "low"
    )
  )

# Select LEC subsets to use for RF
rf_typs <- lec_so@meta.data %>%
  filter(mouse == rf_mouse) %>%
  group_by(subtype, !!sym(rf_dat_clmn)) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(subtype) %>%
  filter(all(n > 60)) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  pull(subtype) %>%
  unique()

# Theme elements
pred_clrs <- c(
  `Ag-low`       = "#6A51A3",
  `Ag-competent` = "#E69F00",
  `Ag-high`      = "#D7301F"
)

base_theme <- djvdj_theme() +
  theme(axis.text = element_text(color = "black"))

# Check for RF predictions
run_rf <- !file.exists(here(params$mod_dir, "ag-high_preds.tsv.gz"))
```

```{r "RF functions"}
# Function to predict
rf_predict <- function(mod, dat, data_clmn = NULL, return_stats = TRUE,
                       prob = FALSE) {
  
  prds <- mod %>%
    predict(dat, seed = 42) %>%
    ranger::predictions()
  
  if (prob) {
    classes <- colnames(prds)
    
    prds <- prds %>%
      as.data.frame() %>%
      mutate(pred = ifelse(!!sym(classes[1]) > 0.5, classes[1], classes[2])) %>%
      pull(pred)
  }
  
  res <- dat %>%
    as_tibble(rownames = ".cell_id") %>%
    mutate(pred = prds)
  
  if (is.null(data_clmn)) return(res)
  
  res <- res %>%
    mutate(!!sym(data_clmn) := fct_relevel(!!sym(data_clmn), levels(prds)))
  
  res <- res %>%
    dplyr::select(.cell_id, all_of(data_clmn), pred) %>%
    mutate(correct = pred == !!sym(data_clmn)) %>%
    group_by(pred) %>%
    mutate(frac_correct = sum(correct) / n()) %>%
    ungroup()
  
  if (!return_stats) return(column_to_rownames(res, ".cell_id"))
  
  # Calculate F1 score
  stats <- caret::confusionMatrix(
    data      = res$pred,
    reference = res[[data_clmn]],
    positive  = "high"
  )
  
  stats <- as_tibble(as.list(stats$byClass))
    
  stats
}

#' Generate RF models using given data and parameters
#' 
#' @param df_in data.frame containing features as columns and observations as
#' rows
#' @param data_clmn column in df_in containing response variable
#' @param param_lst list of RF parameters to expand and test
#' @param feat_p p-value cutoff for selecting best features
#' @param min_feats minimum number of features to allow after feature selection
#' @param min_cells minimum number of cells required for each group in data_clmn
#' @param scale_data Should independent variables be scaled
#' @param select_feats should features be filtered based on p-value
#' @param df_list list of data.frames containing data for each mouse to use for
#' comparing the fraction of predicted Ag-high cells. Want a model where the
#' fraction of predicted Ag-high cells is roughly the same for all samples.
#' @param frac_grp group in data_clmn that should be used for calculating and
#' comparing fractions using data in df_list
#' @param balance_groups downsample so groups have the same number of cells
#' @param degs data.frame of DEGs, used to determine which DEGs are markers
#' for each group
#' @param include_objects in output tibble include ranger object, top features,
#' and cell barcodes for training data
#' @param ... additional parameters to pass to ranger::ranger()
train_rf <- function(df_in, data_clmn, param_lst,
                     feat_p = 0.05, min_feats = 20, min_cells = 30,
                     scale_data = FALSE, select_feats = TRUE, df_list = NULL,
                     frac_grp = "high", balance_groups = FALSE,
                     degs = NULL, include_objects = FALSE, ...) {
  
  # Format input data
  rf_dat <- df_in %>%
    dplyr::select(
      all_of(data_clmn),
      where(~ !all(.x == 0))
    ) %>%
    mutate(!!sym(data_clmn) := factor(!!sym(data_clmn))) %>%
    rename_with(~ str_replace_all(.x, "-", "_")) %>%
    rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
    rename_with(~ str_c("x", .x), matches("^[0-9]"))
  
  classes     <- as.character(unique(rf_dat[[data_clmn]]))
  class_sizes <- table(rf_dat[[rf_dat_clmn]])
  
  # Scale data
  if (scale_data) {
    rf_dat <- rf_dat %>%
      mutate(
        across(-all_of(data_clmn), ~ as.numeric(scale(.x)))
      )
  }
  
  # Adjust groups so they are balanced
  # split into train/test data
  if (balance_groups) {
    group_size  <- table(rf_dat[[data_clmn]])
    target_frac <- group_size[[frac_grp]] / sum(group_size)
    sample_size <- floor(min(group_size) / 2)
    
    if (sample_size < min_cells) {
      cli::cli_abort("All groups must have at least {min_cells} cells")
    }

    rf_train <- rf_dat %>%
      rownames_to_column(".cell_id") %>%
      group_by(!!sym(data_clmn))
    
    set.seed(42)
    
    rf_train <- rf_train %>%
      dplyr::sample_n(sample_size) %>%
      column_to_rownames(".cell_id")

    rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
    
  } else {
    set.seed(42)
    
    rf_split <- initial_split(rf_dat, prop = 0.5)
    rf_train <- training(rf_split)
    rf_test  <- testing(rf_split)
  }
  
  # Set parameters to test
  # if class weights are provided, remove repetitive combinations
  rf_params <- expand.grid(param_lst)
  rf_params <- bind_cols(rf_params, list(...))
  
  weight_classes <- all(classes %in% names(rf_params)) && !balance_groups
  
  if (weight_classes) {
    clmns <- colnames(rf_params)
    clmns <- clmns[!clmns %in% classes]
    
    rf_params <- rf_params %>%
      mutate(frac = !!sym(classes[1]) / !!sym(classes[2])) %>%
      distinct(!!!syms(clmns), frac, .keep_all = TRUE) %>%
      dplyr::select(-frac)
  }
  
  n_params    <- nrow(rf_params)
  rf_params$n <- 1:n_params
  
  # Train models
  res <- pmap_dfr(rf_params, ~ {
    args <- list(...)

    # Select training sample
    # if class weights are passed, downsample training data accordingly
    if (weight_classes) {
      train_sizes <- floor(class_sizes / 2)
      
      class_wts <- set_names(as.numeric(args[classes]), classes)
      class_wts <- sort(class_wts, decreasing = TRUE)
      
      train_sizes <- train_sizes[names(class_wts)]
      
      ratio  <- class_wts[[1]] / class_wts[[2]]
      new_sz <- floor(train_sizes[[1]] / ratio)
      new_sz <- max(new_sz, min_cells)
      
      if (new_sz > train_sizes[[2]]) {
        new_sz <- floor(train_sizes[[2]] * ratio)
        new_sz <- max(new_sz, min_cells)
        
        train_sizes[1] <- new_sz
        
      } else {
        train_sizes[2] <- new_sz
      }
      
      rf_train <- rf_dat %>%
        rownames_to_column(".cell_id") %>%
        split(.[[data_clmn]]) %>%
        imap_dfr(~ {
          sz <- train_sizes[[.y]]
          
          set.seed(42)
          
          .x %>%
            dplyr::sample_n(sz) %>%
            column_to_rownames(".cell_id")
        })
      
      rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
      
      args[classes] <- NULL
    }

    # RF parameters
    if (args$mtry > (ncol(rf_train) - 1)) {
      cli::cli_warn("mtry ({args$mtry}) is greater than the number of features")
      
      return(NULL)
    }
    
    args$formula     <- as.formula(str_c(data_clmn, " ~ ."))
    args$data        <- rf_train
    args$importance  <- args$importance %||% "impurity_corrected"
    args$seed        <- args$seed %||% 42
    args$num.threads <- args$num.threads %||% 12
    args$probability <- args$probability %||% FALSE
    
    # Train initial model
    set.seed(42)
    
    raw_mod <- mod <- lift_dl(ranger)(args)
    
    raw_err   <- raw_mod$prediction.error
    key_feats <- importance(raw_mod)
    
    # Feature selection
    # identify most important features, filter, re-train
    if (select_feats) {
      key_feats <- importance_pvalues(raw_mod)
      key_feats <- sort(key_feats[, "pvalue"])
      
      max_p <- key_feats %>%
        head(min_feats) %>%
        max()
      
      feat_p    <- max(max_p, feat_p)
      key_feats <- names(key_feats[key_feats < feat_p])
      n_feats   <- length(key_feats)
      
      # Re-train model
      args$mtry       <- min(args$mtry, n_feats)
      args$data       <- rf_train[, c(data_clmn, key_feats)]
      args$importance <- "none"
      
      set.seed(42)
      
      mod <- lift_dl(ranger)(args)
    }
    
    err <- mod$prediction.error
    
    # Compare fraction predicted groups for each mouse with ground truth
    if (!is.null(df_list)) {
      frac_clmn <- str_c("frac_", frac_grp)
      
      frac_stats <- df_list %>%
        imap_dfr(~ {
          mod %>%
            rf_predict(
              .x,
              data_clmn    = data_clmn,
              return_stats = FALSE,
              prob         = args$probability
            ) %>%
            mutate(sample = .y)
        }) %>%
        group_by(sample) %>%
        summarize(
          !!sym(frac_clmn) := sum(pred == frac_grp) / n(),
          .groups   = "drop"
        ) %>%
        summarize(across(all_of(frac_clmn), list(mean = mean, sd = sd)))
    }
    
    # Test model
    prds <- mod %>%
      rf_predict(
        dat          = rf_test,
        data_clmn    = data_clmn,
        return_stats = TRUE,
        prob         = args$probability
      )

    # Format output table
    res <- tibble(
      n_train   = nrow(rf_train),
      n_test    = nrow(rf_test),
      ...,
      n_feats = length(key_feats),
      oob_raw = raw_err,
      oob     = err
    ) %>%
      bind_cols(prds)
    
    if (!is.null(df_list)) {
      res <- res %>%
        bind_cols(frac_stats)
    }
    
    if (include_objects) {
      res <- res %>%
        mutate(
          mod          = list(mod),
          feats        = list(key_feats),
          training_bcs = list(rownames(rf_train))
        )
    }
    
    cli::cli_alert_info("Training: {args$n} / {n_params}")
    
    res
  })
  
  if (nrow(res) == 0) return(NULL)  # If mtry is too high
  
  res <- res %>%
    arrange(desc(F1))
  
  res
}

create_gn_plots <- function(so_in, gns, plt_clrs, p_alt = "greater", n_gns = 10) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  gn_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns))
  
  plt_dat <- gn_dat %>%
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(
      med = median(value),
      q1  = quantile(value, 0.25),
      q3  = quantile(value, 0.75),
      .groups = "drop"
    ) %>%
    mutate(pred_grp = fct_relevel(pred_grp, names(plt_clrs))) %>%
    group_by(name, mouse, subtype) %>%
    
    filter(sum(med) > 0) %>%
    mutate(cor = cor(as.numeric(pred_grp), med)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse) == n_mice) %>%
    ungroup()
  
  # Calculate p-values
  clmn2 <- names(pred_clrs[2])
  clmn3 <- names(pred_clrs[3])
  
  p_clmns <- c(clmn2, clmn3)
  
  p_dat <- gn_dat %>%
    group_by(mouse, subtype, pred_grp, name) %>%
    mutate(y = quantile(value, 0.75)) %>%
    group_by(mouse, subtype, name) %>%
    summarize(
      y = max(y),
      
      !!sym(clmn2) := wilcox.test(
        value[pred_grp == clmn2], value[pred_grp == "Ag-low"],
        alternative = p_alt
      )$p.value,
      !!sym(clmn3) := wilcox.test(
        value[pred_grp == clmn3], value[pred_grp == "Ag-low"],
        alternative = p_alt
      )$p.value,
      .groups = "drop"
    ) %>%
    group_by(name) %>%
    mutate(y = max(y)) %>%
    
    group_by(mouse, subtype) %>%
    mutate(across(all_of(p_clmns), ~ p.adjust(.x, method = "bonferroni"))) %>%
    ungroup() %>%
    
    pivot_longer(all_of(p_clmns), names_to = "pred_grp", values_to = "p")
  
  # Rank genes by number of significant p-values
  gns <- p_dat %>%
    group_by(name) %>%
    summarize(n = sum(p < 0.05)) %>%
    filter(name %in% plt_dat$name) %>%
    arrange(desc(n)) %>%
    head(n_gns) %>%
    pull(name) %>%
    as.character()
  
  # Create plots
  res <- plt_dat %>%
    filter(name %in% gns) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    ggplot(aes(pred_grp, med, color = mouse)) +
    geom_segment(
      aes(x = pred_grp, xend = pred_grp, y = q1, yend = q3),
      linewidth = 1, color = ln_col
    ) +
    geom_point(aes(size = pred_grp)) +
    geom_smooth(
      aes(x = as.numeric(as.factor(pred_grp))),
      method = "lm", linewidth = 0.25, linetype = 2,
      se = FALSE, formula = y ~ x
    ) +
    geom_point(
      aes(y = y),
      data = filter(p_dat, name %in% gns, p < 0.05),
      position = position_nudge(y = 0.2),
      color = "black", shape = 6, size = 1
    ) +
    facet_grid(name ~ mouse, scales = "free_y", switch = "y") +
    scale_size_manual(values = c(1, 1.25, 1.25)) +
    scale_color_manual(values = m_clrs) +
    scale_y_continuous(breaks = ~ c(ceiling(min(.x)), floor(max(.x)))) +
    base_theme +
    theme(
      aspect.ratio    = 1,
      legend.position = "none",
      panel.border    = element_rect(color = "grey75"),
      strip.placement = "outside",
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1)
    )
  
  res
}

create_sig_umap <- function(so_in, dat_col, grp_col = "mouse", clrs) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = grp_col,
      outline     = TRUE,
      plot_colors = clrs,
      panel_nrow  = 1,
      size        = 0.15,
      stroke      = 0.6
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_grp_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            lvls = c("Ag-competent", "Ag-low", "Ag-high", "other")) {
  so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = grp_col,
      outline     = TRUE,
      plot_colors = clrs,
      plot_lvls   = lvls,
      panel_nrow  = 1,
      size        = 0.25,
      stroke      = 0.8,
      color = ln_col,
      trace_position = "bottom"
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F"),
                         max_gns = 75) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(pred_grp = fct_relevel(pred_grp, lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = "pred_grp", values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character() %>%
    head(max_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(pred_grp, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, sort_gns = "up",
                               lvls = names(pred_clrs), n_gns = 100,
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", "lec_type", "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(lec_type == "cLEC") %>%
    group_by(treatment, name, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  if (identical(sort_gns, "down")) gn_lvls <- rev(gn_lvls)
  
  gn_lvls <- head(gn_lvls, n_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, lec_type) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ lec_type) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.75
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL, clrs = pred_clrs, ...) {
  typ <- str_remove(dat_col, "_[a-zA-Z]+$")
  
  dat <- df_in %>%
    filter(tm == "24hpi", lec_type == typ)
  
  if (nrow(dat) == 0) return(NULL)
  
  res <- dat %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, ...
    ) +
    facet_wrap(~ lec_type, nrow = 1, scales = "free_y") +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = clrs) +
    labs(title = ttl) +
    base_theme +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      # * overall fold enrichment scores for each cell type were not used
      #   in the final version of the GO heatmaps since the overall enrichment
      #   scores are on a much different scale as the other enrichement scores
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  # this is very slow
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}
```

```{r "identify Ag DEGs", eval = run_rf}
# Identify Ag markers for all LECs for each mouse
fc <- 0

deg_so <- lec_so %>%
  SplitObject("mouse")

degs_1 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = "all", mouse = .y) %>%
      arrange(padj)
  })

# Identify Ag markers for subtype
deg_so <- lec_so %>%
  SplitObject("subtype")

degs_2 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y, mouse = "all") %>%
      arrange(padj)
  })

rm(deg_so)

# Identify markers for subtype and mouse
degs_3 <- lec_so@meta.data %>%
  distinct(subtype, mouse) %>%
  pmap_dfr(~ {
    res <- lec_so %>%
      subset(subtype == ..1 & mouse == ..2)
    
    if (n_distinct(res[[rf_dat_clmn]]) < 2) return(NULL)
    
    res <- res %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = ..1, mouse = ..2) %>%
      arrange(padj)
  })

degs <- bind_rows(degs_1, degs_2, degs_3) %>%
  filter(
    padj < 0.05, logFC > fc,
    !grepl("^(mt-|R[pls])", feature),
    feature != "Malat1"
  )

# Write table
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "train RF models", eval = run_rf}
# Test parameters and calculate stats for each LEC subtype
rf_stats <- rf_typs %>%
  map_dfr(~ {
    feats <- degs %>%
      filter(subtype == .x) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == .x & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    all_dat <- lec_so %>%
      subset(subtype == .x & mouse != rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, "mouse", feats))) %>%
      rename_with(~ str_replace_all(.x, "-", "_")) %>%
      rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
      rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
      column_to_rownames(".cell_id") %>%
      split(.$mouse)
    
    # Set RF params to test every combination
    max_mtry <- min(length(feats), 1000)
    
    param_lst <- list(
      mtry          = seq(1, max_mtry, floor(max_mtry / 15)),
      min.node.size = seq(1, 10, 2),
      num.trees     = seq(50, 1000, 100),
      low           = seq(1, 4, 1),
      high          = seq(1, 4, 1)
    )
    
    # Train model
    res <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = param_lst,
        df_list         = all_dat[names(all_dat) != rf_mouse],
        scale_data      = FALSE,
        include_objects = FALSE
      )
    
    if (is.null(res)) return(res)  # If mtry is too high
    
    # Identify best models
    target_frac <- sum(rf_dat[[rf_dat_clmn]] == "high") / nrow(rf_dat)
    
    res <- res %>%
      arrange(desc(F1)) %>%
      mutate(
        subtype     = .x,
        target_frac = target_frac,
        rank        = row_number()
      )
      
    res
  })

# Train models based on best parameters
# sort based on balanced accuracy and F1 score
rf_mods <- rf_stats %>%
  group_by(subtype) %>%
  slice_max(`Balanced Accuracy`, prop = 0.2) %>%
  slice_max(F1, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  split(.$subtype)

rf_mods <- rf_mods %>%
  imap_dfr(~ {
    feats <- degs %>%
      filter(subtype == .y) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == .y & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
        
        rf_dat %>%
          train_rf(
            data_clmn       = rf_dat_clmn,
            param_lst       = args[stats],
            include_objects = TRUE
          ) %>%
          mutate(subtype = args$subtype)
      })
  })

# Save RF models
rf_stats %>%
  write_tsv(here(params$mod_dir, "ag-high_models.tsv.gz"))

rf_mods %>%
  qsave(here(params$mod_dir, "ag-high_models.qs"))
```

```{r "assess model performance with CHIKV data", eval = run_rf}
# Identify top models for each cell type
# !! stats in rf_stats do not match stats produced during model training !!
# !! a key difference is the number of test and training cells           !!
# rf_stats <- read_tsv(here(params$mod_dir, "ag-high_stats.tsv.gz"))
rf_stats <- rf_stats %>%
  distinct(high / low, F1, `Balanced Accuracy`, .keep_all = TRUE) %>%
  group_by(subtype) %>%
  slice_max(`Balanced Accuracy`, prop = 0.2) %>%
  slice_max(F1, n = 100, with_ties = FALSE) %>%
  ungroup()

# Format CHIKV RF data
# need to add zeros for missing genes
chikv_so <- qread(params$chikv_so) %>%
  subset(treatment == "mock" & tm == "24hpi" & rep == 1)

chikv_feats <- degs %>%
  pull(feature) %>%
  unique()

chikv_dat <- chikv_so %>%
  FetchData(c("lec_type", chikv_feats))

missing_gns <- chikv_feats[!chikv_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Check model performance using some CHIKV data
# assess fold change in module score for one mock CHIKV replicate
# CLEAN THIS UP
rf_stats <- rf_stats %>%
  pmap_dfr(~ {
    args <- list(...)
    
    # Train model
    feats <- degs %>%
      filter(subtype == args$subtype) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
    
    mod <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = args[stats],
        include_objects = TRUE
      ) %>%
      mutate(subtype = args$subtype)
    
    # Pull top features
    mod_feats <- mod$feats[[1]] %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    mod_feats <- degs %>%
      filter(feature %in% mod_feats) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
    
    # Predict using models for each LEC subset
    chikv_dat <- chikv_dat %>%
      filter(lec_type == mod$subtype) %>%
      dplyr::select(-lec_type)
    
    chikv_preds <- mod$mod[[1]] %>%
      rf_predict(
        dat = chikv_dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
    
    chikv_so <- chikv_so %>%
      subset(lec_type == mod$subtype) %>%
      AddMetaData(chikv_preds)
    
    # Add module scores
    clmn_nms <- names(mod_feats)
    
    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      names(mod_feats)
    )
    
    chikv_so <- chikv_so %>%
      AddModuleScore(
        features = mod_feats,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
    
    # Calculate fold change for low and high groups
    chikv_stats <- chikv_so@meta.data %>%
      mutate(
        min_val = min(c(high, low)),
        across(c(high, low), ~ ifelse(min_val < 0, .x + abs(min_val), .x)),  # correct negative values
        
        high_mod_p = wilcox.test(                                            # calculate p-values
          high[pred == "high"], high[pred == "low"],
          alternative = "greater"
        )$p.value,
        low_mod_p = wilcox.test(
          low[pred == "high"], low[pred == "low"], 
          alternative = "less"
        )$p.value
      ) %>%
      group_by(pred, high_mod_p, low_mod_p) %>%                              # calculate median
      summarize(across(c(high, low), median), .groups = "drop") %>%
      summarize(                                                             # calculate fold change
        across(ends_with("_mod_p"), unique),
        high_mod_fc = high[pred == "high"] / high[pred == "low"],
        low_mod_fc  = low[pred == "high"]  / low[pred == "low"]
      )
    
    # Return stats
    res <- mod %>%
      bind_cols(chikv_stats)
    
    res
  })

# Select best model
# train models based on best parameters
# sort based on fold change in module score
rf_mods <- rf_stats %>%
  filter(high_mod_fc >= 1.2, low_mod_fc < 0.9) %>%
  arrange(desc(F1), desc(high_mod_fc), low_mod_fc) %>%
  group_by(subtype) %>%
  dplyr::slice(1) %>%
  ungroup()

# rf_mods <- rf_mods %>%
#   imap_dfr(~ {
#     feats <- degs %>%
#       filter(subtype == .y) %>%
#       pull(feature) %>%
#       unique()
#     
#     rf_dat <- lec_so %>%
#       subset(subtype == .y & mouse == rf_mouse) %>%
#       FetchData(unique(c(rf_dat_clmn, feats)))
#     
#     .x %>%
#       pmap_dfr(~ {
#         args <- list(...)
#         stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
#         
#         rf_dat %>%
#           train_rf(
#             data_clmn       = rf_dat_clmn,
#             param_lst       = args[stats],
#             include_objects = TRUE
#           ) %>%
#           mutate(subtype = args$subtype)
#       })
#   })

# Save filtered models
rf_mods %>%
  qsave(here(params$mod_dir, "ag-high_models.qs"))

rf_stats %>%
  dplyr::select_if(~ !is.list(.x)) %>%
  write_tsv(here(params$mod_dir, "ag-high_stats.tsv.gz"))
```

```{r "RF features", eval = run_rf}
# Pull best features
rf_feats <- rf_mods %>%
  pmap(~ {
    args <- list(...)
    
    fts <- args$feats %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    degs %>%
      filter(feature %in% fts) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
  })

names(rf_feats) <- rf_mods$subtype

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Save top features
rf_feats %>%
  qsave(here(params$mod_dir, "ag-high_features.qs"))
```

```{r "predict Ag class", eval = run_rf}
# Predict Ag class
# remove cells used to train models
train_cells <- unlist(rf_mods$training_bcs)
keep_cells  <- Cells(lec_so)
keep_cells  <- keep_cells[!keep_cells %in% train_cells]

info_clmns <- c("subtype", "mouse")

pred_dat <- lec_so %>%
  subset(cells = keep_cells) %>%
  FetchData(unique(c(rf_dat_clmn, info_clmns, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  mutate(mouse = as.character(mouse)) %>%
  column_to_rownames(".cell_id")

rf_preds <- rf_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Predict Ag class using cLEC model
rf_preds_2 <- rf_mods %>%
  filter(subtype == "cLEC") %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Write table with predictions
rf_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz"))

rf_preds_2 %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_cLEC_preds.tsv.gz"))
```

```{r "load models", eval = !run_rf}
# Load saved objects
rf_mods <- qread(here(params$mod_dir, "ag-high_models.qs"))
degs <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

rf_preds <- read_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")

rf_feats <- qread(here(params$mod_dir, "ag-high_features.qs"))

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()
```

```{r "format data"}
# Format prediction labels
# training data was removed before predicting
lec_so <- lec_so %>%
  AddMetaData(rf_preds, col.name = str_c("rf_", colnames(rf_preds)))
  # AddMetaData(rf_preds_2, col.name = str_c("rf_", colnames(rf_preds_2), "_2"))

lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    pred_grp = ifelse(
      rf_pred == "high" & !rf_correct,
      "Ag-competent", str_c("Ag-", !!sym(rf_dat_clmn))
    ),
    rf_pred       = str_c("Ag-", rf_pred),
    mouse         = fct_relevel(mouse, mice),
    training_data = is.na(rf_pred)
  )

# Add module scores
rf_feats %>%
  iwalk(~ {
    clmn_nms <- str_c(.y, "_", names(.x))

    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      clmn_nms
    )

    lec_so <<- lec_so %>%
      AddModuleScore(
        features = .x,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
  })

# Remove day 2 timepoint
lec_df <- lec_so@meta.data

lec_so <- lec_so %>%
  subset(mouse != "d2")
```

```{r "predict CHIKV"}
# Load CHIKV data
chikv_so <- qread(params$chikv_so)

# Format RF data
# need to add zeros for missing genes
# scaling genes across entire dataset yields predications more in line with
# Ag data (e.g. fraction Ag-high is roughly the same)
clmns <- c(
  "orig.ident", "rep", "treatment", "tm",
  "cell_type_2", "cell_type", "lec_type", "subtype",
  "UMAP_1", "UMAP_2"
)

chikv_dat <- chikv_so %>%
  FetchData(c(clmns, all_feats))

missing_gns <- all_feats[!all_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Predict using models for each LEC subset
chikv_preds <- rf_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- chikv_dat %>%
      filter(lec_type == args$subtype) %>%
      dplyr::select(-all_of(clmns))
    
    args$mod %>%
      rf_predict(
        dat = dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
  })

chikv_so <- chikv_so %>%
  AddMetaData(chikv_preds)

rf_feats %>%
  iwalk(~ {
    clmn_nms <- str_c(.y, "_", names(.x))

    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      clmn_nms
    )

    chikv_so <<- chikv_so %>%
      AddModuleScore(
        features = .x,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
  })

# Save predictions
chikv_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz"))
```



```{r "TEST PLOTS MODS", eval = FALSE}
# Predict Ag class
pred_dat <- lec_so %>%
  FetchData(unique(c(rf_dat_clmn, "subtype", "mouse", unique(degs$feature)))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  column_to_rownames(".cell_id") %>%
  split(.$subtype)

# Create bargraphs
bar_plts <- rf_mods %>%
  pmap(~ {
    args <- list(...)
    
    preds <- pred_dat[[args$subtype]] %>%
      split(.$mouse) %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
    
    # Format prediction labels
    bar_dat <- lec_so %>%
      AddMetaData(preds, col.name = c("rf_pred", "rf_correct")) %>%
      mutate_meta(
        mutate,
        pred_grp = case_when(
          !!sym(rf_dat_clmn) == "high" ~ !!sym(rf_dat_clmn),
          rf_pred            == "high" ~ "high-pred",
          TRUE                         ~ !!sym(rf_dat_clmn)
        ),
        mouse    = fct_relevel(mouse, mice),
        training = .cell_id %in% args$training_bcs
      )
    
    # Format data
    bar_dat <- bar_dat@meta.data %>%
      filter(
        subtype == args$subtype,
        !training
      ) %>%
      rename(prediction = rf_pred, correct = rf_correct) %>%
      mutate(correct = fct_relevel(as.character(correct), c("TRUE", "FALSE")))
    
    bar_thm <- base_theme +
      theme(
        aspect.ratio    = 1.4,
        axis.title      = element_blank(),
        legend.position = "none",
        axis.text.x     = element_text(angle = 45, hjust = 1),
        axis.text.y     = element_blank(),
        axis.ticks.y    = element_blank(),
        plot.title      = element_text(hjust = 0.5)
      )
    
    # Plot fraction predicted groups
    bar_1 <- bar_dat %>%
      ggplot(aes(mouse, fill = prediction, alpha = correct)) +
      geom_bar(position = "fill") +
      scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
      scale_fill_manual(values = pred_clrs) +
      facet_grid(~ subtype) +
      ggtitle(as.character(args$rank)) +
      bar_thm
    
    bar_2 <- bar_dat %>%
      ggplot(aes(mouse, fill = pred_grp)) +
      geom_bar(position = "fill", alpha = 0.85) +
      facet_grid(~ subtype) +
      scale_fill_manual(values = pred_clrs) +
      bar_thm +
      theme(legend.title = element_blank())
    
    wrap_plots(
      bar_1, bar_2, 
      nrow = 1
    ) 
  })

wrap_plots(bar_plts)
```

```{r "OPTIMIZE RF PARAMETERS WITH RF", eval = FALSE}
mod_dat <- rf_mods %>%
  filter(subtype == "cLEC") %>%
  dplyr::select(oob, mtry, min.node.size, num.trees) %>%
  as.data.frame()

mod_dat   <- initial_split(mod_dat)
mod_train <- training(mod_dat)
mod_test  <- testing(mod_dat)

mod_mod <- ranger(
  oob ~.,
  data = mod_train
)

train_mod <- ranger(
  oob ~.,
  data = 
)



# Format data for model
# cLEC DEGs from all timepoints
feats <- degs %>%
  filter(subtype == rf_cell_type) %>%
  pull(feature) %>%
  unique()

rf_dat <- lec_so %>%
  subset(subtype == rf_cell_type & mouse == rf_mouse) %>%
  FetchData(unique(c(rf_dat_clmn, feats))) %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

rf_train <- rf_dat %>%
  rownames_to_column(".cell_id") %>%
  split(.[[rf_dat_clmn]]) %>%
  imap_dfr(~ {
    set.seed(42)
    
    .x %>%
      dplyr::sample_n(135) %>%
      column_to_rownames(".cell_id")
  })

rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
```

```{r "OPTIMIZE RF PARAMETERS MLRMBO", eval = FALSE}
# Install and load required packages
pak::pkg_install("mlr")
pak::pkg_install("mlrMBO")
library(mlr3)
library(mlrMBO)

# Format data for model
# cLEC DEGs from all timepoints
feats <- degs %>%
  filter(subtype == rf_cell_type) %>%
  pull(feature) %>%
  unique()

rf_dat <- lec_so %>%
  subset(subtype == rf_cell_type & mouse == rf_mouse) %>%
  FetchData(unique(c(rf_dat_clmn, feats))) %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

rf_train <- rf_dat %>%
  rownames_to_column(".cell_id") %>%
  split(.[[rf_dat_clmn]]) %>%
  imap_dfr(~ {
    set.seed(42)
    
    .x %>%
      dplyr::sample_n(135) %>%
      column_to_rownames(".cell_id")
  })

rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]

# Define the search space
param_space <- makeParamSet(
  makeIntegerParam("num.trees",     lower = 50, upper = 1000),
  makeIntegerParam("mtry",          lower = 1,  upper = 20),
  makeIntegerParam("min.node.size", lower = 1,  upper = 20)
)

# Define the objective function
cross_validation_rf <- function(num.trees, mtry, min.node.size, data,
                                clmn = "Ag_class_2") {
  
  # Define the task
  task <- makeClassifTask(data = data, target = clmn)
  
  # Define the learner with hyperparameters to be optimized
  learner <- makeLearner(
    "classif.ranger",
    predict.type  = "prob",
    num.trees     = num.trees,
    mtry          = mtry,
    min.node.size = min.node.size
  )
  
  # Define the resampling strategy (e.g., 10-fold cross-validation)
  resampling <- makeResampleDesc("CV", iters = 10)
  
  # Define a measure (e.g., AUC) for evaluation
  measure <- mlr::auc
  
  # Perform the cross-validation
  result <- resample(learner, task, resampling, measures = measure)
  
  # Return the performance metric (e.g., AUC) from cross-validation
  return(result$aggr[1])
}

rf_optimization_problem <- makeSingleObjectiveFunction(
  fn = function(par.set) {
    # Inside this function, you can define the objective to be minimized.
    # par.set is a parameter set that represents the hyperparameters to be optimized.
    
    num.trees     <- as.integer(par.set[["num.trees"]])
    mtry          <- as.integer(par.set[["mtry"]])
    min.node.size <- as.integer(par.set[["min.node.size"]])
    
    # Here, you would perform cross-validation with the given hyperparameters and return the performance metric.
    # For example, you could use AUC as the performance metric.
    performance <- cross_validation_rf(
      num.trees, mtry, min.node.size,
      data = rf_train[, c(rf_dat_clmn, key_feats)]
    )
    
    # Return the negative AUC because mlrMBO minimizes the objective function
    return(-performance)
  },
  par.set = param_space
)

# Initialize the optimization process
opt <- makeMBOControl()

# Set the maximum number of iterations
opt$BUDGET = 1000  # Replace 100 with your desired number of iterations

# Run the Bayesian optimization
result <- mbo(rf_optimization_problem, control = opt)

# Get the best hyperparameters
best_hyperparameters <- result$x

# Test best parameters
# Train model
rf_args            <- best_hyperparameters
rf_args$formula    <- factor(Ag_class_2) ~.
rf_args$data       <- rf_train
rf_args$importance <- "impurity_corrected"

mod <- lift_dl(ranger)(rf_args)

# Feature selection
key_feats <- mod %>%
  importance_pvalues() %>%
  .[, "pvalue"] %>%
  sort()

key_feats <- names(key_feats[key_feats < 0.05])

# Re-train model
rf_args$data       <- rf_train[, c(rf_dat_clmn, key_feats)]
rf_args$importance <- "none"

mod <- lift_dl(ranger)(rf_args)
```

```{r "COMPARE OLD LIST", eval = FALSE}
old_feats <- qread("~/Dropbox/Ryan/Projects/antigen-exchange/results/models/2023-10-16/ag-high_features.qs")

x <- old_feats$cLEC$high
y <- rf_feats$cLEC$high

x[!x %in% y]

y[!y %in% x]
```

```{r "DATA CLUB SLIDE", fig.width = 8.1, fig.height = 9, eval = FALSE}
# Format data for plotting
clrs <- c(
  `Ag-low`  = "#56B4E9",
  `Ag-high` = "#D7031F" 
)

dat <- lec_df %>%
  filter(mouse == "d14") %>%
  mutate(
    Ag_class_3 = str_c("Ag-", Ag_class_3),
    Ag_class_3 = fct_relevel(Ag_class_3, names(clrs))
  )

# Create UMAP
u <- dat %>%
  plot_scatter(
    "Ag_score",
    x = "hUMAP_1", y = "hUMAP_2",
    plot_colors = c("lightblue", "white", pred_clrs["Ag-high"]),
    size = 0.15,
    stroke = 0.75,
    outline = TRUE
  ) +
  guides(fill = guide_colorbar(
    ticks = FALSE,
    barwidth = unit(130, "pt"),
    barheight = unit(7, "pt"),
    title = "Ag-score", title.position = "top", title.hjust = 0.5
  )) +
  umap_theme_2 +
  theme(
    # aspect.ratio = 0.75,
    # legend.text     = element_blank()
    plot.margin     = margin(r = 5, b = 5, l = 5),
    legend.position = "top"
  )

# Create histogram
hst <- dat %>%
  filter(subtype == rf_cell_type) %>%
  ggplot(aes(Ag_score, fill = Ag_class_3)) +
  geom_histogram(alpha = 0.9) +
  scale_fill_manual(values = clrs) +
  scale_y_continuous(expand = expansion(c(0.05, 0.4))) +
  guides(fill = guide_legend(title = "Ag-class")) +
  labs(x = "Ag-score", y = "number of cells") +
  base_theme +
  theme(
    aspect.ratio    = 0.6,
    legend.position = c(0.25, 0.6)
  )

# Plot F1 scores
f1 <- f1_scores %>%
  filter(subtype == mod_type, mouse == rf_mouse) %>%
  ggplot(aes(subtype, F1)) +
  geom_col(fill = "#E69F00", width = 0.75) +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  labs(y = "F1 score", x = "Cell type") +
  base_theme +
  theme(
    aspect.ratio = 1.2,
    axis.title.x = element_blank(),
    axis.text.x  = element_text(angle = 45, hjust = 1, size = txt_pt1),
  )

# Plot Ag module scores
ag_mods <- str_c(rf_cell_type, c("_high", "_low"))

lab_fn <- function(x) {
  x %>%
    str_remove("[a-zA-Z0-9]+_") %>%
    str_c("Ag-", ., " module")
}

bx_dat <- dat %>%
  filter(!training_data, subtype == rf_cell_type) %>%
  pivot_longer(all_of(ag_mods))
  
bxs <- bx_dat %>%
  ggplot(aes(Ag_class_3, value, fill = Ag_class_3, color = Ag_class_3)) +
  geom_boxplot(outlier.size = 0.25, alpha = 0.6, size = 0.75) +
  facet_wrap(~ name, nrow = 1, scales = "free", labeller = as_labeller(lab_fn)) +
  scale_color_manual(values = clrs) +
  scale_fill_manual(values = clrs) +
  labs(y = "Ag module expression") +
  base_theme +
  theme(
    aspect.ratio    = 2,
    legend.position = "none",
    strip.clip      = "off",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1, size = txt_pt1)
  )

# Plot CHIKV predictions
treat_clrs <- c(mock = "#009E73", CHIKV = "#6A51A3")
n_reps     <- n_distinct(chikv_so$rep)

chikv_dat <- chikv_so@meta.data %>%
  filter(lec_type == rf_cell_type) %>%
  mutate(treatment = fct_relevel(treatment, names(treat_clrs)))

br_dat <- chikv_dat %>%
  group_by(treatment, rep) %>%
  summarize(
    frac = sum(pred == "high") / n(),
    .groups = "drop"
  ) %>%
  mutate(
    p = t.test(
      frac[treatment == "mock"],
      frac[treatment == "CHIKV"]
    )$p.value
  ) %>%
  rowwise() %>%
  mutate(
    plab = .format_pvalue(p),
    plab = str_c("italic(p) == ", plab) 
  )

chikv_brs <- br_dat %>%
  ggplot(aes(treatment, frac, fill = treatment, alpha = rep)) +
  geom_col(position = position_dodge2()) +
  geom_text(
    aes(x = 1.5, y = 1, label = plab),
    check_overlap = TRUE, parse = TRUE
  ) +
  scale_alpha_manual(values = rep(1, n_reps)) +
  scale_fill_manual(values = treat_clrs) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  labs(y = "fraction predicted\narchiving-competent") +
  base_theme +
  theme(
    aspect.ratio    = 1.2,
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(size = txt_pt1)
  )

# Plot module score for CHIKV
chikv_bxs <- chikv_dat %>%
  plot_violin(
    "cLEC_high",
    cluster_col = "treatment",
    plot_colors = treat_clrs,
    draw_quantiles = c(0.25, 0.75),
    alpha      = 0.6,
    size       = 0.75,
    point.size = 2,
    n_label    = "none"
  ) +
  labs(y = "Ag-high module\nexpression") +
  base_theme +
  theme(
    aspect.ratio    = 1.2,
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(size = txt_pt1)
  )

# Create final figure
wrap_plots(
  u, hst, f1, bxs, chikv_brs, chikv_bxs,
  ncol = 2,
  heights = c(1, 0.8, 0.8)
)

ggsave(here("docs/data_club_fig.png"), width = 8.1, height = 9, dpi = 400)
```

---

<br>

## Summary

* The goal of this project is to use machine learning to predict Ag archiving
  capacity (or ability) in LECs from naive mice.
* For a proof of principle analysis, Ag-tracking data for d14 cLECs was used to
  train a random forest classifier to predict Ag status
* Using this model we defined a gene program that correlates with Ag status at
  various timepoints
* Archiving "competent" cLECs can be predicted in the CHIKV LN scRNA-seq data
* There is a reduction in archiving-competent cLECs in CHIKV-infected mice and
  a broad downregulation of the Ag-archiving gene program
* The central goal for this project is to optimize the model
  (e.g. expand to other cell types)
  and use it to assess archiving capacity in samples that did not receive an
  Ag-tag (e.g. other published datasets). We can then identify
  perturbations/treatments etc that are predicted to impair archiving.

<br>

Ag signal is shown below for broad cell types identified in the CD45- dataset.

```{r "Ag signal broad cell types", fig.width = 7.5, fig.height = 3.5}
# ADJUST CELL TYPE ANNOTATIONS FOR PLOTS
# NEED TO FIX SETUP CODE
# adjust epithelial cells based on E-cadherin and cytokeratin-8
# adjust stem cells based on Cd79a, these should be B cells
cd45neg_so <- qread(here(params$so_dir, "cd45neg_so.qs"))

clst_clmn <- "RNA_snn_res.5"

cd45neg_so <- cd45neg_so %>%
  classify_markers(
    feats    = c("Cdh1", "Krt8"),
    filt     = Cdh1 > 0.75 & Krt8 > 0.75,
    type     = "Epithelial cells",
    clst_col = clst_clmn,
    type_col = "cell_type"
  ) %>%
  classify_markers(
    feats    = c("Ptprc", "Cd79a", "Cd19"),
    filt     = Ptprc > 1 & Cd79a > 1.5 & Cd19 > 0.5,
    type     = "B cells",
    clst_col = clst_clmn,
    type_col = "cell_type"
  )

# Format data for plotting
dat <- cd45neg_so@meta.data %>%
  filter(mouse != "6wk-3wk") %>%
  mutate(
    mouse = fct_relevel(mouse, mice)
  )

rm(cd45neg_so)

u_lvls <- c("LEC", "BEC", "Epithelial cells")

# Create UMAP
u <- dat %>%
  plot_scatter(
    data_col    = "cell_type",
    x           = "hUMAP_1",
    y           = "hUMAP_2",
    size        = 0.001,
    plot_colors = typ_clrs,
    plot_lvls   = u_lvls,
    panel_nrow  = 1
  ) +
  umap_theme +
  theme(legend.position = "none")

# Create violin plot
v_lvls <- fct_reorder(dat$cell_type, dat$Ag_score, median) %>%
  levels()

vln <- dat %>%
  filter(subtype != "unassigned") %>%
  plot_violin(
    "Ag_score",
    "cell_type",
    plot_colors    = typ_clrs,
    plot_lvls      = v_lvls,
    point.color = "black",
    # color          = "black",
    # alpha          = 1,
    scale          = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  labs(y = "Ag-score") +
  coord_flip() +
  base_theme +
  theme(
    aspect.ratio    = 1.2,
    legend.position = "none",
    axis.title.y    = element_blank()
  )

# Create final figure
plot_grid(
  u, vln,
  rel_widths = c(1, 0.8),
  align = "h",
  axis  = "tb",
  nrow  = 1
)
```

```{r "RF GENE EXPRESSION ALL CELL TYPES", eval = FALSE}
dat <- cd45neg_so %>%
  AddModuleScore(features = list(rf_feats$cLEC$high)) %>%
  FetchData(c("orig.ident", "mouse", "cell_type", "subtype", "Cluster1")) %>%
  as_tibble(rownames = ".cell_id")

dat %>%
  plot_violin(
    "Cluster1", "cell_type",
    plot_colors = typ_clrs,
    method = "boxplot",
    group_col = "mouse"
  )

dat %>%
  plot_violin(
    "Cluster1", "subtype",
    plot_colors = lec_clrs,
    method = "boxplot",
    group_col = "mouse"
  )
```

<br>

Ag signal is shown below for day 14 LEC subsets.

```{r "Ag signal LEC subsets", fig.width = 6.5, fig.height = 3.5}
# Format data for plotting
dat <- lec_so@meta.data %>%
  filter(mouse != "6wk-3wk") %>%
  mutate(
    mouse = fct_relevel(mouse, mice)
  )

u_lvls <- c("LEC", "BEC", "Epithelial cells")

# Create UMAP
u <- dat %>%
  plot_scatter(
    data_col    = "subtype",
    x           = "hUMAP_1",
    y           = "hUMAP_2",
    size        = 0.001,
    plot_colors = lec_clrs,
    plot_lvls   = u_lvls,
    panel_nrow  = 1
  ) +
  umap_theme +
  theme(legend.position = "none")

# Create violin plot
v_dat <- dat %>%
  filter(subtype != "unassigned", mouse == "d14")
  
v_lvls <- fct_reorder(v_dat$subtype, v_dat$Ag_score, median) %>%
  levels()

vln <- v_dat %>%
  plot_violin(
    "Ag_score",
    cluster_col    = "subtype",
    plot_colors    = lec_clrs,
    plot_lvls      = v_lvls,
    point.color = "black",
    # color          = "black",
    # alpha          = 1,
    # scale          = "width",
    draw_quantiles = c(0.25, 0.75)
  ) +
  facet_wrap(~ tm, labeller = as_labeller((function(x) str_c("day ", x)))) +
  labs(y = "Ag-score") +
  coord_flip() +
  base_theme +
  theme(
    aspect.ratio    = 1.2,
    legend.position = "none",
    axis.title.y    = element_blank()
  )

# Create final figure
plot_grid(
  u, vln,
  rel_widths = c(1, 0.8),
  align = "h",
  axis  = "tb",
  nrow  = 1
)
```

<br>

Ag signal is shown below for cLEC subsets for each timepoint.

```{r "Ag signal LEC subsets 2", fig.width = 9, fig.height = 6}
# Format data for plotting
dat <- lec_df %>%
  filter(mouse != "6wk-3wk")

# UMAPs showing LEC subsets
u_typ <- dat %>%
  plot_scatter(
    data_col    = "subtype",
    x           = "hUMAP_1",
    y           = "hUMAP_2",
    group_col   = "tm",
    plot_colors = lec_clrs,
    size        = 0.001,
    panel_nrow  = 1
  ) +
  guides(color = guide_legend(ncol = 2, override.aes = list(size = 3))) +
  umap_theme_2 +
  theme(legend.title = element_blank())

# UMAPs showing Ag signal
u_ag <- dat %>%
  plot_scatter(
    data_col    = "Ag_score",
    x           = "hUMAP_1",
    y           = "hUMAP_2",
    group_col   = "tm",
    plot_colors = c("lightblue", "white", "red"),
    size        = 0.01,
    panel_nrow  = 1
  ) +
  guides(color = guide_colorbar(
    ticks = FALSE,
    title = "Ag-score",
    barwidth = unit(5, "pt"), barheight = unit(70, "pt")
  )) +
  umap_theme_2
  
# Violin plots showing Ag signal
v_ag <- dat %>%
  filter(subtype != "unassigned") %>%
  plot_violin(
    data_col       = "Ag_score",
    cluster_col    = "subtype",
    group_col      = "tm",
    plot_colors    = lec_clrs,
    method = "boxplot",
    # point.color = "black",
    # scale          = "width",
    # draw_quantiles = c(0.25, 0.75),
    outlier.alpha  = 1,
    outlier.size   = 0.1,
    panel_nrow     = 1,
    n_label        = "none"
  ) +
  labs(y = "Ag-score") +
  base_theme +
  theme(
    aspect.ratio    = 0.9,
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )

# Create final figure
wrap_plots(
  u_typ, u_ag, v_ag,
  ncol = 1
)
```

<br>

```{r "LEC Ag scores over time", fig.width = 8, fig.height = 2}
# Data for boxplots
dat <- lec_df %>%
  filter(
    mouse != "6wk-3wk",
    !subtype %in% c("unassigned")
    # exp %in% c("exp-0", "exp-1")
  ) %>%
  group_by(subtype) %>%
  filter(all(table(tm) >= 5)) %>%
  ungroup() %>%
  mutate(subtype = fct_reorder(subtype, Ag_score, mean, .desc = TRUE))

typ_ag_lvls <- levels(dat$subtype)

# Create boxplots
dat %>%
  ggplot(aes(tm, Ag_score, fill = subtype)) +
  
  geom_smooth(
    data = dat,
    method = "loess",
    se = FALSE, color = "grey85", linewidth = 0.5, fill = "black", linetype = 2
  ) +
  geom_boxplot(aes(group = mouse), outlier.size = 0.2, width = 3, key_glyph = draw_key_point) +
  
  guides(
    fill = guide_legend(override.aes = list(size = 4, shape = 22), order = 1),
    linetype = guide_legend(override.aes = list(color = "black"), title = NULL)
  ) +
  facet_grid(~ subtype) +
  
  scale_fill_manual(values = lec_clrs) +
  labs(x = "days post vaccination", y = "Ag-score") +
  base_theme +
  theme(
    aspect.ratio    = 0.9,
    legend.position = "none",
    plot.margin     = margin(0, 15, 0, 15)
  )
```

---

<br>

<br> 

## Classifying Ag-high

Ag-low and -high cells were identified by separately clustering each LEC subset
for each sample into two groups based on Ag-score. For the 6wk-3wk sample,
the 3wk Ag score is used. Ag-low/high classifications
used for the analysis are shown below.

```{r "Ag signal", fig.width = 10, fig.height = 5}
# Cell types to plot
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

# Format plotting data
plt_dat <- lec_so@meta.data %>%
  filter(subtype %in% plt_typs)

# Format plot labels
plt_labs <- plt_dat %>%
  group_by(subtype, mouse, !!sym(rf_dat_clmn)) %>%
  summarize(
    n = label_comma()(n()),
    .groups = "drop"
  ) %>%
  mutate(
    n = str_c(!!sym(rf_dat_clmn), ": ", n, " cells"),
    !!sym(rf_dat_clmn) := fct_relevel(!!sym(rf_dat_clmn), names(pred_clrs))
  ) %>%
  group_by(subtype, mouse) %>%
  arrange(!!sym(rf_dat_clmn)) %>%
  mutate(n = str_c(n, collapse = "\n"))
  
# Create histograms
plt_dat %>%
  ggplot(aes(Ag_score, after_stat(count) + 1, fill = mouse, alpha = !!sym(rf_dat_clmn))) +
  geom_histogram(bins = 30) +
  geom_text(
    aes(Inf, Inf, label = n),
    data = plt_labs,
    check_overlap = TRUE,
    alpha = 1,
    hjust = 1.1,
    vjust = 1.1,
    size  = txt_pt1 / .pt * 0.65
  ) +
  facet_grid(mouse ~ subtype, scales = "free") +
  guides(fill = "none", alpha = guide_legend(title = "Ag group")) +
  scale_alpha_manual(values = c(low = 0.35, high = 1)) +
  scale_fill_manual(values = m_clrs) +
  scale_y_log10(expand = expansion(c(0.05, 0.2))) +
  labs(x = "Ag-score", y = "number of cells") +
  base_theme +
  theme(aspect.ratio = 0.7)
```

<br>

Ag-low and -high cells are shown below for cLECs.

```{r "cLEC Ag signal", fig.width = 10, fig.height = 2.5}
# Cell types to plot
plt_typs <- "cLEC"

# Format plotting data
plt_dat <- lec_df %>%
  filter(
    subtype %in% plt_typs,
    mouse != "6wk-3wk"
  )

# Format plot labels
plt_labs <- plt_dat %>%
  group_by(subtype, mouse, tm, !!sym(rf_dat_clmn)) %>%
  summarize(
    n = label_comma()(n()),
    .groups = "drop"
  ) %>%
  mutate(
    n = str_c(!!sym(rf_dat_clmn), ": ", n, " cells"),
    !!sym(rf_dat_clmn) := fct_relevel(!!sym(rf_dat_clmn), names(pred_clrs))
  ) %>%
  group_by(subtype, mouse, tm) %>%
  arrange(!!sym(rf_dat_clmn)) %>%
  mutate(n = str_c(n, collapse = "\n"))
  
# Create bargraphs
hsts <- tms %>%
  imap(~ {
    dat <- plt_dat %>%
      filter(tm == .x) %>%
      mutate(mouse = as.character(mouse))
    
    fst <- .y == 1
    lst <- .y == length(tms)
    
    br <- dat %>%
      ggplot(aes(y = mouse, fill = mouse, alpha = !!sym(rf_dat_clmn))) +
      geom_bar() +
      facet_wrap(~ tm, nrow = 1, scales = "free") +
      scale_alpha_manual(values = c(low = 0.35, high = 1)) +
      scale_fill_manual(values = m_clrs) +
      scale_y_discrete(expand = expansion(c(0, 0))) +
      scale_x_continuous(expand = expansion(c(0, 0))) +
      base_theme +
      theme_void() +
      theme(
        legend.position = "none",
        strip.text      = element_text(size = 11),
        plot.margin     = margin(t = 5)
      )
    
    # Create histograms
    hst <- dat %>%
      ggplot(aes(Ag_score, fill = mouse, alpha = !!sym(rf_dat_clmn))) +
      geom_histogram(bins = 30) +
      geom_text(
        aes(Inf, Inf, label = n),
        data = filter(plt_labs, tm == .x),
        check_overlap = TRUE,
        alpha = 1,
        hjust = 1.1,
        vjust = 1.1,
        size  = txt_pt1 / .pt * 0.65
      ) +
      facet_wrap(~ tm, scales = "free", nrow = 1) +
      guides(fill = "none", alpha = guide_legend(title = "Ag group")) +
      scale_alpha_manual(values = c(low = 0.35, high = 1)) +
      scale_fill_manual(values = m_clrs) +
      scale_y_continuous(expand = expansion(c(0.05, 0.25))) +
      labs(x = "Ag-score", y = "number of cells") +
      base_theme +
      theme(
        aspect.ratio    = 0.7,
        strip.text      = element_blank(),
        legend.position = "none",
        plot.margin     = margin(t = 0, r = 5, b = 5, l = 5)
      )
    
    if (!fst) {
      hst <- hst +
        theme(axis.title.y = element_blank())
    }
    
    # if (lst) {
    #   hst <- hst +
    #     theme(legend.position = "bottom")
    # }
    
    plot_grid(
      br, hst,
      ncol = 1,
      align = "v", axis = "rl",
      rel_heights = c(0.15, 1)
    )
  })

# Create final figure
wrap_plots(
  hsts,
  nrow = 1
)
```

<br>

Ag-low and -high cells are shown for d14 LEC subsets

```{r "d14 Ag signal", fig.width = 10, fig.height = 2.5}
# Cell types to plot
plt_typs <- typ_ag_lvls[typ_ag_lvls != "BEC"]

# Format plotting data
plt_dat <- lec_df %>%
  filter(
    subtype %in% plt_typs,
    tm == 14
  )

# Format plot labels
plt_labs <- plt_dat %>%
  group_by(subtype, mouse, tm, !!sym(rf_dat_clmn)) %>%
  summarize(
    n = label_comma()(n()),
    .groups = "drop"
  ) %>%
  mutate(
    n = str_c(!!sym(rf_dat_clmn), ": ", n, " cells"),
    !!sym(rf_dat_clmn) := fct_relevel(!!sym(rf_dat_clmn), names(pred_clrs))
  ) %>%
  group_by(subtype, mouse, tm) %>%
  arrange(!!sym(rf_dat_clmn)) %>%
  mutate(n = str_c(n, collapse = "\n"))

plt_clrs <- lec_clrs
plt_clrs["fLEC"] <- "black"
  
# Create bargraphs
hsts <- plt_typs %>%
  imap(~ {
    dat <- plt_dat %>%
      filter(subtype == .x) %>%
      mutate(mouse = as.character(mouse))
    
    fst <- .y == 1
    lst <- .y == length(tms)
    
    br <- dat %>%
      ggplot(aes(y = mouse, fill = subtype, alpha = !!sym(rf_dat_clmn))) +
      geom_bar() +
      facet_wrap(~ subtype, nrow = 1, scales = "free") +
      scale_alpha_manual(values = c(low = 0.35, high = 1)) +
      scale_fill_manual(values = plt_clrs) +
      scale_y_discrete(expand = expansion(c(0, 0))) +
      scale_x_continuous(expand = expansion(c(0, 0))) +
      base_theme +
      theme_void() +
      theme(
        legend.position = "none",
        strip.text      = element_text(size = 11),
        plot.margin     = margin(t = 5)
      )
    
    # Create histograms
    hst <- dat %>%
      ggplot(aes(Ag_score, fill = subtype, alpha = !!sym(rf_dat_clmn))) +
      geom_histogram(bins = 30) +
      geom_text(
        aes(-Inf, Inf, label = n),
        data = filter(plt_labs, subtype == .x),
        check_overlap = TRUE,
        alpha = 1,
        hjust = -0.25,
        vjust = 1.1,
        size  = txt_pt1 / .pt
      ) +
      facet_wrap(~ subtype, scales = "free", nrow = 1) +
      guides(fill = "none", alpha = guide_legend(title = "Ag group")) +
      scale_alpha_manual(values = c(low = 0.35, high = 1)) +
      scale_fill_manual(values = plt_clrs) +
      scale_y_continuous(expand = expansion(c(0.05, 0.25))) +
      labs(x = "Ag-score", y = "number of cells") +
      base_theme +
      theme(
        aspect.ratio    = 0.7,
        strip.text      = element_blank(),
        legend.position = "none",
        plot.margin     = margin(t = 0, r = 5, b = 5, l = 5)
      )
    
    if (!fst) {
      hst <- hst +
        theme(axis.title.y = element_blank())
    }
    
    plot_grid(
      br, hst,
      ncol = 1,
      align = "v", axis = "rl",
      rel_heights = c(0.15, 1)
    )
  })

# Create final figure
wrap_plots(
  hsts,
  widths = c(1.08, 1, 1, 1),
  nrow = 1
)
```

<br>

A random forest classifier was trained using data for d14 cLECs. The model was
then used to predict Ag-high cells in the other Ag datasets.

The fraction of cells belonging to each predicted Ag group is shown on the left
for cLECs from each sample.
The fraction of true Ag-low, true Ag-high, and false-positive Ag-high cells
(high-pred) is shown on the right.

* The model is fairly accurate in predicting Ag-high cells in the training and
  test data (d14 cLECs), but does not perform as well when predicting Ag-low
  cells, this can be improved with more optimization
* Since we want to identify gene signatures that are expressed
  in naive mice and continue to be expressed after
  Ag levels have fallen, we expect to observe an increasing fraction of false
  positive Ag-high cells for the later timepoints.

```{r "fraction Ag-high", fig.width = 8, fig.height = 5}
# Format data
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

bar_dat <- lec_so@meta.data %>%
  filter(
    mouse != "6wk-3wk",
    subtype %in% plt_typs,
    !training_data
  ) %>%
  mutate(
    rf_correct = fct_relevel(as.character(rf_correct), c("TRUE", "FALSE")),
    pred_grp   = fct_relevel(pred_grp, rev(names(pred_clrs))),
    tm         = as.character(tm)
  )

bar_thm <- base_theme +
  theme(aspect.ratio = 1.4)

# Plot fraction predicted groups
bar_1 <- bar_dat %>%
  ggplot(aes(tm, fill = rf_pred, alpha = rf_correct)) +
  geom_bar(position = "fill") +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
  scale_fill_manual(values = pred_clrs) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  facet_grid(~ subtype) +
  labs(y = "fraction of cells", x = "days post vaccination") +
  bar_thm

bar_2 <- bar_dat %>%
  ggplot(aes(tm, fill = pred_grp)) +
  geom_bar(position = "fill", alpha = 0.85) +
  facet_grid(~ subtype) +
  scale_fill_manual(values = pred_clrs) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  labs(y = "fraction of cells", x = "days post vaccination") +
  bar_thm +
  theme(legend.title = element_blank())

plot_grid(
  bar_1, bar_2, 
  ncol = 1,
  align = "v",
  axis  = "rl"
)
```

<br>

Model accuracy was assessed for each LEC subset. F1 scores are shown for
different combinations of testing and training data.

* Ag-high cLECs, collecting, and fLECs are easiest to predict. All models show
  high F1 scores when tested using these LEC subsets.
* Ag-high Ptx3 LECs and BECs are most difficult to accurately predict. This is
  expected since these cell populations have the lowest Ag signal and the fewest
  Ag-high cells.
* The F1 score is not always highest when the models are tested using the
  training cell type. This is not necessarily surprising since the models were
  selected using several metrics in addition to the F1 score.

```{r "F1 scores", fig.width = 8, fig.height = 3.5}
# Format model data
mods        <- rf_mods$mod
names(mods) <- rf_mods$subtype

f1_scores <- rf_mods %>%
  filter(subtype != "BEC") %>%
  mutate(mod_type = subtype) %>%
  tidyr::expand(subtype, mod_type) %>%
  mutate(mod = mods[mod_type])

# Test models on all cell types
train_cells <- unlist(rf_mods$training_bcs)
keep_cells  <- Cells(lec_so)
keep_cells  <- keep_cells[!keep_cells %in% train_cells]

info_clmns <- c("subtype", "mouse")

pred_dat <- lec_so %>%
  subset(cells = keep_cells) %>%
  FetchData(unique(c(rf_dat_clmn, info_clmns, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  mutate(mouse = as.character(mouse)) %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  column_to_rownames(".cell_id")

f1_scores <- f1_scores %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = TRUE
        ) %>%
          mutate(
            mouse = .y,
            subtype = args$subtype,
            mod_type = args$mod_type
          )
      })
  })

# Format plot data
lvls <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC", "BEC")

plt_dat <- f1_scores %>%
  filter(mouse != "6wk-3wk") %>%
  dplyr::select(F1, mouse, subtype, mod_type) %>%
  mutate(
    subtype  = fct_relevel(subtype, rev(lvls)),
    mod_type = fct_relevel(mod_type, lvls),
    mouse    = fct_relevel(mouse, mice),
    lab      = as.character(round(F1, 2))
  )

plt_dat %>%
  ggplot(aes(mod_type, subtype, fill = F1)) + 
  geom_tile(color = "white") +
  geom_text(aes(label = lab), size = 8 / .pt) +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  facet_wrap(~ mouse, nrow = 1) +
  labs(x = "training cell type", y = "testing cell type") +
  guides(fill = guide_colorbar(
    barheight = unit(100, "pt"), barwidth = unit(10, "pt"),
    ticks = FALSE
  )) +
  base_theme +
  theme(
    aspect.ratio = 1,
    axis.text.x  = element_text(angle = 45, hjust = 1)
  )
```

<br>

F1 scores are shown for the d14 timepoint using testing and training data from
the same LEC subset.

```{r "F1 scores 2", fig.width = 8, fig.height = 2.5}
f1_scores %>%
  filter(
    mod_type == subtype,
    mouse == "d14"
  ) %>%
  ggplot(aes(subtype, F1)) +
  geom_col(fill = "#0072B2") +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    aspect.ratio = 1.3,
    axis.title.x = element_blank(),
    axis.text.x  = element_text(angle = 45, hjust = 1)
  )
```

---

<br>

<br>

## Ag modules {.tabset .tabset-pills}

Expression of the top upregulated (top) and downregulated (bottom) gene modules
that are most predictive of Ag signal are shown below.

* There is a notable correlation between the expression of these genes
  and the Ag class
* False positive Ag high cells (high-pred) show
  an intermediate level of expression that falls roughly between the true Ag-low
  and true Ag-high cells.
* The false positive Ag high cells are potentially cells that are
  archiving-competent but have now lost/released most Ag at the later timepoints

```{r "modules", fig.width = 10, fig.height = 4}
# Format plot data
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

ag_modules <- plt_typs %>%
  map(str_c, c("_high", "_low")) %>%
  unlist()

plt_dat <- lec_so %>%
  FetchData(c("subtype", "mouse", "pred_grp", "training_data", ag_modules)) %>%
  filter(
    subtype %in% plt_typs,
    !training_data
  ) %>%
  pivot_longer(all_of(ag_modules)) %>%
  separate_wider_regex(
    name,
    c(module_type = ".*", "_", module_ag = ".*")
  ) %>%
  filter(subtype == module_type) %>%
  mutate(
    subtype = fct_relevel(subtype, plt_typs),
    pred_grp = fct_relevel(pred_grp, names(pred_clrs))
  )

# Create boxplots
module_lab_fn <- function(x) {
  if (any(x %in% c("high", "low"))) {
    x <- str_c("Ag-", x, " module")
  } else {
    x <- str_replace_all(x, "_", " ")
  }
  
  x
}

plt_dat %>%  
  ggplot(aes(mouse, value, fill = pred_grp)) +
  geom_boxplot(outlier.size = 0.1, key_glyph = draw_key_point) +
  scale_fill_manual(values = pred_clrs) +
  facet_wrap(
    subtype ~ module_ag,
    labeller = as_labeller(module_lab_fn),
    scales = "free_y", nrow = 2, dir = "v"
  ) +
  labs(y = "module score") +
  guides(fill = guide_legend(override.aes = list(shape = 22, size = 4))) +
  base_theme +
  theme(
    aspect.ratio = 0.75,
    plot.title   = element_text(hjust = 0.5),
    legend.title = element_blank(),
    axis.title.x = element_blank()
  )
```

<br>

Expression of the Ag-high and -low gene modules is shown below for 14, 21, and
42 day timepoints.

```{r "modules 2", fig.width = 10, fig.height = 4}
# Format plot data
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

ag_modules <- plt_typs %>%
  map(str_c, c("_high", "_low")) %>%
  unlist()

plt_dat <- lec_so %>%
  FetchData(c("subtype", "mouse", "tm", "pred_grp", "training_data", ag_modules)) %>%
  filter(
    mouse != "6wk-3wk",
    subtype %in% plt_typs,
    !training_data
  ) %>%
  pivot_longer(all_of(ag_modules)) %>%
  separate_wider_regex(
    name,
    c(module_type = ".*", "_", module_ag = ".*")
  ) %>%
  filter(subtype == module_type) %>%
  mutate(
    subtype  = fct_relevel(subtype, plt_typs),
    pred_grp = fct_relevel(pred_grp, names(pred_clrs)),
    tm       = as.character(tm)
  )

# Calculate p-values
alt <- c(high = "greater", low = "less")

p_dat <- plt_dat %>%
  filter(pred_grp != "Ag-low") %>%
  group_by(module_type, module_ag, subtype, mouse, tm) %>%
  summarize(
    p = t.test(
      value[pred_grp == "Ag-high"],
      value[pred_grp == "Ag-competent"],
      alternative = unique(alt[module_ag])
    )$p.value,
    .groups = "drop"
  ) %>%
  mutate(p_adj = p.adjust(p, method = "bonferroni"))

# Create boxplots
plt_dat %>%
  split(.$module_ag) %>%
  imap(~ {
    .x %>%  
      ggplot(aes(tm, value, fill = pred_grp)) +
      geom_boxplot(outlier.size = 0.1, key_glyph = draw_key_point) +
      scale_fill_manual(values = pred_clrs) +
      facet_wrap(
        ~ subtype,
        scales = "free_y", nrow = 1, dir = "v"
      ) +
      labs(y = "module expression", x = "days post vaccination") +
      guides(fill = guide_legend(override.aes = list(shape = 22, size = 4))) +
      ggtitle(str_c("Ag-", .y, " module")) +
      base_theme +
      theme(
        aspect.ratio = 0.75,
        plot.title   = element_text(hjust = 0.5),
        legend.title = element_blank()
      )
  }) %>%
  plot_grid(
    plotlist = .,
    ncol  = 1,
    align = "v",
    axis  = "rl"
  )
```

<br>

The cLEC Ag-high gene module is shown below.

```{r "cLEC module scores UMAP", fig.width = 8, fig.height = 6.5}
# Format plotting data
plt_typ     <- "cLEC"
module_clmn <- str_c(plt_typ, "_high")

u_so <- lec_so %>%
  subset(mouse != "6wk-3wk") %>%
  mutate_meta(
    mutate,
    pred_grp = ifelse(subtype == plt_typ, pred_grp, "other"),
    pred_grp = recode(pred_grp, `Ag-competent` = "Ag-low"),
    pred_grp = fct_relevel(pred_grp, c("other", names(pred_clrs))),
    tm       = as.character(tm)
  )

# Plot module scores
ag_mod_u <- tms[tms %in% u_so$tm] %>%
  imap(~ {
    u_so %>%
      subset(tm == .x) %>%
      create_sig_umap(
        dat_col = module_clmn,
        grp_col = "tm",
        clrs    = c("lightblue", "white", pred_clrs[["Ag-high"]])
      ) +
      theme(strip.text = element_text(size = 14))
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = str_c(plt_typ, " Ag-high module"),
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

# Plot Ag-high cells
clrs <- rev(pred_clrs)
clrs["Ag-low"] <- "#56B4E9"
clrs["other"]  <- "white"

ag_low_u <- tms[tms %in% u_so$tm] %>%
  imap(~ {
    u_so %>%
      subset(tm == .x) %>%
      create_grp_umap(
        dat_col = "pred_grp",
        grp_col = "tm",
        clrs    = clrs,
        lvls    = c("Ag-high", "Ag-low", "other")
      ) +
      theme(strip.text = element_text(size = 14))
  }) %>%
  wrap_plots(nrow = 1)

# Create final figure
fig <- plot_grid(
  ag_mod_u, ag_low_u,
  ncol = 1
)

fig
```

<br>

UMAP projections show Ag-high module expression (top),
true Ag-low vs true Ag-high (middle),
and false-positive Ag-high (high-pred) vs true Ag-high (bottom).

* False positive Ag-high cells (high-pred) show strong overlap with true
  Ag-high cells
  
```{r "module scores UMAPs", fig.width = 10, fig.height = 12, results = "asis"}
# Create UMAPs
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

plt_typs %>%
  walk(~ {
    cat("\n\n###", .x, "\n\n")
    
    module_clmn <- str_c(.x, "_high")
    
    # Set coordinates for drawing circle
    circ_dat <- lec_so@meta.data %>%
      filter(subtype == .x) %>%
      group_by(mouse) %>%
      summarize(across(c(hUMAP_1, hUMAP_2), mean))
    
    # Plot module scores
    ag_mod_u <- mice[mice %in% lec_so$mouse] %>%
      imap(~ {
        lec_so %>%
          subset(mouse == .x) %>%
          create_sig_umap(
            dat_col = module_clmn,
            clrs = c("lightblue", "white", pred_clrs[["Ag-high"]])
          ) +
          geom_circle(
            aes(x0 = hUMAP_1, y0 = hUMAP_2, fill = NULL, color = NULL, r = 2),
            data = filter(circ_dat, mouse == .x),
            linetype = 2
          )
      }) %>%
      wrap_plots(nrow = 1) +
      plot_annotation(
        title = str_c(.x, " Ag-high module"),
        theme = theme(
          plot.title = element_text(hjust = 0.5, size = ttl_pt2)
        )
      )
    
    # Plot Ag-low vs Ag-high
    clrs <- rev(pred_clrs)
    clrs[c("low", "high-pred")] <- "#56B4E9"
    clrs["other"]               <- "white"
    
    u_so <- lec_so %>%
      mutate_meta(
        mutate,
        pred_grp  = ifelse(subtype == .x, pred_grp, "other"),
        pred_grp1 = ifelse(pred_grp %in% c("high", "low"), pred_grp, "other"),
        pred_grp2 = ifelse(pred_grp %in% c("high", "high-pred"), pred_grp, "other")
      )
    
    ag_low_u <- mice[mice %in% lec_so$mouse] %>%
      imap(~ {
        u_so %>%
          subset(mouse == .x) %>%
          create_grp_umap(
            dat_col = "pred_grp1",
            clrs    = clrs
          )
      }) %>%
      wrap_plots(nrow = 1) +
      plot_annotation(
        title = "Ag-low vs Ag-high",
        theme = theme(
          plot.title = element_text(hjust = 0.5, size = ttl_pt2)
        )
      )
    
    # Plot Ag-high vs predicted Ag-high
    ag_high_u <- mice[mice %in% lec_so$mouse] %>%
      imap(~ {
        u_so %>%
          subset(mouse == .x) %>%
          create_grp_umap(
            dat_col = "pred_grp2",
            clrs    = clrs
          )
      }) %>%
      wrap_plots(nrow = 1) +
      plot_annotation(
        title = "Ag-high predicted vs Ag-high",
        theme = theme(
          plot.title = element_text(hjust = 0.5, size = ttl_pt2)
        )
      )
    
    # Create final figure
    fig <- plot_grid(
      ag_mod_u, ag_low_u, ag_high_u,
      ncol = 1
    )
    
    print(fig)
    cat("\n\n<br>\n\n")
  })
```

##

Expression of Ag-high and Ag-low gene modules is compared for the 6wk, 3wk,
and 6wk-3wk samples.
Module expression is shown for Ag double-positive cells from the 6wk-3wk mouse
(double-high), cells positive for a single Ag-tag (single-high), and
Ag-high cells from the 6wk or 3wk mouse (6wk-high, 3wk-high). All Ag-low cells
are plotted as a single group.

* When compared to the 6wk and 3wk mice,
  double positive Ag-high cLECs show slightly higher expression of the
  Ag-high module.
* This effect requires more investigation, but suggests that
  double-positive cells are better equipped to archive antigen.

```{r "AG-EX DOUBLE POSITIVE", fig.width = 9, fig.height = 5.5}
# Format plot data
lvls <- c("low", "6wk-high", "3wk-high", "single-high", "double-high")

plt_dat <- lec_so %>%
  FetchData(c("subtype", "mouse", "Ag_class_6wk_3wk", ag_modules)) %>%
  filter(
    mouse %in% c("6wk", "3wk", "6wk-3wk"),
    subtype %in% plt_typs
  ) %>%
  pivot_longer(all_of(ag_modules)) %>%
  separate_wider_regex(
    name,
    c(module_type = ".*", "_", module_ag = ".*")
  ) %>%
  filter(subtype == module_type) %>%
  
  # Group all low cells together under single mouse, otherwise three boxplots
  # are shown
  mutate(
    subtype          = fct_relevel(subtype, plt_typs),
    Ag_class_6wk_3wk = fct_relevel(Ag_class_6wk_3wk, lvls),
    mouse            = ifelse(Ag_class_6wk_3wk == "low", "6wk-3wk", mouse)
  ) %>%
  arrange(Ag_class_6wk_3wk) %>%
  mutate(
    mouse_class = fct_inorder(str_c(mouse, "-", subtype, "-", Ag_class_6wk_3wk))
  )

# # Calculate p-values
# p_dat <- plt_dat %>%
#   filter(
#     Ag_class_6wk_3wk %in% c("double-high", "6wk-high"),
#     subtype == "cLEC",
#     module_ag == "high"
#   )
# 
# wilcox.test(
#   p_dat$value[p_dat$Ag_class_6wk_3wk == "double-high"],
#   p_dat$value[p_dat$Ag_class_6wk_3wk == "6wk-high"],
#   alternative = "greater"
# )

# Format n labels
n_dat <- plt_dat %>%
  group_by(Ag_class_6wk_3wk, mouse_class, subtype, module_ag) %>%
  summarize(n = n(), .groups = "drop") %>%
  mutate(
    n = str_c(Ag_class_6wk_3wk, "\nn = ", scales::label_comma()(n))
  ) %>%
  filter(module_ag == "high")

n_lab <- set_names(n_dat$n, n_dat$mouse_class)

# Create boxplots
plt_dat %>%
  ggplot(aes(mouse_class, value, fill = Ag_class_6wk_3wk)) +
  geom_boxplot(notch = TRUE, outlier.size = 0.1) +
  facet_wrap(
    module_type ~ module_ag,
    dir = "v", nrow = 2, scales = "free",
    labeller = as_labeller(module_lab_fn)
  ) +
  scale_fill_manual(values = clrs) +
  scale_x_discrete(labels = n_lab) +
  labs(y = "module score") +
  base_theme +
  theme(
    legend.position = "none",
    axis.text.x  = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank()
  )
```

```{r "AG-EX MODULE EXPRESSION", eval = FALSE}
# Do 6wk-3wk mice show higher expression of Ag modules than 3wk
# 6wk-3wk Ag_class is based on the 3wk Ag-tag
# Module expression is higher in 6wk-3wk vs 3wk, but it is also higher in the
# 6wk mouse
typ <- "cLEC"
module <- str_c(typ, "_high")

lec_so@meta.data %>%
  filter(subtype == typ) %>%
  ggplot(aes(mouse, !!sym(module), fill = mouse)) +
  geom_boxplot() +
  base_theme

lec_so@meta.data %>%
  filter(subtype == typ) %>%
  filter(mouse %in% c("6wk-3wk", "3wk")) %>%
  ggplot(aes(orig.ident, fill = Ag_class_3)) +
  geom_bar(position = "fill") +
  facet_wrap(~ mouse, nrow = 1, scales = "free_x")
```

```{r "GEOMX", eval = FALSE}
library(NanoStringNCTools)
library(GeomxTools)
library(GeoMxWorkflows)
library(umap)

geomx_dir  <- file.path("~/Projects", proj)
geomx_res  <- "results/2023-06-23"
counts_dir <- "results/2023-06-23/counts"
worksheet  <- "geomx_worksheets/Tamburini_061423_20230619T1930_annotations.xlsx"
obj_dir    <- "sobjs"                            # Directory to load/save Seurat objects
table_dir  <- "tables"
pkcs       <- c("Mm_R_NGS_WTA_v1.0.pkc", "Hesselberth_02-SO-90138_v1.0.pkc")

# Load data
proj      <- "tamburini-antigen-tracking"
geomx_dat <- file.path("~/Dropbox/Ryan/Projects", proj)

dcc <- dir(file.path(geomx_dat, counts_dir), ".dcc$", full.names = TRUE)
pkc <- file.path(geomx_dir, "ref", pkcs)
ann <- file.path(geomx_dir, geomx_res, worksheet)

dat <- readNanoStringGeoMxSet(
  dccFiles               = dcc,
  pkcFiles               = pkc,
  phenoDataFile          = ann,
  phenoDataSheet         = "LabWorksheet",
  phenoDataDccColName    = "Sample_ID",
  protocolDataColNames   = c("Aoi", "Roi"),
  experimentDataColNames = "Panel"
)

pkcs    <- annotation(dat)
modules <- gsub(".pkc", "", pkcs)

# Add 1 to counts
dat <- dat %>%
  shiftCountsOne(useDALogic = TRUE)

# Default QC cutoffs are shown in parenthesis
# study-specific values were selected after visualizing the QC results in more
# detail below
QC_params <- list(
  minSegmentReads   = 1000,  # Minimum number of reads (1000)
  percentTrimmed    = 80,    # Minimum % of reads trimmed (80%)
  percentStitched   = 80,    # Minimum % of reads stitched (80%)
  percentAligned    = 75,    # Minimum % of reads aligned (80%)
  percentSaturation = 50,    # Minimum sequencing saturation (50%)
  minNegativeCount  = 1,     # Minimum negative control counts (10)
  maxNTCCount       = 1000,  # Maximum counts observed in NTC well (1000)
  minNuclei         = 100,   # Minimum # of nuclei estimated (100)
  minArea           = 5000   # Minimum segment area in um2 (5000)
)

dat <- dat %>%
  setSegmentQCFlags(qcCutoffs = QC_params)

# Collate QC Results
QCResults    <- protocolData(dat)[["QCFlags"]]
flag_columns <- colnames(QCResults)

QC_Summary <- data.frame(
  Pass    = colSums(!QCResults[, flag_columns]),
  Warning = colSums(QCResults[, flag_columns])
)

QCResults$QCStatus <- apply(QCResults, 1L, function(x) {
    ifelse(sum(x) == 0L, "PASS", "WARNING")
})

QC_Summary["TOTAL FLAGS", ] <- c(
  sum(QCResults[, "QCStatus"] == "PASS"),
  sum(QCResults[, "QCStatus"] == "WARNING")
)

# Calculate geometric mean for negative control probes for each pkc module 
neg_geo_mns <- esBy(
  negativeControlSubset(dat), 
  GROUP = "Module", 
  FUN = function(x) assayDataApply(x, MARGIN = 2, FUN = ngeoMean, elt = "exprs")
)

protocolData(dat)[["NegGeoMean"]] <- neg_geo_mns

# explicitly copy the Negative geoMeans from sData to pData
negCols <- paste0("NegGeoMean_", modules)

pData(dat)[, negCols] <- sData(dat)[["NegGeoMean"]][, modules]

# Filter data
dat <- dat[, QCResults$QCStatus == "PASS"]

## Probe QC
# A probe is removed globally from the dataset if either of the following is
# true, Nanostring does not recommend adjusting these parameters.
# A probe is removed locally (from a given segment) if the probe is an outlier
# according to the Grubb’s test in that segment.
# 
# * The geometric mean of that probe’s counts from all segments divided by the
#   geometric mean of all probe counts representing the target from all segments
#   is less than 0.1
# * The probe is an outlier according to the Grubb’s test in at least 20% of the
#   segments
# 
# Generally keep the qcCutoffs parameters unchanged. Set removeLocalOutliers to 
# FALSE if you do not want to remove local outliers
dat <- dat %>%
  setBioProbeQCFlags(
    qcCutoffs = list(minProbeRatio = 0.1, percentFailGrubbs = 20),
    removeLocalOutliers = TRUE
  )

ProbeQCResults <- fData(dat)[["QCFlags"]]

# Probe QC summary
qc_df <- data.frame(
  Passed = sum(rowSums(ProbeQCResults[, -1]) == 0),
  Global = sum(ProbeQCResults$GlobalGrubbsOutlier),
  Local  = sum(rowSums(ProbeQCResults[, -2:-1]) > 0 & !ProbeQCResults$GlobalGrubbsOutlier)
)

# Collapse probe counts for each gene
# This is important since multiple probes are included for some genes
# Remove neg_geomean columns from pData since aggregateCounts()
# will add these columns
pData(dat) <- pData(dat)[, !colnames(pData(dat)) %in% negCols]
gene_dat   <- aggregateCounts(dat)

# In addition to Segment and Probe QC, also need to determine the limit of
# quantification (LOQ) per segment. The LOQ is calculated based on the
# distribution of negative control probes and is intended to approximate the
# quantifiable limit of gene expression per segment. It should be noted that this
# process is more stable for larger segments. Likewise, the LOQ may not be as
# accurately reflective of true signal detection rates in segments with low
# negative probe counts (e.g. <2).
# 
# Use 2 geometric standard deviations (n = 2) above the geometric mean as the LOQ, which is reasonable for most studies.
# Nanostring also recommends that a minimum LOQ of 2 be used if the LOQ calculated in a segment is below this threshold.

# Define LOQ SD threshold and minimum value
cutoff <- 2
minLOQ <- 2

# Calculate LOQ per module tested
LOQ <- data.frame(row.names = colnames(gene_dat))

for (module in modules) {
    vars <- paste0(c("NegGeoMean_", "NegGeoSD_"), module)
    
    if(all(vars[1:2] %in% colnames(pData(gene_dat)))) {
        LOQ[, module] <- pmax(minLOQ, pData(gene_dat)[, vars[1]] * pData(gene_dat)[, vars[2]] ^ cutoff)
    }
}

# Add LOQ to gene-level data
pData(gene_dat)$LOQ <- LOQ

# Calculate detected genes in each segment
LOQ_Mat <- c()

for(module in modules) {
  ind     <- fData(gene_dat)$Module == module
  Mat_i   <- t(esApply(gene_dat[ind, ], MARGIN = 1, FUN = function(x) x > LOQ[, module]))
  LOQ_Mat <- rbind(LOQ_Mat, Mat_i)
}

# Ensure ordering since this is stored outside of the geomxSet
LOQ_Mat <- LOQ_Mat[fData(gene_dat)$TargetName, ]

# Save detection rate information to pheno data
pData(gene_dat)$GenesDetected     <- colSums(LOQ_Mat, na.rm = TRUE)
pData(gene_dat)$GeneDetectionRate <- pData(gene_dat)$GenesDetected / nrow(gene_dat)

# Determine detection thresholds
# Bin segments based on detection rate
pData(gene_dat)$DetectionThreshold <- cut(
  pData(gene_dat)$GeneDetectionRate,
  breaks = c(0, 0.01, 0.05, 0.1, 0.15, 1),
  labels = c("<1%", "1-5%", "5-10%", "10-15%", ">15%")
)

# Filter segments
rate_cutoff <- 0.01

gene_dat <- gene_dat[, pData(gene_dat)$GeneDetectionRate >= rate_cutoff]

# Calculate detection rate
LOQ_Mat <- LOQ_Mat[, colnames(gene_dat)]

fData(gene_dat)$DetectedSegments <- rowSums(LOQ_Mat, na.rm = TRUE)
fData(gene_dat)$DetectionRate    <- fData(gene_dat)$DetectedSegments / nrow(pData(gene_dat))

# Plot detection rate:
plot_detect <- data.frame(Freq = c(1, 5, 10, 20, 30, 50))

plot_detect$Number <- unlist(lapply(
  c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5),
  function(x) sum(fData(gene_dat)$DetectionRate >= x)
))

plot_detect$Rate <- plot_detect$Number / nrow(fData(gene_dat))

rownames(plot_detect) <- plot_detect$Freq

# USING CUTOFF OF 5%
# Subset to target genes detected in at least 10% of the samples.
# Also manually include the negative control probe, for downstream use
rate_cutoff <- 0.05

negativeProbefData <- subset(fData(gene_dat), CodeClass == "Negative")
neg_probes         <- unique(negativeProbefData$TargetName)

gene_dat <- gene_dat[fData(gene_dat)$DetectionRate >= rate_cutoff | fData(gene_dat)$TargetName %in% neg_probes, ]

# Background normalization for WTA/CTA without custom spike-in
gene_dat <- gene_dat %>%
  normalize(norm_method = "neg", fromElt = "exprs", toElt = "neg_norm")

# Q3 norm (75th percentile) for WTA/CTA  with or without custom spike-ins
gene_dat <- gene_dat %>%
  normalize(norm_method = "quant", desiredQuantile = 0.75, toElt = "q_norm")

# update defaults for umap to contain a stable random_state (seed)
custom_umap <- umap::umap.defaults

custom_umap$random_state <- 42

# run UMAP
# exclude data for Ag tags and control tags
exclude <- rownames(gene_dat)
exclude <- grepl("^(Custom|Barcode)|_CTL$", exclude)
u_dat   <- gene_dat[!exclude, ]

umap_out <- umap(
  t(log2(assayDataElement(u_dat, elt = "q_norm"))),  
  config = custom_umap
)

pData(gene_dat)[, c("UMAP1", "UMAP2")] <- umap_out$layout[, c(1,2)]

# DATA FOR PLOTTING GENE EXPRESSION ----
# THIS SYNTAX DOES NOT WORK, WHY?
# pData(plt_dat)[, "Barcode01"] <- gn_dat$Barcode01
rf_gns <- c(
  "Barcode01", "Barcode02",
  # rf_feats$cLEC$high
  rf_feats$cLEC$low
)

rf_gns <- rf_gns[rf_gns %in% rownames(gene_dat)]

gn_dat <- gene_dat[rf_gns, ] %>%
  assayDataElement(elt = "q_norm") %>%
  # assayDataElement(elt = "neg_norm") %>%
  # assayDataElement(elt = "exprs") %>%
  t() %>%
  as_tibble(rownames = "dcc")

plt_dat <- pData(gene_dat) %>%
  as_tibble(rownames = "dcc") %>%
  left_join(gn_dat, by = "dcc")

# Format segment names
plt_dat <- plt_dat %>%
  mutate(
    LN = str_remove(LN, "(?<=LN) "),
    sample = str_remove(LN, " LN[0-9]+$"),
    sample = str_remove(sample, "^ova-GeoMX\\+VV "),
    sample = str_replace_all(sample, "week", "wk"),
    sample = str_replace_all(sample, " and ", "-"),
    rep    = str_extract(LN, "LN[ 0-9]+"),
    rep    = str_remove_all(rep, " "),
    slide  = as.numeric(str_extract(`Slide Name`, "[0-9]+$"))
  )

# Set sample colors
sam_cols <- c("naive", "3wk", "6wk", "6wk-3wk")

sam_cols <- set_names(
  ito_cols[seq_along(sam_cols)],
  sam_cols
)

ag_cols <- c(`ova-3wk` = "#56B4E9", `ova-6wk` = "#6A51A3")

# Assign barcode signals
bc_key <- plt_dat %>%
  filter(sample %in% c("3wk", "6wk")) %>%
  group_by(slide, sample) %>%
  summarize(across(starts_with("Barcode0"), mean), .groups = "drop") %>%
  pivot_longer(starts_with("Barcode0")) %>%
  group_by(slide, sample) %>%
  filter(value == max(value)) %>%
  split(.$slide) %>%
  map(~ set_names(.x$name, .x$sample))

plt_dat <- plt_dat %>%
  group_by(slide) %>%
  rowwise() %>%
  mutate(
    `ova-3wk` = bc_key[[as.character(slide)]][["3wk"]],
    `ova-6wk` = bc_key[[as.character(slide)]][["6wk"]]
  ) %>%
  ungroup() %>%
  mutate(
    across(matches("ova-[0-9]+wk"), ~ {
      case_when(
        .x == "Barcode01" ~ Barcode01,
        .x == "Barcode02" ~ Barcode02
      )
    }),
    # Segment = fct_relevel(Segment, names(seg_cols)),
    sample  = fct_relevel(sample, names(sam_cols))
  )

plt_dat <- plt_dat %>%
  rowwise() %>%
  mutate(top_ova = max(c(`ova-3wk`, `ova-6wk`))) %>%
  ungroup()

# Plot genes
plt_dat %>%
  pivot_longer(all_of(rf_gns)) %>%
  mutate(name = fct_relevel(name, rf_gns)) %>%
  ggplot(aes(region_2, value, fill = region_2, color = region_2)) +
  geom_boxplot(alpha = 0.5, key_glyph = draw_key_point) +
  facet_wrap(~ name, scales = "free_y") +
  # scale_color_manual(values = seg_cols) +
  # scale_fill_manual(values = seg_cols) +
  # labs(x = "Segment type", y = "Normalized expression") +
  base_theme +
  theme(
    aspect.ratio    = 1.2,
    legend.position = "none",
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )
```

---

<br>

<br>

## Ag features {.tabset .tabset-pills}

```{r "top features heatmaps"}
heats <- rf_feats %>%
  imap(~ {
    typ <- .y
    
    .x %>%
      imap(~ {
        lec_so %>%
          subset(subtype == typ) %>%
          create_heats(
            gns = .x,
            sort_gns = switch(.y, high = "up", low = "down")
          ) +
          theme(
            panel.border = element_rect(color = "grey30")
          )
      })
  })
```

```{r "top features examples", fig.height = 8, fig.width = 8}
gn_plots <- rf_feats %>%
  map(~ {
    plt_args <- list(
      gns   = .x,
      p_alt = c("greater", "less"),
      n_gns = c(10, 7)
    )
    
    plt_args %>%
      pmap(~ {
        args <- list(...)
        lec_so %>%
          subset(subtype == rf_cell_type) %>%
          create_gn_plots(
            gns      = args$gns,
            plt_clrs = pred_clrs,
            p_alt    = args$p_alt,
            n_gns    = args$n_gns
          )
      })
  })
```

Mean expression in cLECs is shown on the left for genes from the Ag-high module for
true Ag-low, true Ag-high, and false positive Ag-high (predicted, high-pred)
cells.
Expression is shown on the right for select top features.

Points show median expression, grey bars show interquartile range, dotted line
shows the trend, and arrows indicate the gene is significantly up or down
regulated when compared to Ag-low cells.

Ag-high gene module is shown below for cLECs.

```{r "cLEC heat", fig.width = 10, fig.height = 5}
lec_so %>%
  subset(subtype == "cLEC" & mouse != "6wk-3wk") %>%
  mutate_meta(mutate, mouse = tm) %>%
  create_heats(
    gns = rf_feats$cLEC$high,
    sort_gns = "down"
  ) +
  coord_flip() +
  facet_wrap(~ mouse, ncol = 1, strip.position = "right") +
  guides(fill = guide_colorbar(
    barheight = unit(7, "pt"), barwidth = unit(120, "pt"),
    title = "expression", title.position = "top"
  )) +
  theme(
    aspect.ratio    = length(pred_clrs) / length(rf_feats$cLEC$high),
    legend.position = "bottom",
    legend.title    = element_text()
  )
```

<br>

```{r "Ag-high examples", fig.height = 10, fig.width = 10, results = "asis"}
heats[names(heats) != "BEC"] %>%
  iwalk(~ {
    cat("\n\n###", str_c(.y, "-high"), "\n\n")
    
    plt <- plot_grid(.x$high, gn_plots[[.y]]$high)
    print(plt)
    cat("\n\n<br>\n\n")
    # cat("\n\n---\n\n<br>\n\n<br>\n\n")
  })
```

```{r "Ag-low examples", fig.height = 10, fig.width = 10, results = "asis"}
heats[names(heats) != "BEC"] %>%
  iwalk(~ {
    cat("\n\n###", str_c(.y, "-low"), "\n\n")
    
    plt <- plot_grid(.x$low, gn_plots[[.y]]$low)
    print(plt)
    cat("\n\n<br>\n\n")
    # cat("\n\n---\n\n<br>\n\n<br>\n\n")
  })
```

```{r "GO", eval = FALSE}
# Prepare GO data to measure similarity
go_sim_data <- godata(
  OrgDb   = org.Mm.eg.db,
  keytype = "SYMBOL",
  ont     = "BP"
)

# Set DEGs to use
go_feats <- rf_feats[names(rf_feats) != "BEC"]

go_feats <- list(
  high = map(go_feats, ~ .x$high),
  low  = map(go_feats, ~ .x$low)
)

# Get GO terms
go <- go_feats["high"] %>%
  imap(~ {
    file <- str_c("ag-", .y, "_go")
    file <- here(params$mod_dir, file)  # file extension gets added later
    
    .x %>%
      get_go(
        so_in     = lec_so,
        file      = file,
        db        = "BP",
        type_clmn = "subtype"
      )
  })
```

```{r "GO examples", eval = FALSE}

go_dat <- go$high@compareClusterResult %>%
  as_tibble() %>%
  dplyr::select(-bgID) %>%
  filter(
    Cluster == "cLEC",
    p.adjust < 0.05
  )

go_dat %>%
  filter(Description %in% c("endocytosis", "proteolysis")) %>%
  pull(geneID) %>%
  str_split("/") %>%
  purrr::reduce(c) %>%
  unique()

gns <- c(
  "Ctsd",   # cathepsin D, protease
  "Esyt2",  # endocytic adapter
  "Dab2",   # Clathrin endocytic adapter
  "Cd63",   # facilitates vesicular trafficking through endosomal pathways
  "Cd36",   # scavenger receptor
  "Canx",   # calnexin, molecular chaperone in ER
  "Lgmn"    # cysteine protease 
)

dat <- lec_so %>%
  FetchData(c("tm", "mouse", "subtype", "training_data", "Ag_score", "Ag_class_3", "pred_grp", gns)) %>%
  as_tibble(rownames = ".cell_id") %>%
  filter(
    subtype %in% rf_typs,
    mouse != "6wk-3wk",
    !training_data
  ) %>%
  mutate(
    tm = as.character(tm),
    pred_grp = fct_relevel(pred_grp, names(pred_clrs))
  ) %>%
  
  pivot_longer(all_of(gns))
  
dat %>%
  ggplot(aes(tm, value, fill = pred_grp)) +
  geom_boxplot() +
  facet_grid(subtype ~ name) +
  base_theme

dat %>%
  group_by(tm, mouse, subtype, name, pred_grp) %>%
  summarize(value = mean(value), .groups = "drop") %>%
  group_by(tm, subtype, name) %>%
  mutate(value = as.numeric(scale(value))) %>%
  ungroup() %>%
  # filter(subtype == "cLEC") %>%
  
  ggplot(aes(pred_grp, name, fill = value)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("lightblue", "white", "red")) +
  facet_grid(subtype ~ tm) +
  base_theme +
  theme(
    aspect.ratio = length(gns) / length(pred_clrs),
    axis.text.x  = element_text(angle = 45, hjust = 1)
  )
```

```{r "GO clusters", eval = FALSE}
# Cell types to exclude from GO analysis
# exclude_cell_types <- "BEC"
exclude_cell_types <- c("BEC", "Collecting", "Ptx3_LEC", "fLEC")
n_ovlp             <- 3
n_clusters         <- 15

# Cluster GO terms
clusters <- go %>%
  map(~ {
    get_go_clusters(
      go_in     = .x,
      k         = n_clusters,
      pval      = 0.05,
      n_overlap = n_ovlp,     # Min genes needed to overlap term for it to
                              # be marked significant
      n_shared  = 1,          # Min number of cell types needed to share term for the
                              # term to be included in clustering
      max_term_size = 500,
      exclude_cell_types = exclude_cell_types
    )
  }) %>%
  purrr::discard(is.null)
```

```{r "GO heatmaps", eval = FALSE}
# # Cluster titles
# ttls <- as_labeller(c(
#   `1` = "Innate Immune Response",
#   `2` = "Inflammatory Response"
# ))

# # Cluster colors
# go_clrs <- setNames(
#   list(
#     c(`1` = "#E69F00"),
#     c(`1` = "#D7301F", `2` = "#6A51A3")
#   ),
#   plt_comps
# )

# Create heatmaps
# only showing cell types that have at least one overlapping term plotted and
# are not in exclude_cell_types
# pval and n_overlap cutoffs should match those used for clustering
plt_args <- list(
  go_in    = go,
  clst_dat = clusters,
  ovlp     = n_ovlp
  # clsts    = list(c(1, 2, 3, 5, 7), 1:5)
  # clrs     = go_clrs,
)

go_heat <- plt_args %>%
  pmap(~ {
    args  <- list(...)
    
    create_go_heatmap(
      df_in          = args$clst_dat$clusters,
      go_in          = args$go_in,
      pval           = 0.05,
      n_overlap      = args$ovlp,   # Min genes needed to overlap term for it to
                                    # be marked significant
      n_genes        = 3,           # Min DEGs represented on plot to include cell type
      clusters       = args$clsts,  # Clusters to plot
      n_clusters     = n_clusters,
      n_terms        = 10,
      n_col          = 4,
      clrs           = ito_cols,
      exclude_cell_types = exclude_cell_types
      # cluster_labels = ttls,
    )
  })
```

```{r "GO tree", eval = FALSE}
# Retrieve clusters
clsts <- clusters$high

clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))

clst_clrs <- set_names(
  unname(ito_cols)[1:n_distinct(clst_ids)],
  clst_ids
)

cl <- split(
  names(clsts$clusters_object),
  clsts$clusters_object
)

# Create tree
tr <- ggtree(clsts$object, linewidth = 1)

clades <- cl %>%
  map_int(~ MRCA(tr, .x))

tr <- groupClade(tr, clades, group_name = "cluster") +
  aes(color = cluster) +
  scale_color_manual(values = clst_clrs) +
  geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
  layout_dendrogram() +
  theme(
    legend.position = "none",
    plot.margin = margin(6, 6, 250, 6)
  )
```

---

<br>

<br>

## Ag archiving in CHIKV {.tabset .tabset-pills}

```{r "CHIKV data"}
# Format plotting data
treat_clrs <- c(mock = "#009E73", CHIKV = "#6A51A3")
n_reps     <- n_distinct(chikv_so$rep)

plt_dat <- chikv_so@meta.data %>%
  as_tibble(rownames = ".cell_id") %>%
  mutate(
    treatment = fct_relevel(treatment, names(treat_clrs)),
    pred      = fct_relevel(pred, names(pred_clrs))
  ) %>%
  filter(cell_type_2 == "LEC")

# Cell types to plot
chikv_typs <- plt_dat %>%
  group_by(treatment, lec_type, tm, rep) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(lec_type, tm) %>%
  filter(
    all(n > 20),
    !lec_type %in% c("unassigned-LEC")
  ) %>%
  ungroup() %>%
  pull(lec_type) %>%
  unique()

plt_dat <- plt_dat %>%
  filter(lec_type %in% chikv_typs)
```

The fraction of cells predicted to be Ag-high (i.e. archiving competent) is
shown below for each biological replicate. p-values < 0.05 are shown.

* There is a reduction in archiving-competent cells in CHIKV-infected LN samples

```{r "CHIKV fraction Ag", fig.width = 10, fig.height = 4}
# Format plotting data
bar_dat <- plt_dat %>%
  filter(!is.na(pred)) %>%
  group_by(orig.ident, lec_type, rep, treatment, tm) %>%
  summarize(
    frac_high = sum(pred == "high") / n(),
    .groups = "drop"
  )

# Format p-values
p_dat <- bar_dat %>%
  group_by(lec_type, tm) %>%
  summarize(
    p = wilcox.test(
      frac_high[treatment == names(treat_clrs)[1]],
      frac_high[treatment == names(treat_clrs)[2]]
    )$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(p, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(
    plab = .format_pvalue(padj),
    plab = str_c("italic(p) == ", plab) 
  ) %>%
  filter(padj < 0.05)

# Create bargraphs
bar_dat %>%
  ggplot(aes(treatment, frac_high, fill = treatment, alpha = rep)) +
  geom_col(position = position_dodge2(preserve = "single")) +
  geom_text(
    aes(y = Inf, x = 1.5, label = plab, fill = NULL),
    data = p_dat,
    alpha = 1,
    parse = TRUE,
    size  = txt_pt1 / .pt * 0.8,
    vjust = 1.1
  ) +
  facet_grid(tm ~ lec_type) +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  scale_alpha_manual(values = rep(1, n_reps)) +
  scale_fill_manual(values = treat_clrs) +
  labs(y = "fraction predicted Ag-high") +
  base_theme +
  theme(
    aspect.ratio    = 1.25, 
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )
```

<br>

The fraction of cells predicted to be Ag-high is shown below for 24 hpi cLECs.

```{r "cLEC fraction Ag", fig.width = 10, fig.height = 2.8}
# Format plotting data
bar_dat <- plt_dat %>%
  
  filter(lec_type == "cLEC", tm == "24hpi") %>%
  
  filter(!is.na(pred)) %>%
  group_by(orig.ident, lec_type, rep, treatment, tm) %>%
  summarize(
    frac_high = sum(pred == "high") / n(),
    .groups = "drop"
  )

# Format p-values
p_dat <- bar_dat %>%
  group_by(lec_type, tm) %>%
  summarize(
    p = wilcox.test(
      frac_high[treatment == names(treat_clrs)[1]],
      frac_high[treatment == names(treat_clrs)[2]]
    )$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(p, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(
    plab = .format_pvalue(padj),
    plab = str_c("italic(p) == ", plab) 
  ) %>%
  filter(padj < 0.05)

# Create bargraphs
bar_dat %>%
  ggplot(aes(treatment, frac_high, fill = treatment, alpha = rep)) +
  geom_col(position = position_dodge2(preserve = "single")) +
  geom_text(
    aes(y = Inf, x = 1.5, label = plab, fill = NULL),
    data = p_dat,
    alpha = 1,
    parse = TRUE,
    size  = txt_pt1 / .pt * 0.8,
    vjust = 1.1
  ) +
  facet_grid(~ lec_type) +
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  scale_alpha_manual(values = rep(1, n_reps)) +
  scale_fill_manual(values = treat_clrs) +
  labs(y = "fraction predicted\nAg-competent") +
  base_theme +
  theme(
    aspect.ratio    = 1.25, 
    legend.position = "none",
    axis.title.x    = element_blank()
  )
```

<br>

Expression of the Ag-high (top) and Ag-low (bottom) gene modules is shown below
for each predicted Ag class for the 24 hpi timepoint.

* Cells predicted to
  be archiving-competent show upregulation of the Ag-high gene module
* The Ag-low gene module shows similar expression between samples

```{r "CHIKV module scores", fig.width = 9, fig.height = 5.5}
# Module scores for each prediction group
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

ag_modules <- plt_typs %>%
  map(str_c, c("_high", "_low")) %>%
  unlist()

clrs <- c(
  `Ag-low`       = treat_clrs[["mock"]],
  `Ag-competent` = treat_clrs[["CHIKV"]]
)

chikv_boxes <- ag_modules %>%
  map(~ {
    plt_dat %>%
      mutate(pred = recode(pred, high = "Ag-competent", low = "Ag-low")) %>%
      mutate(pred = fct_relevel(pred, names(clrs))) %>%
      create_chikv_boxes(
        dat_col = .x,
        ttl     = .x,
        clrs    = clrs
      )
  }) %>%
  purrr::discard(is.null)

chikv_boxes %>%
  wrap_plots(nrow = 2, byrow = FALSE, guides = "collect")
```

<br>

Expression of Ag modules is shown for predicted Ag-low and Ag-high cLECs.

```{r "cLEC module scores", fig.width = 9, fig.height = 4}
# Module scores for each prediction group
plt_typs <- "cLEC"

ag_modules <- plt_typs %>%
  map(str_c, c("_high", "_low")) %>%
  unlist()

clrs <- c(
  `Ag-low`  = treat_clrs[["mock"]],
  `Ag-competent` = treat_clrs[["CHIKV"]]
)

lab_fn <- function(x) {
  x <- str_replace(x, "cLEC_", "Ag-")
  x <- str_replace(x, "mock|CHIKV", "module")
  
  x
}

bx_dat <- plt_dat %>%
  filter(
    !is.na(pred),
    lec_type %in% plt_typs,
    tm == "24hpi"
  ) %>%
  pivot_longer(all_of(ag_modules)) %>%
  mutate(
    pred = str_c("Ag-", pred),
    pred = recode(pred, `Ag-high` = "Ag-competent"),
    pred = fct_relevel(pred, names(clrs)),
    name = fct_relevel(name, ag_modules)
  )

p_dat <- bx_dat %>%
  group_by(treatment, name) %>%
  summarize(
    p = wilcox.test(
      value[pred == names(clrs[1])],
      value[pred == names(clrs[2])]
    )$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(p, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(plab = .format_pvalue(padj)) %>%
  ungroup() %>%
  mutate(plab = str_c("italic(p) == ", plab))

bx_dat %>%
  ggplot(aes(treatment, value, fill = pred)) +
  geom_boxplot(notch = TRUE, outlier.size = 0.25, alpha = 0.9, key_glyph = draw_key_point) +
  geom_text(
    aes(y = Inf, fill = NULL, label = plab),
    data = p_dat, vjust = 1.3, parse = TRUE, size = 8 / .pt
  ) +
  facet_wrap(name ~ treatment, nrow = 1, scales = "free", labeller = as_labeller(lab_fn)) +
  labs(y = "Ag module expression") +
  scale_fill_manual(values = clrs) +
  scale_y_continuous(expand = expansion(c(0.05, 0.15))) +
  guides(fill = guide_legend(
    title = "prediction", title.position = "top", title.hjust = 0.5,
    override.aes = list(shape = 22, size = 4)
  )) +
  base_theme +
  theme(
    aspect.ratio = 2.5,
    legend.position = "bottom",
    axis.title.x = element_blank()
  )
```

<br>

Expression of Ag-high gene module is shown below for mock vs CHIKV.

```{r, fig.width = 9, fig.height = 3}

p_dat <- bx_dat %>%
  group_by(name) %>%
  summarize(
    p = wilcox.test(
      value[treatment == names(treat_clrs[1])],
      value[treatment == names(treat_clrs[2])]
    )$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(p, method = "bonferroni")) %>%
  rowwise() %>%
  mutate(plab = .format_pvalue(padj)) %>%
  ungroup() %>%
  mutate(plab = str_c("italic(p) == ", plab))

lab_fn <- function(x) {
  x <- str_replace(x, "cLEC_", "Ag-")
  x <- str_c(x, " module")
  
  x
}

bx_dat %>%
  ggplot(aes(treatment, value, fill = treatment, alpha = rep)) +
  geom_boxplot(outlier.size = 0.25, key_glyph = draw_key_point) +
  geom_text(
    aes(x = 1.5, y = Inf, fill = NULL, alpha = NULL, label = plab),
    data = p_dat, vjust = 1.3, parse = TRUE, size = 8 / .pt
  ) +
  facet_wrap(~ name, nrow = 1, scales = "free", labeller = as_labeller(lab_fn)) +
  labs(y = "Ag module expression") +
  scale_fill_manual(values = treat_clrs) +
  scale_alpha_manual(values = rep(0.9, n_reps)) +
  scale_y_continuous(expand = expansion(c(0.05, 0.15))) +
  base_theme +
  theme(
    aspect.ratio = 1.5,
    legend.position = "none",
    axis.title.x = element_blank()
  )

```

<br>

Mean expression is shown for genes from the Ag-high module for mock- and
CHIKV-infected mice from the 24 hpi timepoint.

* CHIKV-infected mice broadly downregulate Ag-high modules

```{r "cLEC CHIKV heatmaps", fig.width = 10, fig.height = 6}
rf_feats$cLEC %>%
  imap(~ {
    chikv_so %>%
      subset(lec_type == "cLEC" & tm == "24hpi") %>%
      create_chikv_heats(gns = .x, sort_gns = "down") +
      coord_flip() +
      facet_wrap(~ lec_type, ncol = 1, strip.position = "right") +
      guides(fill = guide_colorbar(
        barheight = unit(7, "pt"), barwidth = unit(120, "pt"),
        title = "expression", title.position = "top"
      )) +
      ggtitle(str_c("Ag-", .y, " module")) +
      theme(
        aspect.ratio    = 6 / length(rf_feats$cLEC$high),
        legend.position = "bottom",
        legend.title    = element_text()
      )
  }) %>%
  plot_grid(plotlist = ., ncol = 1)
```

<br>

```{r "CHIKV heatmaps", fig.width = 6, fig.height = 8.5, results = "asis"}
rf_feats[names(rf_feats) %in% chikv_typs] %>%
  iwalk(~ {
    cat("\n\n###", .y, "\n\n")
    
    plt <- chikv_so %>%
      subset(lec_type %in% chikv_typs & tm == "24hpi") %>%
      create_chikv_heats(gns = .x[[1]]) +
      theme(
        panel.border = element_rect(color = "grey30"),
        axis.text.x  = element_text(angle = 90, vjust = 0.5)
      )
    
    print(plt)
    cat("\n\n---\n\n<br>\n\n<br>\n\n")
  })
```

```{r "PLOT ALL RF GENES", eval = FALSE}
gns <- rf_feats$cLEC$high

dat <- chikv_so %>%
  subset(lec_type == "cLEC") %>%
  FetchData(c("orig.ident", "treatment", "rep", "lec_type", gns)) %>%
  as_tibble(rownames = ".cell_id") %>%
  pivot_longer(any_of(gns)) %>%
  mutate(treatment = fct_relevel(treatment, names(treat_clrs)))

dat %>%
  ggplot(aes(treatment, value, fill = treatment, alpha = rep)) +
  geom_boxplot() +
  facet_wrap(~ name) +
  scale_fill_manual(values = treat_clrs) +
  scale_alpha_manual(values = rep(0.9, n_reps)) +
  base_theme
```

## Session info

```{r "session info"}
sessionInfo()
```
