---
title: "Antigen Tracking Figures"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc:            true
    toc_float:      true
    toc_depth:      4
    df_print:       "paged"
    code_folding:   "hide"
    self_contained: true
    highlight:      "kate"
params:
  template_dir:  "src"                                                                      # Directory containing template Rmarkdowns
  so_dir:        "~/Dropbox/Ryan/Projects/antigen-exchange/results/sobjs" # Directory for loading/saving Seurat objects
  ref_dir:       "ref"                                                                      # Directory to use for loading/saving clustifyr references
  sample_info:   "sample_info.xlsx"
  res_dir:                                                
    value:
      exp-0: "~/Projects/antigen-tracking/results"
      exp-1: "~/Projects/tamburini-antigen-tracking/results/2022-03-11"
      exp-2: "~/Projects/tamburini-antigen-tracking/results/2022-10-28"
editor_options: 
  chunk_output_type: inline
---

---

<br>

```{r "setup"}
knitr::knit(here::here(params$template_dir, "setup.Rmd"), "")

# Data column to use
dat_clmn <- "Ag_class_2"
```

```{r "identify Ag DEGs"}
# Identify Ag markers for all LECs for each mouse
fc  <- 0

deg_so <- lec_so %>%
  SplitObject("mouse")

degs_1 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = "all", mouse = .y) %>%
      arrange(padj)
  })

# Identify Ag markers for subtype
deg_so <- lec_so %>%
  SplitObject("subtype")

degs_2 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y, mouse = "all") %>%
      arrange(padj)
  })

rm(deg_so)

# Identify markers for subtype and mouse
degs_3 <- lec_so@meta.data %>%
  distinct(subtype, mouse) %>%
  pmap_dfr(~ {
    res <- lec_so %>%
      subset(subtype == ..1 & mouse == ..2)
    
    if (n_distinct(res[[dat_clmn]]) < 2) return(NULL)
    
    res <- res %>%
      wilcoxauc(group_by = dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = ..1, mouse = ..2) %>%
      arrange(padj)
  })

degs <- bind_rows(degs_1, degs_2, degs_3) %>%
  filter(
    padj < 0.05, logFC > fc,
    !grepl("^(mt-|R[pls])", feature),
    feature != "Malat1"
  )

# degs %>%
#   write_tsv(here(params$so_dir, "ag-high_degs_Ag_class_2.tsv.gz"))

# # Most common degs
# top_degs <- degs %>%
#   group_by(subtype, feature, group) %>%
#   summarize(n = n_distinct(mouse), .groups = "drop") %>%
#   arrange(desc(n))
#   filter(n > 1)
```

```{r "RF functions"}
# Function to predict
rf_predict <- function(mod, dat, data_clmn = NULL, return_stats = TRUE) {
  
  prds <- mod %>%
    predict(dat, seed = 42) %>%
    ranger::predictions()
  
  res <- dat %>%
    as_tibble(rownames = ".cell_id") %>%
    mutate(pred = prds)
  
  if (is.null(data_clmn)) return(res)
  
  res <- res %>%
    dplyr::select(.cell_id, all_of(data_clmn), pred) %>%
    mutate(correct = pred == !!sym(data_clmn)) %>%
    group_by(pred) %>%
    mutate(frac_correct = sum(correct) / n()) %>%
    ungroup()
  
  if (!return_stats) return(column_to_rownames(res, ".cell_id"))
  
  res <- res %>%
    distinct(pred, frac_correct) %>%
    pivot_wider(names_from = pred, values_from = frac_correct)
  
  res
}

#' Generate RF models using given data and parameters
#' 
#' @param df_in data.frame containing features as columns and observations as
#' rows
#' @param data_clmn column in df_in containing response variable
#' @param param_lst list of RF parameters to expand and test
#' @param sample_size number of cells to use for each group in data_clmn, want
#' number of cells in each group to be equal when training model
#' @param feat_p p-value cutoff for selecting best features
#' @param min_feats minimum number of features to allow after feature selection
#' @param min_cells minimum number of cells required for each group in data_clmn
#' @param scale_data Should independent variables be scaled
#' @param select_feats should features be filtered based on p-value
#' @param df_list list of data.frames containing data for each mouse to use for
#' comparing the fraction of predicted Ag-high cells. Want a model where the
#' fraction of predicted Ag-high cells is roughly the same for all samples.
#' @param frac_grp group in data_clmn that should be used for calculating and
#' comparing fractions using data in df_list
#' @param balance_groups downsample so groups have the same number of cells
#' @param sample_info addition columns to include in data
#' @param degs data.frame of DEGs, used to determine which DEGs are markers
#' for each group, this is used to balance the features equally between groups
#' @param ... additional parameters to pass to ranger::ranger()
train_rf <- function(df_in, data_clmn, param_lst, sample_size = 135,
                     feat_p = 0.05, min_feats = 20, min_cells = 30,
                     scale_data = FALSE, select_feats = TRUE, df_list = NULL,
                     frac_grp = "high", balance_groups = TRUE,
                     group_prop = NULL, sample_info = NULL, degs = NULL, ...) {
  
  # Format train/test data
  rf_dat <- df_in %>%
    dplyr::select(
      all_of(c(data_clmn, sample_info)),
      where(~ !all(.x == 0))
    ) %>%
    mutate(!!sym(data_clmn) := factor(!!sym(data_clmn))) %>%
    rename_with(~ str_replace_all(.x, "-", "_")) %>%
    rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
    rename_with(~ str_c("x", .x), matches("^[0-9]"))
  
  # # Reverse class weights to account for imbalanced data
  # # class_weights <- class_weights / sum(class_weights)
  # class_weights <- table(rf_dat[[data_clmn]])
  # class_weights <- class_weights / min(class_weights)
  # 
  # lvls <- levels(rf_dat[[data_clmn]])
  # 
  # class_weights <- set_names(
  #   rev(class_weights),
  #   lvls
  # )
  
  # Scale data
  if (scale_data) {
    rf_dat <- rf_dat %>%
      mutate(
        across(-any_of(c(data_clmn, sample_info)), ~ as.numeric(scale(.x)))
      )
  }
  
  # Adjust groups so they are balanced
  # Split into train/test data
  # sam_sz <- min(sample_size, min(table(rf_dat[[data_clmn]])))
  if (balance_groups) {
    if (any(sample_size < min_cells)) {
      cli::cli_abort("All groups must have at least {min_cells} cells")
    }
    
    rf_train <- rf_dat %>%
      rownames_to_column(".cell_id") %>%
      split(.[[data_clmn]]) %>%
      imap_dfr(~ {
        sz <- sample_size[[.y]] 
        
        set.seed(42)
        
        .x %>%
          dplyr::sample_n(sz) %>%
          column_to_rownames(".cell_id")
      })
    
    rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
    
  } else {
    set.seed(42)
    
    rf_split <- initial_split(rf_dat, prop = 0.5)
    rf_train <- training(rf_split)
    rf_test  <- testing(rf_split)
  }
  
  rf_train <- rf_train %>%
    dplyr::select(-any_of(sample_info))
  
  # Train models
  rf_params <- expand.grid(param_lst)
  rf_params <- bind_cols(rf_params, list(...))
  
  res <- pmap_dfr(rf_params, ~ {
    args <- list(...)
    
    if (args$mtry > (ncol(rf_train) - 1)) return(NULL)
    
    args$formula       <- as.formula(str_c(data_clmn, " ~ ."))
    args$data          <- rf_train
    args$importance    <- args$importance %||% "impurity_corrected"
    args$seed          <- 42
    # args$class.weights <- args$class.weights %||% class_weights
    # args$class.weights <- c(high = 1, low = 200)
    
    set.seed(42)
    
    raw_mod <- mod <- lift_dl(ranger)(args)
    
    raw_err   <- raw_mod$prediction.error
    key_feats <- importance(raw_mod)
    
    # Feature selection
    if (select_feats) {
      key_feats <- raw_mod %>%
        importance_pvalues() %>%
        .[, "pvalue"] %>%
        sort()
      
      max_p <- key_feats %>%
        head(min_feats) %>%
        max()
      
      feat_p <- max(max_p, feat_p)
      
      key_feats <- key_feats[key_feats < feat_p] %>%
        names()
      
      n_feats <- length(key_feats)
      
      # Re-train model
      args$mtry       <- min(args$mtry, n_feats)
      args$data       <- rf_train[, c(data_clmn, key_feats)]
      args$importance <- "none"
      
      set.seed(42)
      
      mod <- lift_dl(ranger)(args)
    }
    
    err <- mod$prediction.error
    
    # Compare fraction predicted groups with ground truth from training data
    frac_stats <- df_list %>%
      imap_dfr(~ {
        mod %>%
          rf_predict(.x, data_clmn = data_clmn, return_stats = FALSE) %>%
          mutate(sample = .y)
      }) %>%
      group_by(sample) %>%
      summarize(
        frac_high = sum(pred == frac_grp) / n(),
        .groups   = "drop"
      ) %>%
      summarize(
        frac_mean = mean(frac_high),
        frac_sd   = sd(frac_high)
      )
    
    # Test model
    prds <- mod %>%
      rf_predict(
        dat          = rf_test,
        data_clmn    = data_clmn,
        return_stats = TRUE
      )
                                         # only used for continuous
    # err <- sqrt(res$prediction.error)  # response variables
    
    # Format output table
    tibble(
      raw_mod   = list(raw_mod),
      mod       = list(mod),
      feats     = list(key_feats),
      n_train   = nrow(rf_train),
      n_test    = nrow(rf_test),
      # train_bcs = list(rownames(rf_train)),
      # test_bcs  = list(rownames(rf_test)),
      ...,
      n_feats = length(key_feats),
      oob_raw = raw_err,
      oob     = err
    ) %>%
      bind_cols(frac_stats) %>%
      bind_cols(prds)
  })
  
  res <- res %>%
    arrange(oob)
  
  res
}

create_gn_plots <- function(so_in, gns, plt_clrs, p_alt = "greater", n_gns = 10) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  gn_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns))
  
  plt_dat <- gn_dat %>%
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(
      med = median(value),
      q1  = quantile(value, 0.25),
      q3  = quantile(value, 0.75),
      .groups = "drop"
    ) %>%
    mutate(pred_grp = fct_relevel(pred_grp, names(plt_clrs))) %>%
    group_by(name, mouse, subtype) %>%
    
    filter(sum(med) > 0) %>%
    mutate(cor = cor(as.numeric(pred_grp), med)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse) == n_mice) %>%
    ungroup()
  
  # Calculate p-values
  clmn2 <- names(pred_clrs[2])
  clmn3 <- names(pred_clrs[3])
  
  p_clmns <- c(clmn2, clmn3)
  
  p_dat <- gn_dat %>%
    group_by(mouse, subtype, pred_grp, name) %>%
    mutate(y = quantile(value, 0.75)) %>%
    group_by(mouse, subtype, name) %>%
    summarize(
      y = max(y),
      
      !!sym(clmn2) := wilcox.test(
        value[pred_grp == clmn2], value[pred_grp == "low"],
        alternative = p_alt
      )$p.value,
      !!sym(clmn3) := wilcox.test(
        value[pred_grp == clmn3], value[pred_grp == "low"],
        alternative = p_alt
      )$p.value,
      .groups = "drop"
    ) %>%
    group_by(name) %>%
    mutate(y = max(y)) %>%
    
    group_by(mouse, subtype) %>%
    mutate(across(all_of(p_clmns), ~ p.adjust(.x, method = "bonferroni"))) %>%
    ungroup() %>%
    
    pivot_longer(all_of(p_clmns), names_to = "pred_grp", values_to = "p") %>%
    filter(p < 0.05)
  
  # Rank genes by number of significant p-values
  gns <- p_dat %>%
    group_by(name) %>%
    summarize(n = n()) %>%
    filter(name %in% plt_dat$name) %>%
    arrange(desc(n)) %>%
    head(n_gns) %>%
    pull(name) %>%
    as.character()
  
  # Create plots
  res <- plt_dat %>%
    filter(name %in% gns) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    ggplot(aes(pred_grp, med, color = mouse)) +
    geom_segment(
      aes(x = pred_grp, xend = pred_grp, y = q1, yend = q3),
      linewidth = 1, color = ln_col
    ) +
    geom_point(aes(size = pred_grp)) +
    geom_smooth(
      aes(x = as.numeric(as.factor(pred_grp))),
      method = "lm", linewidth = 0.25, linetype = 2,
      se = FALSE, formula = y ~ x
    ) +
    geom_point(
      aes(y = y),
      data = filter(p_dat, name %in% gns),
      position = position_nudge(y = 0.2),
      color = "black", shape = 6, size = 1
    ) +
    facet_grid(name ~ mouse, scales = "free_y", switch = "y") +
    scale_size_manual(values = c(1, 1.25, 1.25)) +
    scale_color_manual(values = m_clrs) +
    scale_y_continuous(breaks = ~ c(ceiling(min(.x)), floor(max(.x)))) +
    djvdj_theme() +
    theme(
      aspect.ratio    = 1,
      legend.position = "none",
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1),
      strip.placement = "outside"
    )
  
  res
}

create_sig_umap <- function(so_in, dat_col, clrs) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = "mouse",
      outline     = TRUE,
      plot_colors = clrs,
      panel_nrow  = 1,
      size        = 0.15,
      stroke      = 0.6
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    djvdj_theme() +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_grp_umap <- function(so_in, dat_col, clrs) {
  so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = "mouse",
      outline     = TRUE,
      plot_colors = clrs,
      plot_lvls   = c("high-pred", "low", "high", "other"),
      panel_nrow  = 1,
      size        = 0.25,
      stroke      = 0.8,
      color = ln_col,
      trace_position = "bottom"
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    djvdj_theme() +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F")) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(pred_grp = fct_relevel(pred_grp, lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = "pred_grp", values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character()
  
  # Create heatmaps
  res <- heat_dat %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(pred_grp, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    djvdj_theme() +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.x  = element_text(angle = 45, hjust = 1),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}
```

```{r "train RF models"}
# Params for RF
dat_clmn   <- "Ag_class_2"
ms         <- "d14"
other_info <- c("subtype", "mouse")

# Select LEC subsets
typs <- lec_so@meta.data %>%
  filter(mouse == ms) %>%
  group_by(subtype, Ag_class_2) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(subtype) %>%
  filter(all(n > 60)) %>%
  ungroup() %>%
  pull(subtype) %>%
  unique()

# Train models for each LEC subtype
type_mods <- typs %>%
  map_dfr(~ {
    rf_dat <- lec_so %>%
      subset(subtype == .x & mouse == ms) %>%
      FetchData(unique(c(dat_clmn, other_info, feats)))
    
    all_dat <- lec_so %>%
      subset(subtype == .x) %>%
      FetchData(unique(c(dat_clmn, other_info, feats))) %>%
      rename_with(~ str_replace_all(.x, "-", "_")) %>%
      rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
      rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
      split(.$mouse)
    
    group_size  <- table(rf_dat[[dat_clmn]])
    target_frac <- group_size[["high"]] / sum(group_size)
    sam_size    <- floor(min(group_size) / 2)
    
    sam_size <- set_names(
      rep(sam_size, length(group_size)),
      names(group_size)
    )
    
    # Select features
    # calculate proportion of features identified for each group
    feats <- degs %>%
      filter(subtype == .x)
    
    feat_frac <- table(feats$group)
    feat_frac <- feat_frac / sum(feat_frac)
    
    feats <- feats %>%
      pull(feature) %>%
      unique()
    
    # Set RF params
    param_lst <- list(
      mtry          = seq(1, length(feats), floor(length(feats) / 15)),
      # min.node.size = 1:10,
      # num.trees     = seq(50, 1000, 100)
      min.node.size = c(1, 3, 5),
      num.trees     = c(50, 400, 1000)
    )
    
    # Train model
    res <- rf_dat %>%
      train_rf(
        data_clmn   = dat_clmn,
        param_lst   = param_lst,
        sample_info = other_info,
        group_prop  = feat_frac,
        df_list     = all_dat[names(all_dat) != ms],
        scale_data  = FALSE,
        sample_size = sam_size
      )

    # Identify best models
    res <- res %>%
      arrange(
        desc(frac_mean < target_frac + 0.05 & frac_mean > target_frac - 0.05),
        desc(frac_mean < target_frac + 0.1 & frac_mean > target_frac - 0.1),
        desc(frac_sd < 0.1),
        oob,
        desc(low),
        desc(high)
      ) %>%
      mutate(
        subtype = .x,
        rank = row_number()
      )
      
    res
  })

# type_mods <- qread(here(params$so_dir, "lec_rf_mods.qs"))

# Identify best models
# type_mods %>%
#   arrange(desc(frac_sd < 0.1)) %>%
#   arrange(desc(frac_mean < target_frac + 0.1 & frac_mean > target_frac - 0.1)) %>%
#   filter(high > 0.5, low > 0.5) %>%
#   arrange(desc(high), desc(low), oob) %>%
#   slice(1:5) %>%
#   print(n = 30)
best_mods <- type_mods %>%
  arrange(desc(low), desc(high)) %>%
  group_by(subtype) %>%
  slice(1)

# Pull best features
best_feats <- best_mods %>%
  pmap(~ {
    args <- list(...)
    
    fts <- args$feats %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    degs %>%
      filter(feature %in% fts) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == ms ~ 1,
        subtype == args$subtype               ~ 2,
        mouse   == ms                         ~ 3,
        TRUE                                  ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
  })

names(best_feats) <- best_mods$subtype

all_feats <- best_feats %>%
  unlist(use.names = FALSE) %>%
  unique()
```

```{r "predict Ag class"}
# Predict Ag class
pred_dat <- lec_so %>%
  FetchData(unique(c(dat_clmn, other_info, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  column_to_rownames(".cell_id")

type_preds <- best_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse)
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

lec_so <- lec_so %>%
  AddMetaData(type_preds, col.name = c("type_pred", "type_correct"))

# Format prediction labels
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    pred_grp = case_when(
      Ag_class_2 == "high" ~ Ag_class_2,
      type_pred  == "high" ~ "high-pred",
      TRUE                 ~ Ag_class_2
    ),
    mouse = fct_relevel(mouse, mice)
  )

# Add module scores
best_feats %>%
  iwalk(~ {
    clmn_nms <- str_c(.y, "_", names(.x))

    lec_so <<- lec_so %>%
      AddModuleScore(
        features = .x,
        name     = clmn_nms
      )
  })
```

## Classifying Ag-high

Ag-low and -high cells were identified by separatly clustering each LEC subset
for each sample into two groups based on Ag-score. Ag-low/high classifications
are shown below.

```{r "plotting params"}
pred_clrs <- c(
  low         = "#6A51A3",
  `high-pred` = "#E69F00",
  high        = "#D7301F"
)
```

```{r "Ag signal", fig.width = 8, fig.height = 4}
plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

clmn <- "Ag_class_2"

plt_dat <- lec_so@meta.data %>%
  filter(subtype %in% plt_typs)

plt_labs <- plt_dat %>%
  group_by(subtype, mouse, !!sym(clmn)) %>%
  summarize(
    n = label_comma()(n()),
    .groups = "drop"
  ) %>%
  mutate(
    n = str_c(!!sym(clmn), ": ", n, " cells"),
    !!sym(clmn) := fct_relevel(!!sym(clmn), names(pred_clrs))
  ) %>%
  group_by(subtype, mouse) %>%
  arrange(!!sym(clmn)) %>%
  mutate(n = str_c(n, collapse = "\n"))
  
plt_dat %>%
  ggplot(aes(Ag_score, after_stat(count) + 1, fill = mouse, alpha = !!sym(clmn))) +
  geom_histogram(bins = 30) +
  geom_text(
    aes(Inf, Inf, label = n),
    data = plt_labs,
    check_overlap = TRUE,
    alpha = 1,
    hjust = 1.1,
    vjust = 1.1,
    size  = txt_pt1 / .pt * 0.65
  ) +
  facet_grid(subtype ~ mouse, scales = "free") +
  guides(fill = "none", alpha = guide_legend(title = "Ag group")) +
  scale_alpha_manual(values = c(low = 0.25, high = 0.75)) +
  scale_fill_manual(values = m_clrs) +
  scale_y_log10(expand = expansion(c(0.05, 0.2))) +
  labs(x = "Ag-score", y = "number of cells") +
  djvdj_theme() +
  theme(
    aspect.ratio = 0.7
  )
```

<br>

The fraction of cells belonging to each predicted Ag group is shown on the left
for cLECs from each sample.
The fraction of cells incorrectly predicted to be Ag high (high-pred) is shown
on the right for each sample.

Since we are training the model to identify gene signatures that are expressed
in naive mice and should continue to be expressed in our later timepoints after
Ag levels have fallen, we expect to observe an increasing fraction of false
positives for the later timepoints.

```{r "fraction Ag-high", fig.width = 8, fig.height = 4}
# Format data
plt_typs <- "cLEC"

bar_dat <- lec_so@meta.data %>%
  filter(subtype %in% plt_typs) %>%
  rename(prediction = type_pred, correct = type_correct) %>%
  mutate(correct = fct_relevel(as.character(correct), c("TRUE", "FALSE")))

bar_thm <- djvdj_theme() +
  theme(axis.title.y = element_blank())

# Plot fraction predicted groups
bar_1 <- bar_dat %>%
  ggplot(aes(mouse, fill = prediction, alpha = correct)) +
  geom_bar(position = "fill") +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
  scale_fill_manual(values = pred_clrs) +
  facet_grid(~ subtype) +
  bar_thm

bar_2 <- bar_dat %>%
  ggplot(aes(mouse, fill = pred_grp)) +
  geom_bar(position = "fill", alpha = 0.85) +
  facet_grid(~ subtype) +
  scale_fill_manual(values = pred_clrs) +
  bar_thm +
  theme(legend.title = element_blank())

plot_grid(
  bar_1, bar_2, 
  nrow = 1,
  align = "tb",
  axis  = "trbl"
)
```

---

<br>

<br>

## Ag modules

The top positive (top) and negative (bottom) gene modules are shown below for
each sample. We see a notable correlation between the expression of these genes
and the Ag class. False positive Ag high cells (high-pred) show
intermediate levels of expression that falls roughly between the true Ag-low and
true Ag-high cells.

This suggests that the false positive Ag high cells are potentially cells that
are archiving competent but have now lost/released most Ag at the later
timepoints.

```{r "modules", fig.width = 10, fig.height = 6}
# Boxplots
modules <- c(
  cLEC_high1 = "cLEC Ag-high module",
  cLEC_low2  = "cLEC Ag-low module"
)

plt_typs <- c("cLEC", "Collecting", "fLEC", "Ptx3_LEC")

modules %>%
  imap(~ {
    lec_so %>%
      FetchData(c("subtype", "mouse", "pred_grp", .y)) %>%
      filter(subtype %in% plt_typs) %>%
      mutate(
        subtype = fct_relevel(subtype, plt_typs),
        pred_grp = fct_relevel(pred_grp, names(pred_clrs))
      ) %>%
      ggplot(aes(mouse, !!sym(.y), fill = pred_grp)) +
      geom_boxplot(outlier.size = 0.1, key_glyph = draw_key_point) +
      scale_fill_manual(values = pred_clrs) +
      facet_wrap(~ subtype, nrow = 1) +
      ggtitle(.x) +
      guides(fill = guide_legend(override.aes = list(shape = 22, size = 4))) +
      djvdj_theme() +
      theme(
        aspect.ratio = 0.75,
        legend.title = element_blank(),
        axis.title.y = element_blank()
      )
  }) %>%
  wrap_plots(guides = "collect", ncol = 1) &
  theme(legend.position = "bottom")
```

<br>

UMAP projections show Ag-high module expression for each sample, the main cLEC
cluster is circled.

```{r "module scores", fig.width = 10, fig.height = 4}
# Plot module scores
circ_dat <- lec_so@meta.data %>%
  filter(subtype == "cLEC") %>%
  group_by(mouse) %>%
  summarize(across(c(hUMAP_1, hUMAP_2), mean))

ag_mod_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    lec_so %>%
      subset(mouse == .x) %>%
      create_sig_umap(
        dat_col = "cLEC_high1",
        clrs = c("lightblue", "white", pred_clrs[["high"]])
      ) +
      geom_circle(
        aes(x0 = hUMAP_1, y0 = hUMAP_2, fill = NULL, color = NULL, r = 2),
        data = filter(circ_dat, mouse == .x),
        linetype = 2
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "cLEC Ag-high module",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

ag_mod_u
```

<br>

UMAP projections show true Ag-low and true Ag-high cLECs. Ag-high cells occupy
the far right portion of the cluster which coincides with highest expression of
the Ag-high gene module.

```{r "low vs high", fig.width = 10, fig.height = 5}
# Plot Ag-low vs Ag-high
clrs <- rev(pred_clrs)
clrs[c("low", "high-pred")] <- "#56B4E9"
clrs["other"]               <- "white"

u_so <- lec_so %>%
  mutate_meta(
    mutate,
    pred_grp  = ifelse(subtype == "cLEC", pred_grp, "other"),
    pred_grp1 = ifelse(pred_grp %in% c("high", "low"), pred_grp, "other"),
    pred_grp2 = ifelse(pred_grp %in% c("high", "high-pred"), pred_grp, "other")
  )

ag_low_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    u_so %>%
      subset(mouse == .x) %>%
      create_grp_umap(
        dat_col = "pred_grp1",
        clrs    = clrs
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "Ag-low vs Ag-high",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

ag_low_u
```

<br>

UMAP projections show false positive Ag-high and true Ag-high cLECs. False
positive Ag-high cells overlap true Ag-high cells on the projection.

```{r "high-pred vs high", fig.width = 10, fig.height = 5}
# Plot Ag-high vs predicted Ag-high
ag_high_u <- mice[mice %in% lec_so$mouse] %>%
  imap(~ {
    u_so %>%
      subset(mouse == .x) %>%
      create_grp_umap(
        dat_col = "pred_grp2",
        clrs    = clrs
      )
  }) %>%
  wrap_plots(nrow = 1) +
  plot_annotation(
    title = "Ag-high predicted vs Ag-high",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = ttl_pt2)
    )
  )

# Create final figure
plot_grid(
  ag_mod_u, ag_low_u, ag_high_u,
  ncol = 1,
  align = "vh",
  axis  = "trbl"
)

ag_high_u
```

---

<br>

<br>

## Ag features

```{r "top features heatmaps"}
# Heatmap
heats <- best_feats$cLEC %>%
  imap(~ {
    lec_so %>%
      subset(subtype == "cLEC") %>%
      create_heats(
        gns = .x,
        sort_gns = switch(.y, high = "up", low = "down")
      ) +
      theme(
        panel.border = element_rect(color = "grey30")
      )
  })
```

```{r "top features examples", fig.height = 8, fig.width = 8}
plt_args <- list(
  gns   = best_feats$cLEC,
  p_alt = c("greater", "less"),
  n_gns = c(10, 7)
)
gn_plots <- plt_args %>%
  pmap(~ {
    args <- list(...)
    lec_so %>%
      subset(subtype == "cLEC") %>%
      create_gn_plots(
        gns      = args$gns,
        plt_clrs = pred_clrs,
        p_alt    = args$p_alt,
        n_gns    = args$n_gns
      ) +
      theme(
        panel.border = element_rect(color = "grey75")
      )
  })
```

Mean expression is shown on the left for genes from the Ag-high module for
true Ag-low, true Ag-high, and false positive Ag-high (high-pred) cells.
Expression is shown on the right for select top features.

Points show median expression, grey bars show interquartile range, dotted line
shows the trend, and diamonds indicate the gene is significantly up or down
regulated when compared to Ag-low cells.

```{r "Ag-high examples", fig.height = 8, fig.width = 10}
plot_grid(heats[[1]], gn_plots[[1]])
```

<br>

Mean expression is shown on the left for genes from the Ag-low module as
described above.

```{r "Ag-low examples", fig.height = 6, fig.width = 10}
plot_grid(heats[[2]], gn_plots[[2]])
```

---

<br>

<br>

## Ag archiving in CHIKV

```{r "CHIKV RF", eval = FALSE}
# Load CHIKV data
chikv_so <- qread("~/Dropbox/Ryan/Projects/morrison-lnsc/results/sobjs/so_merge.qs")

# Format RF data
# need to add zeros for missing genes
clmns <- c(
  "orig.ident", "rep", "treatment", "tm",
  "cell_type_2", "cell_type", "lec_type", "subtype",
  "UMAP_1", "UMAP_2"
)

chikv_rf_dat <- chikv_so %>%
  FetchData(c(clmns, best_feats)) %>%
  mutate(across(any_of(best_feats), ~ as.numeric(scale(.x))))

missing_gns <- best_feats[!best_feats %in% colnames(chikv_rf_dat)]

chikv_rf_dat[, missing_gns] <- 0

chikv_rf_dat <- chikv_rf_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Predict for CHIKV data
chikv_preds <- best_mod %>%
  rf_predict(dat = chikv_rf_dat) %>%
  dplyr::select(.cell_id, pred) %>%
  column_to_rownames(".cell_id")

chikv_so <- chikv_so %>%
  AddMetaData(chikv_preds) %>%
  AddModuleScore(features = best_feats_lst, name = names(best_feats_lst))

# Plot fraction predicted archiving capable
chikv_so@meta.data %>%
  filter(cell_type_2 == "LEC") %>%
  ggplot(aes(orig.ident, fill = pred)) +
  geom_bar(position = "fill") +
  facet_grid(tm ~ lec_type) +
  djvdj_theme() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Module scores for each prediction group
chikv_so@meta.data %>%
  ggplot(aes(orig.ident, high1, fill = pred)) +
  geom_boxplot() +
  facet_wrap(tm ~ lec_type, scales = "free_y") +
  djvdj_theme()

chikv_so@meta.data %>%
  ggplot(aes(orig.ident, low2, fill = treatment)) +
  geom_boxplot() +
  facet_wrap(tm ~ lec_type, scales = "free_y") +
  djvdj_theme()
```

---

<br>

<br>

## Session info
```{r "session info"}
sessionInfo()
```



```{r "RF MOUSE DEGS", eval = FALSE}
# Identify mouse markers for subtype
deg_so <- lec_so %>%
  SplitObject("subtype")

ms_degs <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = "mouse")

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y) %>%
      arrange(padj)
  })

rm(deg_so)

ms_degs <- ms_degs %>%
  filter(padj < 0.05, logFC > 1)
```

```{r "RF PARAMS OLD", eval = FALSE}
# dat_clmn <- "Ag_class_2"
# typ      <- "cLEC"
# ms       <- "d14"
# 
# # Select features
# # use cLEC DEGs from all timepoints 
# feats <- degs %>%
#   filter(subtype == typ) %>%
#   pull(feature) %>%
#   unique()
# 
# # Format data
# # use all cLEC features
# other_info <- c("subtype", "mouse")
# 
# rf_dat <- lec_so %>%
#   subset(subtype == typ & mouse == ms) %>%
#   FetchData(unique(c(dat_clmn, other_info, feats)))
# 
# all_dat <- lec_so %>%
#   subset(subtype == typ) %>%
#   FetchData(unique(c(dat_clmn, other_info, feats))) %>%
#   rename_with(~ str_replace_all(.x, "-", "_")) %>%
#   rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
#   rename_with(~ str_c("x", .x), matches("^[0-9]"))
# 
# group_size  <- table(rf_dat[[dat_clmn]])
# target_frac <- group_size[["high"]] / sum(group_size)
# sam_size    <- floor(min(group_size) / 2)
# 
# # Parameters for RF
# param_lst <- list(
#   mtry          = seq(1, length(feats), floor(length(feats) / 15)),
#   min.node.size = c(1, 3, 5),
#   num.trees     = c(50, 400, 1000)
# )
```

```{r "RF MOUSE OLD", eval = FALSE}
# Format data
other_info <- c("subtype", "mouse")

rf_dat <- lec_so %>%
  subset(subtype == typ) %>%
  FetchData(unique(c(dat_clmn, other_info, feats)))

# Identify features top features that correlate with mouse
rf_ms <- rf_dat %>%
  train_rf(
    data_clmn    = "mouse",
    param_lst    = param_lst,
    sample_size  = 107
  )

ms_feats <- rf_ms %>%
  arrange(oob) %>%
  head(1) %>%
  pull(feats) %>%
  unlist()
```

```{r "RF MODELS OLD", eval = FALSE}
# Train models
rf_res <- rf_dat %>%
  train_rf(
    data_clmn   = dat_clmn,
    param_lst   = param_lst,
    sample_info = other_info,
    sample_size = 135,
    df_list     = all_dat[names(all_dat) != ms],
    scale_data  = TRUE
  ) %>%
  arrange(desc(low), desc(high))

# Pull best model
best_mod <- rf_res %>%
  arrange(oob, desc(low), desc(high)) %>%
  filter(
    frac_mean < target_frac + 0.05,
    frac_mean > target_frac - 0.05
  ) %>%
  head(1)

best_feats <- best_mod %>%
  pull(feats) %>%
  unlist() %>%
  str_replace_all("_", "-") %>%
  str_remove("^x")

best_feats_lst <- degs %>%
  filter(
    subtype == typ,
    feature %in% best_feats
  ) %>%
  split(.$group) %>%
  map(~ unique(pull(.x, feature)))

best_mod <- best_mod$mod[[1]]
```

```{r "RF PREDICTION OLD", eval = FALSE}
# Predict for other timepoints
preds <- all_dat %>%
  imap_dfr(~ {
    best_mod %>%
      rf_predict(.x, data_clmn = dat_clmn, return_stats = FALSE) %>%
      mutate(mouse = .y)
  })

# Plot predicted classifications
pred_meta <- preds %>%
  dplyr::select(pred, correct)

lec_so <- lec_so %>%
  AddMetaData(pred_meta)

lec_so %>%
  plot_scatter(
    "pred", "hUMAP_1", "hUMAP_2",
    group_col = "mouse",
    size = 0.1,
    panel_nrow = 1
  ) +
  theme(aspect.ratio = 0.9)

# Fraction predicted in each mouse
plt_dat <- lec_so %>%
  subset(subtype == typ) %>%
  AddModuleScore(features = best_feats_lst, name = names(best_feats_lst)) %>%
  mutate_meta(
    mutate,
    pred_grp = case_when(
      Ag_class_2 == "high" ~ Ag_class_2,
      pred       == "high" ~ "high-predicted",
      TRUE                 ~ Ag_class_2
    ),
    mouse = fct_relevel(mouse, mice)
  )

plt_dat %>%
  plot_frequency("pred_grp", cluster_col = "mouse")

# Module scores for each prediction group
# expect that these genes will be highest expressed in high, high-predicted,
# lowest in low
# 3wk sample shows opposite
plt_dat@meta.data %>%
  ggplot(aes(mouse, high1, fill = pred_grp)) +
  geom_boxplot() +
  djvdj_theme()
```