
```{r "h2o setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# Colors
pred_clrs <- c(
  `Ag-low`       = "#6A51A3",
  `Ag-competent` = "#E69F00",
  `Ag-high`      = "#D7301F"
)

# RF parameters
rf_dat_clmn  <- "Ag_class_ml"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"
rf_typs      <- c("cLEC", "fLEC", "Collecting")

ag_lvls <- c("high", "low")

# Check for RF predictions
TRAIN_MODELS <- !file.exists(here(params$mod_dir, "ag-high_preds.tsv.gz"))

# Start h2o session
library(h2o)

invisible(h2o.init())
```

```{r "h2o functions"}
# Filter RF data to include correct cell types, timepoints, and to remove cells
# that were used to train models 
.filter_rf_data <- function(df, filt, timepoints = rf_tms, cell_types = rf_typs) {
  df %>%
    filter(
      tm %in% timepoints,
      subtype %in% cell_types,
      !training_data,
      {{filt}}
    )
}

.subset_rf_data <- function(so, filt, timepoints = rf_tms, cell_types = rf_typs) {
  cells <- so@meta.data %>%
    .filter_rf_data({{filt}}, timepoints, cell_types) %>%
    rownames()
  
  so %>%
    subset(cells = cells)
}

.prepare_ml_data <- function(obj, feats, class_clmn = rf_dat_clmn, scale = TRUE,
                             lvls = ag_lvls, missing_value = NA) {
  # Identify missing features
  feats <- unique(feats)
  
  missing_feats <- feats[!feats %in% rownames(obj)]
  
  # Pull features
  dat <- obj %>%
    FetchData(unique(c(class_clmn, feats)))
  
  if (!is.null(class_clmn) && !is.null(lvls)) {
    dat <- dat %>%
      mutate(!!sym(class_clmn) := factor(!!sym(class_clmn), lvls))
  }
  
  dat[, missing_feats] <- as.numeric(missing_value)
  
  # Scale data separately for each cell
  dat <- dat %>%  
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(feats))
    
  if (scale) {
    dat <- dat %>%
      group_by(.cell_id) %>%
      mutate(value = as.numeric(scale(value))) %>%
      ungroup()
  }
  
  # Format final data.frame
  dat <- dat %>%
    pivot_wider() %>%
    column_to_rownames(".cell_id")
  
  dat
}

# Performs final performance assessment using test data
# * also identifies optimal classification cutoff based on validation data
# * returns data frame with final model and metrics
.assess_ml <- function(ml, metric = "f1", valid_data, test_data,
                       class_clmn = rf_dat_clmn, class_lvls = ag_lvls) {
  
  # Identify optimal classification threshold using validation data
  perf <- ml %>%
    h2o.performance(newdata = valid_data) %>%
    h2o.metric() %>%
    as_tibble() %>%
    arrange(desc(!!sym(metric)))
  
  threshold <- perf %>%
    filter(!!sym(metric) == max(!!sym(metric))) %>%
    pull(threshold)
  
  # Perform final test using optimized threshold
  predict_fn <- function(dat) {
    h2o.predict(ml, dat) %>%
      as.data.frame() %>%
      mutate(adj_pred = if_else(
        !!sym(class_lvls[2]) > threshold, class_lvls[2], class_lvls[1]
      ))
  }
  
  pred <- test_data %>%
    predict_fn() %>%
    pull(adj_pred) %>%
    factor(levels = class_lvls)
  
  final_stats <- confusionMatrix(
    pred,
    factor(as.vector(test_data[[class_clmn]]), class_lvls)
  )
  
  # Function to predict using optimized threshold
  # Format output tibble
  res <- final_stats$byClass %>%
    t() %>%
    as_tibble() %>%
    mutate(
      model_id   = ml@model_id,
      model      = list(ml),
      predict_fn = list(predict_fn),
      .before    = 1
    )
  
  res
}

# Pulls the top models from an H2OAutoML object
# * Uggghhh have to grab the top models from the printed output of the
#   leaderboard since the leaderboard h2o.frame was not saved to disk
.select_best_models <- function(ml, n = 2, model_path, load = FALSE) {
  if (load) {
    if (n > 6) cli_abort("n must be less than 7")
    
    str_cap <- capture.output(ml@leaderboard) %>%
      str_extract("(?<= )[^ ]+(?= )")
    
    top_mls <- str_cap[str_cap != "model_id"]
    
  } else {
    top_mls <- ml@leaderboard %>%
      as_tibble() %>%
      pull(model_id)
  }
  
  top_mls <- head(top_mls, n)
  
  res <- top_mls %>%
    set_names() %>%
    map(~ {
      here(model_path, .x) %>%
        path.expand() %>%
        h2o.loadModel()
    })
  
  res
}

create_gn_plots <- function(so_in, p_data,
                            x = "ml_pred_1_grp", plt_clrs, x_lvls,
                            n_gns = 10, top_gns = NULL,
                            p_test = wilcox.test, draw_line = TRUE, pt_size = 1,
                            sort = TRUE) {
  
  # Set genes to plot
  gns <- p_data %>%
    distinct(gene, class) %>%
    mutate(top = gene %in% top_gns) %>%
    group_by(class) %>%
    mutate(rank = row_number()) %>%
    arrange(desc(top), rank) %>%
    slice(1:n_gns) %>%
    ungroup() %>%
    arrange(rank)
  
  gns <- set_names(gns$class, gns$gene)
  
  p_data <- p_data %>%
    filter(gene %in% names(gns))
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  cell_type <- unique(so_in$subtype)
  
  if (length(cell_type) > 1) cli_abort("Object contains more than one cell type")
  
  plt_dat <- so_in %>%
    FetchData(c("mouse", "tm", "subtype", x, names(gns))) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(names(gns)), names_to = "gene") %>%
    left_join(p_data, by = c("tm", x, "subtype", "gene")) %>%
  
    mutate(
      gene      = fct_relevel(gene, names(gns)),
      tm        = str_c("day ", tm),
      x         = str_c(!!sym(x), "-", tm),
      !!sym(x) := fct_relevel(!!sym(x), x_lvls),
    ) %>%
    arrange(!!sym(x)) %>%
    mutate(x = fct_inorder(x))
  
  plt_dat <- plt_dat %>%
    group_by(gene, mouse, tm, subtype, !!sym(x), x) %>%
    summarize(
      n       = n_distinct(.cell_id),
      med     = median(value),
      q1      = quantile(value, 0.25),
      q3      = quantile(value, 0.75),
      p_adj   = unique(p_adj),
      .groups = "drop"
    ) %>%
    group_by(gene) %>%
    mutate(range = max(q3) - min(q1)) %>%
    ungroup() %>%
    mutate(
      class = gns[gene],
      p_y = q3 + (range * 0.2)
    )
  
  # Format x-axis labels
  x_lab <- plt_dat %>%
    mutate(
      xlab = scales::label_comma()(n),
      xlab = str_c(!!sym(x), " (n = ", xlab, ")")
    ) %>%
    distinct(xlab, x)
  
  x_lab <- set_names(x_lab$xlab, x_lab$x)
  
  # Create boxplots
  plt_dat <- split(plt_dat, plt_dat$class)
  
  res <- plt_dat %>%
    imap(~ {
      cls <- .y
      
      plt <- .x %>%
        ggplot(aes(x, med, color = !!sym(x))) +
        geom_segment(
          aes(x = x, xend = x, y = q1, yend = q3),
          linewidth = pt_size, color = ln_col
        ) +
        geom_point(aes(size = !!sym(x)))
      
      if (draw_line) {
        plt <- plt +
          geom_smooth(
            aes(x = as.numeric(as.factor(!!sym(x)))),
            method = "lm", linewidth = 0.25, linetype = 2,
            se = FALSE, formula = y ~ x
          )
      }
      
      plt <- plt +
        geom_point(
          aes(y = p_y),
          data = ~ filter(.x, class == cls, p_adj < 0.05),
          color = "black", shape = 6, stroke = 1, size = pt_size
        ) +
        facet_grid(gene ~ tm, scales = "free", switch = "y") +
        scale_size_manual(values = c(pt_size, pt_size * 1.25, pt_size * 1.25)) +
        scale_color_manual(values = plt_clrs) +
        scale_y_continuous(
          breaks = ~ c(ceiling(min(.x)), floor(max(.x))),
          sec.axis = dup_axis(name = str_c(cell_type, " Ag-", .y))
        ) +
        scale_x_discrete(labels = x_lab) +
        base_theme +
        theme(
          aspect.ratio       = 1,
          plot.margin        = margin(15, 15, 15, 15),
          legend.position    = "none",
          panel.border       = element_rect(color = "grey75"),
          strip.placement    = "outside",
          axis.ticks.y.right = element_blank(),
          axis.title         = element_blank(),
          axis.title.y.right = element_text(angle = 270, size = ttl_pt2 * 1.2),
          axis.text.y.right  = element_blank(),
          axis.text.x        = element_text(angle = 45, hjust = 1)
        )
      
      # Adjust theme
      if (.y == dplyr::first(names(plt_dat))) {
        plt <- plt +
          theme(
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank()
          )
        
      } else {
        plt <- plt +
          theme(
            strip.text.x = element_blank(),
            plot.margin  = margin(20, 15, 15, 15)
          )
      }
      
      plt
    })
  
  res
}

create_sig_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            pt_size = 0.15, pt_stroke = 0.6,
                            scale_limits = NULL, outline = TRUE) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      outline      = outline,
      plot_colors  = clrs,
      panel_nrow   = 1,
      size         = pt_size,
      stroke       = pt_stroke,
      label_params = list(size = ttl_pt2)
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = 18),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  if (!is.null(scale_limits)) {
    res <- res +
      scale_fill_gradientn(colours = clrs, limits = scale_limits)
  }
  
  res
}

create_grp_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            lvls = c("Ag-competent", "Ag-low", "Ag-high", "other"),
                            ...) {

  # Format n labels  
  n_labs <- so_in %>%
    filter(!is.na(!!sym(dat_col))) %>%
    group_by(!!sym(dat_col)) %>%
    summarize(n = n()) %>%
    mutate(
      n_lab = str_c(!!sym(dat_col), "\nn = ", n)
    )
  
  n_labs <- set_names(n_labs$n_lab, n_labs[[dat_col]])
  
  lvls <- lvls[lvls %in% names(n_labs)]
  
  # Create UMAPs
  # * add colors separately since ggplot2 3.5.1 automatically includes `NA` in
  #   plot legend
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      plot_lvls    = lvls,
      panel_nrow   = 1,
      label_params = list(size = ttl_pt2),
      ...
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    
    scale_color_manual(
      values   = clrs,
      limits   = lvls,
      breaks   = lvls,
      labels   = n_labs,
      na.value = "grey80"
    ) +
    
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F"),
                         max_gns = 75, pred_clmn = "ml_pred_1_grp") {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", pred_clmn, gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, !!sym(pred_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(!!sym(pred_clmn) := fct_relevel(!!sym(pred_clmn), lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = pred_clmn, values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character() %>%
    head(max_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(!!sym(pred_clmn), name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, sort_gns = "up", type_clmn = chikv_type_clmn,
                               lvls = names(pred_clrs), n_gns = 100,
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", type_clmn, "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(!!sym(type_clmn) == "cLEC") %>%
    group_by(treatment, name, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  if (identical(sort_gns, "down")) gn_lvls <- rev(gn_lvls)
  
  gn_lvls <- head(gn_lvls, n_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, !!sym(type_clmn)) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(as.formula(str_c("~", type_clmn))) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.75
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL,
                               type_clmn = chikv_type_clmn, clrs = pred_clrs,
                               ...) {
  
  typ <- str_remove(dat_col, "_[a-zA-Z]+$")
  
  dat <- df_in %>%
    filter(tm == "24hpi", !!sym(type_clmn) == typ)
  
  if (nrow(dat) == 0) return(NULL)
  
  res <- dat %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, ...
    ) +
    facet_wrap(
      as.formula(str_c("~", type_clmn)),
      nrow = 1, scales = "free_y"
    ) +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = clrs) +
    labs(title = ttl) +
    base_theme +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results, do not include extension
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y) && (.y %in% so_in[[type_clmn]][[1]])) {
          bkgd <- subset(so_in, !!sym(type_clmn) == .y)
          
        } else {
          bkgd <- so_in
        }
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # * exclude specified genes
  # * the geneRatio column may not include some input genes if they are not
  #   included in the "GOALL" gene universe used by clusterProfiler
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # * this collapses terms that are very similar
  # * this is very slow
  if (simplify_terms && !is.list(go)) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}

.check_mtime <- function(upstream_file, new_file) {
  make_file <- !file.exists(new_file)
  
  if (!make_file) {
    up_mtime <- file.info(upstream_file)$mtime
    mtime    <- file.info(new_file)$mtime
    
    if (is.na(up_mtime)) cli_abort("{.file {upstream_file}} does not exist")
    
    make_file <- up_mtime > mtime
  }
  
  make_file
}
```

```{r "h2o Ag class", eval = TRAIN_MODELS}
# Set Ag-low/high classes for classifier
# * split for each cell type from each mouse
# * set subtype cutoff for all mice using d14 cutoff
# * for d14, Ag_score_3 and Ag_score_6 columns are identical to Ag_score
ag_clmns <- set_names(
  c("Ag_score", "Ag_score_3", "Ag_score_6"),
  c(rf_dat_clmn, "Ag_class_3wk", "Ag_class_6wk")
)

ag_clmns %>%
  iwalk(~ {
    ag_so <- lec_so %>%
      subset(mouse == rf_mouse) %>%
      cluster_signal(
        data_column  = .x,
        grp_column   = "subtype",
        clust_column = .y,
        method       = "km"
      )
    
    # The threshold will be the same for each column since this is set using
    # only the d14 mouse
    threshold <- ag_so@meta.data %>%
      filter(!!sym(.y) == "high") %>%
      group_by(subtype) %>%
      summarize(threshold = min(!!sym(.x)), .groups = "drop")
    
    threshold <- set_names(threshold$threshold, threshold$subtype)
    
    lec_so <<- lec_so %>%
      mutate_meta(
        mutate,
        !!sym(.y) := ifelse(
          !!sym(.x) >= threshold[as.character(subtype)],
          "high", "low"
        )
      )
  })

# Identify double-positive cells for the 6wk-3wk mouse
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    Ag_class_dual = case_when(
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" & Ag_class_6wk == "high") ~ "double-high",
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" | Ag_class_6wk == "high") ~ "single-high",
      mouse == "6wk"     & Ag_class_6wk == "high"                            ~ "6wk-high",
      mouse == "3wk"     & Ag_class_3wk == "high"                            ~ "3wk-high",
      TRUE                                                                   ~ "low"
    )
  )

# Save LEC object with Ag classifications
lec_so %>%
  qsave(here(params$so_dir, "lec_so.qs"))
```

```{r "h2o data splits", eval = TRAIN_MODELS}
# Split cells into train, validate, test
# * 30% train, 20% validate, 50% test/analysis
# * caret::createDataPartition() will maintain the class ratio for splits
data_splits <- list(
  train = 0.5,
  valid = 0.2,
  test  = 0.3
)

p_train_valid <- data_splits$train + data_splits$valid

data_splits <- rf_typs %>%
  set_names() %>%
  map(~ {
    dat <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, subtype == .x)
      
    cells    <- rownames(dat)
    outcomes <- pull(dat, rf_dat_clmn)
    
    set.seed(42)
    
    train_idx <- outcomes %>%
      createDataPartition(p = p_train_valid) %>%
      unlist(use.names = FALSE)
    
    valid_idx <- outcomes[train_idx] %>%
      createDataPartition(p = data_splits$valid / p_train_valid) %>%
      unlist(use.names = FALSE)
      
    splits <- list(
      train = cells[train_idx][-valid_idx],
      valid = cells[train_idx][valid_idx]
    )
    
    splits$test <- cells[!cells %in% unlist(splits)]
    
    splits
  })

TRAINING_CELLS <- data_splits %>%
  map(~ .x$train) %>%
  unlist(use.names = FALSE)

VALID_CELLS <- data_splits %>%
  map(~ .x$valid) %>%
  unlist(use.names = FALSE)

testing_cells <- data_splits %>%
  map(~ .x$test) %>%
  unlist(use.names = FALSE)
```

```{r "h2o feature selection", eval = TRAIN_MODELS}
# Identify top features to use for model training
# * select top genes using ONLY training data to prevent data leakage

# Identify Ag markers for all LECs from training data
fc <- 0

deg_so <- lec_so %>%
  subset(cells = TRAINING_CELLS)

degs_1 <- deg_so %>%
  wilcoxauc(group_by = rf_dat_clmn) %>%
  mutate(subtype = "all") %>%
  arrange(padj)

# Identify Ag markers for each subtype separately
degs_2 <- deg_so %>%
  SplitObject("subtype") %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y) %>%
      arrange(padj)
  })

# Filter based on differential expression
# * exclude ribosomal protein genes
# * use less stringent filtering to include more genes for training
# * exclude genes that are lowly expressed <20% of cells
exclude_feats <- c("Malat1", "Xist")

degs <- bind_rows(degs_1, degs_2) %>%
  filter(
    pval  < 0.05,
    logFC > fc,
    (pct_in > 20 | pct_out > 20),
    !grepl("^(mt-|R[pls])", feature),
    !feature %in% exclude_feats
  ) %>%
  arrange(pval)

# Remove highly correlated genes
ML_FEATS <- unique(degs$feature)

feat_dat <- lec_so %>%
  subset(mouse == rf_mouse, cells = TRAINING_CELLS) %>%
  FetchData(ML_FEATS)

cor_mat <- h2o.cor(as.h2o(feat_dat))

cor_feats <- caret::findCorrelation(cor_mat, cutoff = 0.75)
cor_feats <- colnames(cor_mat)[cor_feats]

ML_FEATS <- ML_FEATS[!ML_FEATS %in% cor_feats]

degs <- degs %>%
  filter(feature %in% ML_FEATS)

# Write tables
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_features.tsv.gz"))
```

```{r "h2o DEGs", eval = TRAIN_MODELS}
# Identify DEGs using all cells
# * these results will be used to classify genes into final Ag-low/high gene
#   modules
# * it is okay to use all cells since these results are not used for feature
#   selection and are just used to classify final features

# Identify Ag markers for all LECs from training data
fc <- 0

deg_so <- lec_so %>%
  subset(subtype %in% rf_typs & mouse == rf_mouse)

degs_1 <- deg_so %>%
  wilcoxauc(group_by = rf_dat_clmn) %>%
  mutate(subtype = "all") %>%
  arrange(padj)

# Identify Ag markers for each subtype separately
degs_2 <- deg_so %>%
  SplitObject("subtype") %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y) %>%
      arrange(padj)
  })

# Filter for genes used for training
degs <- bind_rows(degs_1, degs_2) %>%
  filter(
    feature %in% ML_FEATS,
    logFC > fc
  ) %>%
  arrange(pval)

# Write tables
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "h2o train models", eval = TRAIN_MODELS}
# Train models
mls <- rf_typs %>%
  set_names() %>%
  map_dfr(~ {
    ml_dat <- lec_so %>%
      subset(subtype == .x & mouse == rf_mouse) %>%
      .prepare_ml_data(feats = ML_FEATS)
    
    # Create h2o frames for training/validating
    cells <- data_splits[[.x]]
    
    ml_dat <- cells %>%
      map(~ {
        ml_dat %>%
          filter(.cell_id %in% .x) %>%
          select(-.cell_id) %>%
          as.h2o()
      })
    
    # Train models
    # * 10-fold cross-validation
    ml <- h2o.automl(
      y                 = rf_dat_clmn,
      training_frame    = ml_dat$train,
      leaderboard_frame = ml_dat$valid,
      # exclude_algos     = "DeepLearning",
      nfolds            = 10,
      max_models        = 50,
      seed              = 42,
      sort_metric       = "AUCPR",
      balance_classes   = TRUE
    )
    
    # Test top model
    mod <- ml@leader

    # Format final output
    res <- tibble(
      subtype    = .x,
      leader_id  = mod@model_id,
      model      = list(ml),
      train_data = list(cells$train),
      valid_data = list(cells$valid),
      test_data  = list(cells$test)
    )
    
    res
  })
```

```{r "h2o final test", eval = TRAIN_MODELS}
BEST_MLS <- mls %>%
  pmap_dfr(~ {
    args <- list(...)
    
    ml_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      .prepare_ml_data(feats = ML_FEATS)
    
    # Create h2o frames for training/validating
    cells <- list(
      train = args$train_data,
      valid = args$valid_data,
      test  = args$test_data
    )
    
    ml_dat <- cells %>%
      map(~ as.h2o(ml_dat[.x, ]))
    
    # Test best model
    # * find the threshold that maximizes F1-score
    top_mls <- args$model %>%
      .select_best_models(
        model_path = here(params$mod_dir, args$subtype),
        n    = 2,
        load = FALSE
      )
    
    res <- top_mls %>%
      map_dfr(~ {
        .x %>%
          .assess_ml(
            valid_data = ml_dat$valid,
            test_data  = ml_dat$test
          )
      }) %>%
      mutate(
        subtype    = args$subtype,
        train_data = list(args$train_data),
        valid_data = list(args$valid_data),
        test_data  = list(args$test_data)
      ) %>%
      mutate(
        training_rank = row_number(),
        .after = model_id
      )
    
    res
  })
```

```{r "h2o save models", eval = TRAIN_MODELS}
# Save models
# * save all models
# * save testing stats
mls %>%
  pull(model, subtype) %>%
  iwalk(~ {
    pth <- path.expand(here(params$mod_dir, .y))
    
    .x@leaderboard["model_id"] %>%
      as.vector() %>%
      walk(~ {
        .x %>%
          h2o.getModel() %>%
          h2o.saveModel(pth)
      })
  })

mls %>%
  qsave(here(params$mod_dir, "ag-high_all_models.qs"))

BEST_MLS %>%
  qsave(here(params$mod_dir, "ag-high_best_models.qs"))
```

```{r "h2o top features", eval = TRAIN_MODELS}
# Filter for top features
# * include features based on cumulative feature importance
# * keep top features that account for 90% of overall importance
# * do not filter features if top features have already been selected by model
MODULE_FEATS <- BEST_MLS %>%
  split(.$training_rank) %>%
  map(~ {
    .x %>%
      pull(model, subtype) %>%
      imap(~ {
        ml <- .x
        
        if (grepl("^StackedEnsemble", .x@model_id)) {
          ml <- .x@model$metalearner_model %>%
            h2o.varimp() %>%
            as_tibble() %>%
            head(1) %>%
            pull(variable) %>%
            h2o.getModel()
        }
        
        imprts <- ml@model$variable_importances %>%
          as_tibble()
        
        if (nrow(imprts) == length(ML_FEATS)) {
          imprts <- imprts %>%
            filter(cumsum(percentage) <= 0.9)
        }
        
        imprts$variable
      })
  })

# Assign Ag-low/high class
# * assign genes as Ag-low/high based on which group they are more highly
#   expressed in for the subtype used for training
MODULE_FEATS <- MODULE_FEATS %>%
  map(~ {
    .x %>%
      imap(~ {
        fts <- .x
        typ <- .y
        
        res <- degs %>%
          filter(
            subtype %in% c(typ, "all"),
            feature %in% fts,
            padj < 0.05
          )
        
        res %>%
          split(.$group) %>%
          map(~ {
            gns <- unique(pull(.x, feature))
            
            fts[fts %in% gns]
          })
      })
  })

# Save top features
MODULE_FEATS %>%
  qsave(here(params$mod_dir, "ag-high_module_features.qs"))
```

```{r "h2o predict Ag class", eval = TRAIN_MODELS}
# Predict Ag class
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    training_data = .cell_id %in% c(TRAINING_CELLS, VALID_CELLS)
  )
 
ML_PREDS <- BEST_MLS %>%
  split(.$training_rank) %>%
  map(~ {
    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        
        cells <- lec_so@meta.data %>%
          filter(!training_data, subtype == args$subtype) %>%
          rownames()
        
        dat <- lec_so %>%
          subset(cells = cells) %>%
          .prepare_ml_data(feats = ML_FEATS)
        
        pred <- args$predict_fn(as.h2o(dat)) %>%
          pull(adj_pred) %>%
          factor(levels = ag_lvls)
        
        res <- dat %>%
          select(!!sym(rf_dat_clmn)) %>%
          mutate(pred = pred)
        
        res
      })
  })

# Write table with predictions
ML_PREDS %>%
  qsave(here(params$mod_dir, "ag-high_preds.qs"))
```

```{r "h2o load models"}
# Load models
# mls <- qread(here(params$mod_dir, "ag-high_all_models.qs"))
BEST_MLS <- qread(here(params$mod_dir, "ag-high_best_models.qs"))

BEST_MLS$model <- BEST_MLS %>%
  pull(model_id, subtype) %>%
  imap(~ {
    here(params$mod_dir, .y, .x) %>%
      path.expand() %>%
      h2o.loadModel()
  })

TRAINING_CELLS <- unlist(BEST_MLS$train_data, use.names = FALSE)
VALID_CELLS    <- unlist(BEST_MLS$valid_data, use.names = FALSE)
TEST_CELLS     <- unlist(BEST_MLS$test_data, use.names = FALSE)

# Differentially expressed genes
degs <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

# RF features
ML_FEATS <- read_tsv(here(params$mod_dir, "ag-high_features.tsv.gz"))
ML_FEATS <- unique(ML_FEATS$feature)

MODULE_FEATS <- qread(here(params$mod_dir, "ag-high_module_features.qs"))

# Predictions
ML_PREDS <- qread(here(params$mod_dir, "ag-high_preds.qs"))
```
