
```{r "h2o setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# Colors
pred_clrs <- c(
  `Ag-low`       = "#6A51A3",
  `Ag-competent` = "#E69F00",
  `Ag-high`      = "#D7301F"
)

# RF parameters
rf_dat_clmn  <- "Ag_class_ml"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"
ml_tm        <- str_remove(rf_mouse, "^d")
rf_typs      <- c("cLEC", "fLEC", "Collecting")

ag_lvls <- c("high", "low")

# Check for RF predictions
TRAIN_MODELS <- !file.exists(here(params$mod_dir, "ag-high_preds.qs"))

# Start h2o session
library(h2o)
library(parallel)

ncpus <- detectCores(logical = TRUE)

invisible(h2o.init(nthreads = ncpus - 2))
```

```{r "h2o main functions"}
# Filter RF data to include correct cell types, timepoints, and to remove cells
# that were used to train models 
.filter_rf_data <- function(df, filt, timepoints = rf_tms, cell_types = rf_typs) {
  df %>%
    filter(
      tm %in% timepoints,
      subtype %in% cell_types,
      !training_data,
      {{filt}}
    )
}

.subset_rf_data <- function(so, filt, timepoints = rf_tms, cell_types = rf_typs) {
  cells <- so@meta.data %>%
    .filter_rf_data({{filt}}, timepoints, cell_types) %>%
    rownames()
  
  so %>%
    subset(cells = cells)
}

.prepare_ml_data <- function(obj, feats, class_clmn = rf_dat_clmn, scale = TRUE,
                             lvls = rev(ag_lvls), missing_value = NA) {
  # Identify missing features
  feats <- unique(feats)
  
  missing_feats <- feats[!feats %in% rownames(obj)]
  
  # Pull features
  dat <- obj %>%
    FetchData(unique(c(class_clmn, feats)))
  
  if (!is.null(class_clmn) && !is.null(lvls)) {
    dat <- dat %>%
      mutate(!!sym(class_clmn) := factor(!!sym(class_clmn), lvls))
  }
  
  dat[, missing_feats] <- as.numeric(missing_value)
  
  dat <- dat %>%  
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(feats))
  
  # Per-feature scaling
  if (scale) {
    dat <- dat %>%
      group_by(name) %>%
      mutate(value = as.numeric(scale(value))) %>%
      ungroup()
  }
  
  # Format final data.frame
  dat <- dat %>%
    pivot_wider() %>%
    column_to_rownames(".cell_id")
  
  dat
}

.predict_ml <- function(dat, predict_fn, features = ML_FEATS,
                        lvls = ag_lvls, class_clmn = rf_dat_clmn) {
  dat <- dat %>%
    .prepare_ml_data(
      feats      = features,
      class_clmn = class_clmn
    )
  
  pred <- predict_fn(as.h2o(dat)) %>%
    pull(adj_pred) %>%
    factor(lvls)
  
  res <- dat %>%
    select(any_of(class_clmn)) %>%
    mutate(pred = pred)
  
  res
}

#' Train models using h2o.automl()
#' 
#' @param ml_dat Named list containing H2OFrames for training ("train") and
#' validating ("valid") models
#' @param class_clmn Column in data containing binary classes to use for
#' classification
#' @param ml_dir Directory to use for saving models
.train_mls <- function(ml_dat, class_clmn = rf_dat_clmn, ml_dir = NULL, ...) {
  
  args <- list(
    y                  = class_clmn,
    training_frame     = ml_dat$train,
    leaderboard_frame  = ml_dat$valid,
    ...
  )
  
  args$nfolds          <- args$nfolds          %||% 10
  args$max_models      <- args$max_models      %||% 50
  args$seed            <- args$seed            %||% 42
  args$sort_metric     <- args$sort_metric     %||% "logloss"
  args$stopping_metric <- args$stopping_metric %||% "logloss"
  args$balance_classes <- args$balance_classes %||% TRUE
  args$keep_cross_validation_predictions <- args$keep_cross_validation_predictions %||% TRUE
  
  # Train models
  # * 10-fold cross-validation
  # * sort models based on logloss
  # * balance classes
  ml <- purrr::lift_dl(h2o.automl)(args)
  
  # Save models
  lb <- ml@leaderboard
  
  if (!is.null(ml_dir)) {
    pth <- path.expand(ml_dir)
    
    lb["model_id"] %>%
      as.vector() %>%
      walk(~ {
        .x %>%
          h2o.getModel() %>%
          h2o.saveModel(pth)
      })
  }
  
  # Calculate metrics for leaderboard
  # * return metrics for training and validation data
  # * use validation for setting classification cutoff
  lb_df <- lb %>%
    as_tibble() %>%
    select(-any_of("logloss"))  # this is calculated by .assess_ml()
  
  lb <- lb["model_id"] %>%
    as.vector() %>%
    map_dfr(~ {
      m <- .load_ml(ml_dir, .x)
      
      c("train", "valid", "test") %>%
        keep(~ .x %in% names(ml_dat)) %>%
        map_dfr(~ {
          m %>%
            .assess_ml(
              valid_data = ml_dat$valid %||% ml_dat$train,  # used to set classification cutoff
              test_data  = ml_dat[[.x]],                    # used to calculate accuracy metrics
              class_clmn = class_clmn
            ) %>%
            mutate(data = .x)
        })
    }) %>%
    left_join(lb_df, by = "model_id")
    
  # Format final output
  res <- list(
    model       = list(ml),
    leaderboard = lb
  )
  
  res
}

# Performs final performance assessment using test data
# * also identifies optimal classification cutoff based on validation data
# * returns data frame with final model and metrics
# * class levels and positive class are set during model training,
#   the first class is the negative class
# * Ag-high is set as the negative class for model training and when selecting
#   the classfication threshold
# * the returned F1 score uses Ag-high as the positive class
.assess_ml <- function(ml, metric = "f1", valid_data, test_data,
                       class_clmn = rf_dat_clmn) {
  
  # Identify optimal classification threshold using validation data
  perf <- ml %>%
    h2o.performance(newdata = valid_data) %>%
    h2o.metric() %>%
    as_tibble() %>%
    arrange(desc(!!sym(metric)), desc(specificity))
  
  threshold <- perf %>%
    head(1) %>%
    pull(threshold)
  
  # Perform final test using optimized threshold
  # * the last output column from h2o.predict is the positive class
  # * but confusionMatrix() uses the first level as the positive class
  predict_fn <- function(dat) {
    p <- h2o.predict(ml, dat) %>%
      as.data.frame()
    
    lvls <- colnames(p)[-1]
    pos  <- lvls[2]
    neg  <- lvls[1]
    
    p %>%
      mutate(
        adj_pred = if_else(!!sym(pos) > threshold, pos, neg),
        adj_pred = factor(adj_pred, lvls)
      )
  }
  
  pred <- test_data %>%
    predict_fn() %>%
    pull(adj_pred)
  
  class_lvls <- levels(pred)
  
  final_stats <- pred %>%
    confusionMatrix(
      reference = factor(as.vector(test_data[[class_clmn]]), class_lvls),
      positive  = class_lvls[1]
    )
  
  # Calculate logloss
  ll <- ml %>%
    h2o.performance(newdata = test_data)
  
  ll <- ll@metrics$logloss
  
  # Function to predict using optimized threshold
  # Format output tibble
  res <- final_stats$byClass %>%
    t() %>%
    as_tibble() %>%
    mutate(
      model_id   = ml@model_id,
      algorithm  = ml@algorithm,
      model      = list(ml),
      predict_fn = list(predict_fn),
      .before    = 1
    ) %>%
    mutate(
      logloss = ll,
      F1_neg = 2 * (
        (`Neg Pred Value` * Specificity) /
          (`Neg Pred Value` + Specificity)
      )
    )

  res
}

# Pulls the top models from an H2OAutoML object
# * Uggghhh have to grab the top models from the printed output of the
#   leaderboard since the leaderboard h2o.frame was not saved to disk
.select_best_models <- function(lb, n = 2, model_path, metric = "logloss",
                                desc = FALSE) {
  
  sort_fn <- function(df) arrange(df, !!sym(metric))
  
  if (desc) sort_fn <- function(df) arrange(df, desc(!!sym(metric)))
  
  top_mls <- lb %>%
    as_tibble() %>%
    sort_fn() %>%
    pull(model_id) %>%
    head(n)
  
  res <- top_mls %>%
    set_names() %>%
    map(~ .load_ml(model_path, .x))
  
  res
}

.load_ml <- function(ml_dir, ml_id) {
  file.path(ml_dir, ml_id) %>%
    path.expand() %>%
    h2o.loadModel()
}
```

```{r "h2o other functions"}
create_gn_plots <- function(so_in, p_data,
                            x = "ml_pred_1_grp", plt_clrs, x_lvls,
                            n_gns = 10, top_gns = NULL,
                            p_test = wilcox.test, draw_line = TRUE, pt_size = 1,
                            sort = TRUE) {
  
  # Set genes to plot
  gns <- p_data %>%
    distinct(gene, class) %>%
    mutate(top = gene %in% top_gns) %>%
    group_by(class) %>%
    mutate(rank = row_number()) %>%
    arrange(desc(top), rank) %>%
    slice(1:n_gns) %>%
    ungroup() %>%
    arrange(rank)
  
  gns <- set_names(gns$class, gns$gene)
  
  p_data <- p_data %>%
    filter(gene %in% names(gns))
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  cell_type <- unique(so_in$subtype)
  
  if (length(cell_type) > 1) cli_abort("Object contains more than one cell type")
  
  plt_dat <- so_in %>%
    FetchData(c("mouse", "tm", "subtype", x, names(gns))) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(names(gns)), names_to = "gene") %>%
    left_join(p_data, by = c("tm", x, "subtype", "gene")) %>%
  
    mutate(
      gene      = fct_relevel(gene, names(gns)),
      tm        = str_c("day ", tm),
      x         = str_c(!!sym(x), "-", tm),
      !!sym(x) := fct_relevel(!!sym(x), x_lvls),
    ) %>%
    arrange(!!sym(x)) %>%
    mutate(x = fct_inorder(x))
  
  plt_dat <- plt_dat %>%
    group_by(gene, mouse, tm, subtype, !!sym(x), x) %>%
    summarize(
      n       = n_distinct(.cell_id),
      med     = median(value),
      q1      = quantile(value, 0.25),
      q3      = quantile(value, 0.75),
      p_adj   = unique(p_adj),
      .groups = "drop"
    ) %>%
    group_by(gene) %>%
    mutate(range = max(q3) - min(q1)) %>%
    ungroup() %>%
    mutate(
      class = gns[gene],
      p_y = q3 + (range * 0.2)
    )
  
  # Format x-axis labels
  x_lab <- plt_dat %>%
    mutate(
      xlab = scales::label_comma()(n),
      xlab = str_c(!!sym(x), " (n = ", xlab, ")")
    ) %>%
    distinct(xlab, x)
  
  x_lab <- set_names(x_lab$xlab, x_lab$x)
  
  # Create boxplots
  plt_dat <- split(plt_dat, plt_dat$class)
  
  res <- plt_dat %>%
    imap(~ {
      cls <- .y
      
      plt <- .x %>%
        ggplot(aes(x, med, color = !!sym(x))) +
        geom_segment(
          aes(x = x, xend = x, y = q1, yend = q3),
          linewidth = pt_size, color = ln_col
        ) +
        geom_point(aes(size = !!sym(x)))
      
      if (draw_line) {
        plt <- plt +
          geom_smooth(
            aes(x = as.numeric(as.factor(!!sym(x)))),
            method = "lm", linewidth = 0.25, linetype = 2,
            se = FALSE, formula = y ~ x
          )
      }
      
      plt <- plt +
        geom_point(
          aes(y = p_y),
          data = ~ filter(.x, class == cls, p_adj < 0.05),
          color = "black", shape = 6, stroke = 1, size = pt_size
        ) +
        facet_grid(gene ~ tm, scales = "free", switch = "y") +
        scale_size_manual(values = c(pt_size, pt_size * 1.25, pt_size * 1.25)) +
        scale_color_manual(values = plt_clrs) +
        scale_y_continuous(
          breaks = ~ c(ceiling(min(.x)), floor(max(.x))),
          sec.axis = dup_axis(name = str_c(cell_type, " Ag-", .y))
        ) +
        scale_x_discrete(labels = x_lab) +
        base_theme +
        theme(
          aspect.ratio       = 1,
          plot.margin        = margin(15, 15, 15, 15),
          legend.position    = "none",
          panel.border       = element_rect(color = "grey75"),
          strip.placement    = "outside",
          axis.ticks.y.right = element_blank(),
          axis.title         = element_blank(),
          axis.title.y.right = element_text(angle = 270, size = ttl_pt2 * 1.2),
          axis.text.y.right  = element_blank(),
          axis.text.x        = element_text(angle = 45, hjust = 1)
        )
      
      # Adjust theme
      if (.y == dplyr::first(names(plt_dat))) {
        plt <- plt +
          theme(
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank()
          )
        
      } else {
        plt <- plt +
          theme(
            strip.text.x = element_blank(),
            plot.margin  = margin(20, 15, 15, 15)
          )
      }
      
      plt
    })
  
  res
}

create_sig_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            pt_size = 0.15, pt_stroke = 0.6,
                            scale_limits = NULL, outline = TRUE) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      outline      = outline,
      plot_colors  = clrs,
      panel_nrow   = 1,
      size         = pt_size,
      stroke       = pt_stroke,
      label_params = list(size = ttl_pt2)
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = 18),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  if (!is.null(scale_limits)) {
    res <- res +
      scale_fill_gradientn(colours = clrs, limits = scale_limits)
  }
  
  res
}

create_grp_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            lvls = c("Ag-competent", "Ag-low", "Ag-high", "other"),
                            ...) {

  # Format n labels  
  n_labs <- so_in %>%
    filter(!is.na(!!sym(dat_col))) %>%
    group_by(!!sym(dat_col)) %>%
    summarize(n = n()) %>%
    mutate(
      n_lab = str_c(!!sym(dat_col), "\nn = ", n)
    )
  
  n_labs <- set_names(n_labs$n_lab, n_labs[[dat_col]])
  
  lvls <- lvls[lvls %in% names(n_labs)]
  
  # Create UMAPs
  # * add colors separately since ggplot2 3.5.1 automatically includes `NA` in
  #   plot legend
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      plot_lvls    = lvls,
      panel_nrow   = 1,
      label_params = list(size = ttl_pt2),
      ...
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    
    scale_color_manual(
      values   = clrs,
      limits   = lvls,
      breaks   = lvls,
      labels   = n_labs,
      na.value = "grey80"
    ) +
    
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F"),
                         max_gns = 75, pred_clmn = "ml_pred_1_grp") {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", pred_clmn, gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, !!sym(pred_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(!!sym(pred_clmn) := fct_relevel(!!sym(pred_clmn), lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = pred_clmn, values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character() %>%
    head(max_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(!!sym(pred_clmn), name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, sort_gns = "up", type_clmn = chikv_type_clmn,
                               lvls = names(pred_clrs), n_gns = 100,
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", type_clmn, "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(!!sym(type_clmn) == "cLEC") %>%
    group_by(treatment, name, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  if (identical(sort_gns, "down")) gn_lvls <- rev(gn_lvls)
  
  gn_lvls <- head(gn_lvls, n_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, !!sym(type_clmn)) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(as.formula(str_c("~", type_clmn))) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.75
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL,
                               type_clmn = chikv_type_clmn, clrs = pred_clrs,
                               ...) {
  
  typ <- str_remove(dat_col, "_[a-zA-Z]+$")
  
  dat <- df_in %>%
    filter(tm == "24hpi", !!sym(type_clmn) == typ)
  
  if (nrow(dat) == 0) return(NULL)
  
  res <- dat %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, ...
    ) +
    facet_wrap(
      as.formula(str_c("~", type_clmn)),
      nrow = 1, scales = "free_y"
    ) +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = clrs) +
    labs(title = ttl) +
    base_theme +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results, do not include extension
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y) && (.y %in% so_in[[type_clmn]][[1]])) {
          bkgd <- subset(so_in, !!sym(type_clmn) == .y)
          
        } else {
          bkgd <- so_in
        }
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # * exclude specified genes
  # * the geneRatio column may not include some input genes if they are not
  #   included in the "GOALL" gene universe used by clusterProfiler
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # * this collapses terms that are very similar
  # * this is very slow
  if (simplify_terms && !is.list(go)) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}

.check_mtime <- function(upstream_file, new_file) {
  make_file <- !file.exists(new_file)
  
  if (!make_file) {
    up_mtime <- file.info(upstream_file)$mtime
    mtime    <- file.info(new_file)$mtime
    
    if (is.na(up_mtime)) cli_abort("{.file {upstream_file}} does not exist")
    
    make_file <- up_mtime > mtime
  }
  
  make_file
}
```

```{r "h2o Ag class", eval = TRAIN_MODELS}
# Set Ag-low/high classes for classifier
# * split for each cell type from each mouse
# * set subtype cutoff for all mice using d14 cutoff
# * for d14, Ag_score_3 and Ag_score_6 columns are identical to Ag_score
ag_clmns <- set_names(
  c("Ag_score", "Ag_score_3", "Ag_score_6"),
  c(rf_dat_clmn, "Ag_class_3wk", "Ag_class_6wk")
)

ag_clmns %>%
  iwalk(~ {
    ag_so <- lec_so %>%
      subset(mouse == rf_mouse) %>%
      cluster_signal(
        data_column  = .x,
        grp_column   = "subtype",
        clust_column = .y,
        method       = "km"
      )
    
    # The threshold will be the same for each column since this is set using
    # only the d14 mouse
    threshold <- ag_so@meta.data %>%
      filter(!!sym(.y) == "high") %>%
      group_by(subtype) %>%
      summarize(threshold = min(!!sym(.x)), .groups = "drop")
    
    threshold <- set_names(threshold$threshold, threshold$subtype)
    
    lec_so <<- lec_so %>%
      mutate_meta(
        mutate,
        !!sym(.y) := ifelse(
          !!sym(.x) >= threshold[as.character(subtype)],
          "high", "low"
        )
      )
  })

# Identify double-positive cells for the 6wk-3wk mouse
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    Ag_class_dual = case_when(
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" & Ag_class_6wk == "high") ~ "double-high",
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" | Ag_class_6wk == "high") ~ "single-high",
      mouse == "6wk"     & Ag_class_6wk == "high"                            ~ "6wk-high",
      mouse == "3wk"     & Ag_class_3wk == "high"                            ~ "3wk-high",
      TRUE                                                                   ~ "low"
    )
  )

# Save LEC object with Ag classifications
lec_so %>%
  qsave(here(params$so_dir, "lec_so.qs"))
```

```{r "h2o data splits", eval = TRAIN_MODELS}
# Split cells into train, validate, test
# * caret::createDataPartition() will maintain the class ratio for splits
data_splits <- list(
  train = 0.5,
  valid = 0.2,
  test  = 0.3
)

prop_train_valid <- data_splits$train + data_splits$valid

data_splits <- rf_typs %>%
  set_names() %>%
  map(~ {
    dat <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, subtype == .x)
      
    cells    <- rownames(dat)
    outcomes <- pull(dat, rf_dat_clmn)
    
    set.seed(42)
    
    train_idx <- outcomes %>%
      createDataPartition(p = prop_train_valid) %>%
      unlist(use.names = FALSE)
    
    valid_idx <- outcomes[train_idx] %>%
      createDataPartition(p = data_splits$valid / prop_train_valid) %>%
      unlist(use.names = FALSE)
    
    # Set training cells
    train_cells <- cells[train_idx]
    
    if (!is_empty(valid_idx)) train_cells <- train_cells[-valid_idx]
    
    # Create split
    splits <- list(train = train_cells)
    
    if (!is_empty(valid_idx)) splits$valid <- cells[train_idx][valid_idx]
    
    splits$test <- cells[!cells %in% unlist(splits)]
    
    splits
  })

# Include cells from the 21 and 42 day timepoints for feature selection
data_splits %>%
  iwalk(~ {
    dat <- lec_so@meta.data %>%
      filter(tm %in% c(21, 42), subtype == .y)

    cells <- dat %>%
      split(.$tm) %>%
      map(~ {
        cells    <- rownames(.x)
        outcomes <- pull(.x, rf_dat_clmn)

        set.seed(42)

        feat_idx <- outcomes %>%
          createDataPartition(p = 0.1) %>%
          unlist(use.names = FALSE)

        cells[feat_idx]
      }) %>%
      unlist(use.names = FALSE)
    
    data_splits[[.y]]$feature <<- cells
  })

# Save cell IDs
TRAINING_CELLS <- c("train", "valid", "feature") %>%
  map(~ map(data_splits, pluck, .x)) %>%
  unlist(use.names = FALSE)

data_splits %>%
  qsave(here(params$mod_dir, "data_splits.qs"))
```

```{r "h2o fLEC data splits", eval = TRAIN_MODELS}
# Split cells into train, validate, test
# * caret::createDataPartition() will maintain the class ratio for splits
new_splits <- list(
  train = 0.7,
  valid = 0.15,
  test  = 0.15
)

prop_train_valid <- new_splits$train + new_splits$valid

new_splits <- set_names("fLEC") %>%
  map(~ {
    dat <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, subtype == .x)
      
    cells    <- rownames(dat)
    outcomes <- pull(dat, rf_dat_clmn)
    
    set.seed(42)
    
    train_idx <- outcomes %>%
      createDataPartition(p = prop_train_valid) %>%
      unlist(use.names = FALSE)
    
    valid_idx <- outcomes[train_idx] %>%
      createDataPartition(p = new_splits$valid / prop_train_valid) %>%
      unlist(use.names = FALSE)
    
    # Set training cells
    train_cells <- cells[train_idx]
    
    if (!is_empty(valid_idx)) train_cells <- train_cells[-valid_idx]
    
    # Create split
    splits <- list(train = train_cells)
    
    if (!is_empty(valid_idx)) splits$valid <- cells[train_idx][valid_idx]
    
    splits$test <- cells[!cells %in% unlist(splits)]
    
    splits
  })

# Include cells from the 21 and 42 day timepoints for feature selection
new_splits %>%
  iwalk(~ {
    dat <- lec_so@meta.data %>%
      filter(tm %in% c(21, 42), subtype == .y)

    cells <- dat %>%
      split(.$tm) %>%
      map(~ {
        cells    <- rownames(.x)
        outcomes <- pull(.x, rf_dat_clmn)

        set.seed(42)

        feat_idx <- outcomes %>%
          createDataPartition(p = 0.1) %>%
          unlist(use.names = FALSE)

        cells[feat_idx]
      }) %>%
      unlist(use.names = FALSE)

    new_splits[[.y]]$feature <<- cells
  })

# Update data_splits
new_splits %>%
  iwalk(~ {
    data_splits[[.y]] <<- .x
  })

# Save cell IDs
TRAINING_CELLS <- c("train", "valid", "feature") %>%
  map(~ map(data_splits, pluck, .x)) %>%
  unlist(use.names = FALSE)

data_splits %>%
  qsave(here(params$mod_dir, "data_splits.qs"))
```

```{r "h2o feature selection 1", eval = TRAIN_MODELS}
# Identify top features to use for model training

# Filter for cells to use for feature selection
deg_so <- lec_so %>%
  subset(cells = TRAINING_CELLS)

# Identify Ag markers for each subtype separately
.identify_degs <- function(obj, var = NULL, group_clmn = rf_dat_clmn) {
  
  multi_var <- length(var) > 1
  
  if (multi_var) {
    obj <- obj %>%
      mutate_meta(~ {
        .x %>%
          rowwise() %>%
          mutate(var = str_c(!!!syms(var), sep = "-")) %>%
          ungroup()
      })
    
    orig_clmns <- var
    var <- "var"
  }
  
  res <- list(obj)
  
  if (!is.null(var)) {
    res <- obj %>%
      SplitObject(var)
  }
  
  res <- res %>%
    imap_dfr(~ {
      res <- .x %>%
        wilcoxauc(group_by = group_clmn)
      
      if (nrow(res) == 0) return(NULL)
      
      res %>%
        as_tibble() %>%
        filter(logFC > 0) %>%
        arrange(padj, pval, desc(logFC))
    }, .id = var)
  
  if (multi_var) {
    res <- res %>%
      separate_wider_delim(var, delim = "-", names = orig_clmns)
  }
  
  res
}

degs_1 <- deg_so %>%
  .identify_degs() %>%
  mutate(subtype = "all", tm = "all")

degs_2 <- deg_so %>%
  .identify_degs("subtype") %>%
  mutate(tm = "all")

degs_3 <- deg_so %>%
  .identify_degs("tm") %>%
  mutate(subtype = "all")

degs_4 <- deg_so %>%
  .identify_degs(c("subtype", "tm"))

# Filter based on differential expression
# * exclude ribosomal protein genes
# * use less stringent filtering to include more genes for training
# * exclude genes that are lowly expressed <20% of cells
exclude_feats <- c("Malat1", "Xist")

fc <- log(1)

degs <- bind_rows(degs_1, degs_2, degs_3, degs_4) %>%
  filter(
    logFC > fc,
    (pct_in > 20 | pct_out > 20),
    
    !grepl("^(mt-|R[pls])", feature),
    !feature %in% exclude_feats
  ) %>%
  arrange(pval)

# Save features
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "h2o feature selection 2", eval = TRAIN_MODELS}
# Save features
# * assign features to Ag-low/high modules
ml_degs <- rf_typs %>%
  map_dfr(~ {
    degs %>%
      filter(subtype %in% c(.x, "all")) %>%
      mutate(
        key = case_when(
          subtype == .x & as.character(tm) == ml_tm    ~ 1,
          subtype == .x                                ~ 2,
          subtype == "all" & as.character(tm) == ml_tm ~ 3,
          as.character(tm) == ml_tm                    ~ 4,
          TRUE                                         ~ 5
        )
      ) %>%
      group_by(feature) %>%
      filter(key == min(key)) %>%
      ungroup() %>%
      mutate(list = .x)
  })

# Select equal number of top genes from Ag-low/high groups for each subtype
ml_degs <- ml_degs %>%
  filter(tm != "all", subtype == list) %>%
  arrange(padj, pval, desc(logFC)) %>%
  group_by(list, tm, group) %>%
  slice(1:100) %>%
  ungroup()

ml_degs %>%
  write_tsv(here(params$mod_dir, "ag-high_features.tsv.gz"))

# All features
ml_feats <- ml_degs %>%
  split(.$list) %>%
  map(~ unique(.x$feature))

ML_FEATS <- unique(unlist(ml_feats))
```

```{r "h2o training data", eval = TRAIN_MODELS}
# Create data.frames
# * separate frame for each subtype and train/validate/test split
ml_data <- data_splits %>%
  map(~ .x[!names(.x) == "feature"]) %>%
  imap(~ {
    cells <- .x
    typ   <- .y
    
    fts <- ml_feats[[typ]]
    
    cells %>%
      map(~ {
        dat <- lec_so %>%
          subset(cells = .x) %>%
          subset(subtype == typ) %>%
          .prepare_ml_data(feats = fts) %>%
          as.h2o()
        
        # the first level should be the negative class
        # * want to train using Ag-low as the positive class since it is the
        #   minority class
        dat[[rf_dat_clmn]] <- dat[[rf_dat_clmn]] %>%
          h2o.setLevels(ag_lvls, in.place = TRUE)
        
        dat
      })
  })
```

```{r "h2o train models", eval = TRAIN_MODELS}
# Train models
# * set Ag-low as the positive class, since there are fewer Ag-low cells
# * scale expression separately for training/validation/testing data
# * train two separate batches, take the top model from each
lb <- c(42, 43) %>%
  map_dfr(~ {
    seed <- .x
    
    rf_typs %>%
      set_names() %>%
      map_dfr(~ {
        typ    <- .x
        cells  <- data_splits[[typ]]
        fts    <- ml_feats[[typ]]    
        ml_dat <- ml_data[[typ]]
        
        res <- ml_dat %>%
          .train_mls(
            class_clmn    = rf_dat_clmn,
            ml_dir        = here(params$mod_dir, typ),
            include_algos = c("GLM", "StackedEnsemble", "GBM"),
            # max_models      = 100,  # USED FOR FIRST PASS
            # balance_classes = FALSE,
            
            max_models    = 100,
            seed          = seed
          ) %>%
          .$leaderboard %>%
          mutate(
            features   = list(fts),
            train_data = list(cells$train),
            valid_data = list(cells$valid),
            test_data  = list(cells$test)
          ) %>%
          mutate(
            subtype = typ,
            seed    = seed,
            .before = 1
          )
        
        res
      })
  })

lb %>%
  qsave(here(params$mod_dir, "ag-high_all_models.qs"))

lb %>%
  select(-where(is.list)) %>%
  write_tsv(here(params$mod_dir, "ag-high_leaderboard.tsv.gz"))
```

```{r "h2o final test", eval = TRAIN_MODELS}
# Select best models
# * Use GLM and top GBM
BEST_MLS <- lb %>%
  filter(
    data == "valid",
    algorithm %in% c("glm", "gbm")
  ) %>%
  group_by(algorithm, subtype) %>%
  slice_max(F1, n = 10) %>%
  slice_max(Specificity, n = 1) %>%
  slice_min(logloss, n = 1, with_ties = FALSE) %>%

  group_by(subtype) %>%
  arrange(desc(F1), desc(Specificity), logloss) %>%
  mutate(training_rank = row_number()) %>%
  ungroup() %>%
  
  pmap_dfr(~ {
    args <- list(...)
    typ  <- args$subtype
    dat  <- ml_data[[typ]]
    
    ml <- .load_ml(
      here(params$mod_dir, typ),
      args$model_id
    )
      
    res <- ml %>%
      .assess_ml(
        valid_data = dat$valid,
        test_data  = dat$test
      ) %>%
      mutate(
        train_data = list(dat$train),
        valid_data = list(dat$valid),
        test_data  = list(dat$test)
      ) %>%
      mutate(
        subtype       = typ,
        seed          = args$seed,
        training_rank = args$training_rank,
        .before = 1
      )
    
    res
  })

BEST_MLS <- BEST_MLS %>%
  arrange(desc(Specificity)) %>%
  group_by(subtype) %>%
  mutate(model_label = row_number()) %>%
  ungroup()

# Save models
BEST_MLS %>%
  qsave(here(params$mod_dir, "ag-high_best_models.qs"))
```

```{r "h2o Ag module features", eval = TRAIN_MODELS}
# Filter for top features
# * include features based on cumulative feature importance
# * keep top features that account for 90% of overall importance
MODULE_FEATS <- BEST_MLS %>%
  split(.$model_label) %>%
  map(~ {
    .x %>%
      pull(model, subtype) %>%
      imap(~ {
        ml <- .x
        
        if (grepl("^StackedEnsemble", .x@model_id)) {
          ml <- .x@model$metalearner_model %>%
            h2o.varimp() %>%
            as_tibble() %>%
            head(1) %>%
            pull(variable) %>%
            h2o.getModel()
        }
        
        imprts <- ml@model$variable_importances %>%
          as_tibble()
        
        imprts <- imprts %>%
          filter(cumsum(percentage) <= 0.99)  # remove any features not used by
                                              # model
        imprts$variable
      })
  })

# Assign Ag-low/high class
# * assign genes as Ag-low/high based on which group they are more highly
#   expressed in for the subtype used for training
MODULE_FEATS <- MODULE_FEATS %>%
  map(~ {
    .x %>%
      imap(~ {
        fts <- .x
        typ <- .y
        
        res <- ml_degs %>%
          filter(list == typ, feature %in% fts) %>%
          group_by(feature) %>%
          filter(key == min(key)) %>%
          filter(n_distinct(group) == 1) %>%
          slice_max(logFC) %>%
          ungroup()
          
        res %>%
          split(.$group) %>%
          map(~ {
            gns <- unique(pull(.x, feature))
            
            fts[fts %in% gns]
          })
      })
  })

# Save top features
MODULE_FEATS %>%
  qsave(here(params$mod_dir, "ag-high_module_features.qs"))
```

```{r "h2o predict Ag class", eval = TRAIN_MODELS}
# Predict Ag class
# * THIS RETURNS WARNINGS
# * Test/Validation dataset is missing column 'Orai10': substituting in a column of NaN
# * suggests there are genes used for training that are not present in data
#   for predictions
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    training_data = .cell_id %in% TRAINING_CELLS
  )
 
ML_PREDS <- BEST_MLS %>%
  split(.$model_label) %>%
  map(~ {
    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        
        dat <- lec_so@meta.data %>%
          filter(!training_data, subtype == args$subtype) %>%
          split(.$mouse) %>%
          map(~ subset(lec_so, cells = rownames(.x)))
        
        res <- dat %>%
          map_dfr(
            .predict_ml,
            predict_fn = args$predict_fn,
          )
        
        res
      })
  })

# Write table with predictions
ML_PREDS %>%
  qsave(here(params$mod_dir, "ag-high_preds.qs"))
```

```{r "h2o load models"}
# Load models
# lb <- qread(here(params$mod_dir, "ag-high_all_models.qs"))
lb       <- read_tsv(here(params$mod_dir, "ag-high_leaderboard.tsv.gz"))
BEST_MLS <- qread(here(params$mod_dir, "ag-high_best_models.qs"))

BEST_MLS$model <- BEST_MLS %>%
  pull(model_id, subtype) %>%
  imap(~ {
    here(params$mod_dir, .y, .x) %>%
      path.expand() %>%
      h2o.loadModel()
  })

# Load data splits used for training models
data_splits <- qread(here(params$mod_dir, "data_splits.qs"))

TRAINING_CELLS <- c("train", "valid", "feature") %>%
  map(~ map(data_splits, pluck, .x)) %>%
  unlist(use.names = FALSE)

# Differentially expressed genes
ml_degs <- read_tsv(here(params$mod_dir, "ag-high_features.tsv.gz"))
degs    <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

ml_feats <- ml_degs %>%
  split(.$list) %>%
  map(~ unique(.x$feature))

# RF features
ML_FEATS <- read_tsv(here(params$mod_dir, "ag-high_features.tsv.gz"))
ML_FEATS <- unique(ML_FEATS$feature)

MODULE_FEATS <- qread(here(params$mod_dir, "ag-high_module_features.qs"))

# Predictions
ML_PREDS <- qread(here(params$mod_dir, "ag-high_preds.qs"))
```
