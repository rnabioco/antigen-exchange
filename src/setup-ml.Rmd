
```{r "RF setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# Theme elements
pred_clrs <- c(
  `Ag-low`       = "#6A51A3",
  `Ag-competent` = "#E69F00",
  `Ag-high`      = "#D7301F"
)

# RF parameters
rf_dat_clmn  <- "Ag_class_ml"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"

# Check for RF predictions
run_rf <- !file.exists(here(params$mod_dir, "ag-high_preds.tsv.gz"))
```

```{r "RF functions"}
# Function to predict
rf_predict <- function(mod, dat, data_clmn = NULL, return_stats = TRUE,
                       prob = FALSE) {
  
  prds <- mod %>%
    predict(dat, seed = 42) %>%
    ranger::predictions()
  
  if (prob) {
    classes <- colnames(prds)
    
    prds <- prds %>%
      as.data.frame() %>%
      mutate(pred = ifelse(!!sym(classes[1]) > 0.5, classes[1], classes[2])) %>%
      pull(pred)
  }
  
  res <- dat %>%
    as_tibble(rownames = ".cell_id") %>%
    mutate(pred = prds)
  
  if (is.null(data_clmn)) return(res)
  
  res <- res %>%
    mutate(!!sym(data_clmn) := fct_relevel(!!sym(data_clmn), levels(prds)))
  
  res <- res %>%
    dplyr::select(.cell_id, all_of(data_clmn), pred) %>%
    mutate(correct = pred == !!sym(data_clmn)) %>%
    group_by(pred) %>%
    mutate(frac_correct = sum(correct) / n()) %>%
    ungroup()
  
  if (!return_stats) return(column_to_rownames(res, ".cell_id"))
  
  # Calculate F1 score
  stats <- caret::confusionMatrix(
    data      = res$pred,
    reference = res[[data_clmn]],
    positive  = "high"
  )
  
  stats <- as_tibble(as.list(stats$byClass))
    
  stats
}

#' Generate RF models using given data and parameters
#' 
#' @param df_in data.frame containing features as columns and observations as
#' rows
#' @param data_clmn column in df_in containing response variable
#' @param param_lst list of RF parameters to expand and test
#' @param train_fn Function to use for training model
#' @param feat_p p-value cutoff for selecting best features
#' @param min_feats minimum number of features to allow after feature selection
#' @param min_cells minimum number of cells required for each group in data_clmn
#' @param scale_data Should independent variables be scaled
#' @param select_feats should features be filtered based on p-value
#' @param df_list list of data.frames containing data for each mouse to use for
#' comparing the fraction of predicted Ag-high cells. Want a model where the
#' fraction of predicted Ag-high cells is roughly the same for all samples.
#' @param frac_grp group in data_clmn that should be used for calculating and
#' comparing fractions using data in df_list
#' @param balance_groups downsample so groups have the same number of cells
#' @param degs data.frame of DEGs, used to determine which DEGs are markers
#' for each group
#' @param include_objects in output tibble include ranger object, top features,
#' and cell barcodes for training data
#' @param ... additional parameters to pass to ranger::ranger()
train_rf <- function(df_in, data_clmn, param_lst, train_fn = ranger,
                     feat_p = 0.05, min_feats = 20, min_cells = 30,
                     scale_data = FALSE, select_feats = TRUE, df_list = NULL,
                     frac_grp = "high", balance_groups = FALSE,
                     degs = NULL, include_objects = FALSE, ...) {
  
  # Format input data
  rf_dat <- df_in %>%
    dplyr::select(
      all_of(data_clmn),
      where(~ !all(.x == 0))
    ) %>%
    mutate(!!sym(data_clmn) := factor(!!sym(data_clmn))) %>%
    rename_with(~ str_replace_all(.x, "-", "_")) %>%
    rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
    rename_with(~ str_c("x", .x), matches("^[0-9]"))
  
  classes     <- as.character(unique(rf_dat[[data_clmn]]))
  class_sizes <- table(rf_dat[[rf_dat_clmn]])
  
  # Scale data
  if (scale_data) {
    rf_dat <- rf_dat %>%
      mutate(
        across(-all_of(data_clmn), ~ as.numeric(scale(.x)))
      )
  }
  
  # Adjust groups so they are balanced
  # split into train/test data
  if (balance_groups) {
    group_size  <- table(rf_dat[[data_clmn]])
    target_frac <- group_size[[frac_grp]] / sum(group_size)
    sample_size <- floor(min(group_size) / 2)
    
    if (sample_size < min_cells) {
      cli::cli_abort("All groups must have at least {min_cells} cells")
    }

    rf_train <- rf_dat %>%
      rownames_to_column(".cell_id") %>%
      group_by(!!sym(data_clmn))
    
    set.seed(42)
    
    rf_train <- rf_train %>%
      dplyr::sample_n(sample_size) %>%
      column_to_rownames(".cell_id")

    rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
    
  } else {
    set.seed(42)
    
    rf_split <- initial_split(rf_dat, prop = 0.5)
    rf_train <- training(rf_split)
    rf_test  <- testing(rf_split)
  }
  
  # Set parameters to test
  # if class weights are provided, remove repetitive combinations
  rf_params <- expand.grid(param_lst)
  rf_params <- bind_cols(rf_params, list(...))
  
  weight_classes <- all(classes %in% names(rf_params)) && !balance_groups
  
  if (weight_classes) {
    clmns <- colnames(rf_params)
    clmns <- clmns[!clmns %in% classes]
    
    rf_params <- rf_params %>%
      mutate(frac = !!sym(classes[1]) / !!sym(classes[2])) %>%
      distinct(!!!syms(clmns), frac, .keep_all = TRUE) %>%
      dplyr::select(-frac)
  }
  
  n_params    <- nrow(rf_params)
  rf_params$n <- 1:n_params
  
  # Train models
  res <- pmap_dfr(rf_params, ~ {
    args <- list(...)

    # Select training sample
    # if class weights are passed, downsample training data accordingly
    if (weight_classes) {
      train_sizes <- floor(class_sizes / 2)
      
      class_wts <- set_names(as.numeric(args[classes]), classes)
      class_wts <- sort(class_wts, decreasing = TRUE)
      
      train_sizes <- train_sizes[names(class_wts)]
      
      ratio  <- class_wts[[1]] / class_wts[[2]]
      new_sz <- floor(train_sizes[[1]] / ratio)
      new_sz <- max(new_sz, min_cells)
      
      if (new_sz > train_sizes[[2]]) {
        new_sz <- floor(train_sizes[[2]] * ratio)
        new_sz <- max(new_sz, min_cells)
        
        train_sizes[1] <- new_sz
        
      } else {
        train_sizes[2] <- new_sz
      }
      
      rf_train <- rf_dat %>%
        rownames_to_column(".cell_id") %>%
        split(.[[data_clmn]]) %>%
        imap_dfr(~ {
          sz <- train_sizes[[.y]]
          
          set.seed(42)
          
          .x %>%
            dplyr::sample_n(sz) %>%
            column_to_rownames(".cell_id")
        })
      
      rf_test <- rf_dat[!rownames(rf_dat) %in% rownames(rf_train), ]
      
      args[classes] <- NULL
    }

    # RF parameters
    if (args$mtry > (ncol(rf_train) - 1)) {
      cli::cli_warn("mtry ({args$mtry}) is greater than the number of features")
      
      return(NULL)
    }
    
    args$data        <- rf_train
    args$formula     <- as.formula(str_c(data_clmn, " ~ ."))
    args$importance  <- args$importance %||% "impurity_corrected"
    args$seed        <- args$seed %||% 42
    args$num.threads <- args$num.threads %||% 12
    args$probability <- args$probability %||% FALSE
      
    # Train initial model
    set.seed(42)
    
    raw_mod <- mod <- lift_dl(train_fn)(args)
    
    raw_err   <- raw_mod$prediction.error
    key_feats <- importance(raw_mod)
    
    # Feature selection
    # identify most important features, filter, re-train
    if (select_feats) {
      key_feats <- importance_pvalues(raw_mod)
      key_feats <- sort(key_feats[, "pvalue"])
      
      max_p <- key_feats %>%
        head(min_feats) %>%
        max()
      
      feat_p    <- max(max_p, feat_p)
      key_feats <- names(key_feats[key_feats < feat_p])
      n_feats   <- length(key_feats)
      
      # Re-train model
      args$mtry       <- min(args$mtry, n_feats)
      args$data       <- rf_train[, c(data_clmn, key_feats)]
      args$importance <- "none"
      
      set.seed(42)
      
      mod <- lift_dl(train_fn)(args)
    }
    
    err <- mod$prediction.error
    
    # Compare fraction predicted groups for each mouse with ground truth
    if (!is.null(df_list)) {
      frac_clmn <- str_c("frac_", frac_grp)
      
      frac_stats <- df_list %>%
        imap_dfr(~ {
          mod %>%
            rf_predict(
              .x,
              data_clmn    = data_clmn,
              return_stats = FALSE,
              prob         = args$probability
            ) %>%
            mutate(sample = .y)
        }) %>%
        group_by(sample) %>%
        summarize(
          !!sym(frac_clmn) := sum(pred == frac_grp) / n(),
          .groups   = "drop"
        ) %>%
        summarize(across(all_of(frac_clmn), list(mean = mean, sd = sd)))
    }
    
    # Test model
    prds <- mod %>%
      rf_predict(
        dat          = rf_test,
        data_clmn    = data_clmn,
        return_stats = TRUE,
        prob         = args$probability
      )

    # Format output table
    res <- tibble(
      n_train   = nrow(rf_train),
      n_test    = nrow(rf_test),
      ...,
      n_feats = length(key_feats),
      oob_raw = raw_err,
      oob     = err
    ) %>%
      bind_cols(prds)
    
    if (!is.null(df_list)) {
      res <- res %>%
        bind_cols(frac_stats)
    }
    
    if (include_objects) {
      res <- res %>%
        mutate(
          mod          = list(mod),
          feats        = list(key_feats),
          training_bcs = list(rownames(rf_train))
        )
    }
    
    cli::cli_alert_info("Training: {args$n} / {n_params}")
    
    res
  })
  
  if (nrow(res) == 0) return(NULL)  # If mtry is too high
  
  res <- res %>%
    arrange(desc(F1))
  
  res
}

create_gn_plots <- function(so_in, ag_high_gns = NULL, ag_low_gns = NULL,
                            x = "pred_grp", plt_clrs, x_lvls, p_alt = NULL,
                            n_gns = 10, top_gns = NULL,
                            p_test = wilcox.test, draw_line = TRUE, pt_size = 1,
                            sort = TRUE) {
  
  # Set gene lists
  gns <- c(ag_high_gns, ag_low_gns)
  
  if (is.null(gns)) stop("Must provide Ag-high or -low genes")
  
  alt_high <- alt_low <- p_alt
  alt_high <- alt_high %||% "greater"
  alt_low  <- alt_low  %||% "less"
  
  alt_key <- set_names(
    c(rep(alt_high, length(ag_high_gns)), rep(alt_low, length(ag_low_gns))),
    gns
  )
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  gn_dat <- so_in %>%
    FetchData(c("mouse", "tm", "subtype", x, "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(
      name      = fct_relevel(name, gns),
      tm        = str_c("day ", tm),
      x         = str_c(!!sym(x), "-", tm),
      !!sym(x) := fct_relevel(!!sym(x), x_lvls),
      p_alt     = alt_key[name]                            # order boxes for
    ) %>%                                                  # each timepoint
    arrange(!!sym(x)) %>%
    mutate(x = fct_inorder(x))
  
  plt_dat <- gn_dat %>%
    group_by(name, mouse, tm, subtype, !!sym(x), x, p_alt) %>%
    summarize(
      n   = n_distinct(.cell_id),
      med = median(value),
      q1  = quantile(value, 0.25),
      q3  = quantile(value, 0.75),
      .groups = "drop"
    ) %>%
    group_by(name, mouse, tm, subtype) %>%
    
    filter(sum(med) > 0) %>%  # remove genes where median is 0 for all
    mutate(cor = cor(as.numeric(!!sym(x)), med)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse) == n_mice) %>%
    ungroup()
  
  # Calculate p-values
  # adjust p-values based on number of plotted genes
  clmn2 <- x_lvls[2]
  clmn3 <- x_lvls[3]
  
  p_clmns <- c(clmn2, clmn3)
  
  p_dat <- gn_dat %>%
    group_by(mouse, tm, subtype, !!sym(x), x, name, p_alt) %>%
    mutate(y = quantile(value, 0.75)) %>%
    group_by(mouse, tm, subtype, name, p_alt) %>%
    summarize(
      y = max(y),
      n = n(),
      
      !!sym(clmn2) := p_test(
        value[!!sym(x) == clmn2], value[!!sym(x) == "Ag-low"],
        alternative = unique(p_alt)
      )$p.value,
      !!sym(clmn3) := p_test(
        value[!!sym(x) == clmn3], value[!!sym(x) == "Ag-low"],
        alternative = unique(p_alt)
      )$p.value,
      .groups = "drop"
    ) %>%
    group_by(name) %>%
    mutate(y = max(y)) %>%
    
    group_by(mouse, tm, subtype) %>%
    mutate(across(all_of(p_clmns), ~ p.adjust(.x, method = "bonferroni"))) %>%
    ungroup() %>%
    
    pivot_longer(all_of(p_clmns), names_to = x, values_to = "p") %>%
    mutate(
      top = name %in% top_gns,
      x   = str_c(!!sym(x), "-", tm)
    )
  
  # Rank genes by number of significant p-values
  gns <- p_dat %>%
    group_by(name, top, p_alt) %>%
    summarize(n = sum(p < 0.05), .groups = "drop") %>%
    filter(name %in% plt_dat$name) %>%
    mutate(p_alt = fct_relevel(p_alt, unique(alt_key))) %>%
    arrange(p_alt, desc(top), desc(n)) %>%
    group_by(p_alt) %>%
    dplyr::slice(1:n_gns) %>%
    
    arrange(p_alt, desc(n)) %>%
    
    pull(name) %>%
    as.character()
  
  # Create plots
  names(plt_clrs) <- str_c("day ", names(plt_clrs))
  
  x_lab <- plt_dat %>%
    mutate(xlab = str_c(!!sym(x), " (n = ", scales::label_comma()(n), ")")) %>%
    distinct(xlab, x)
  
  x_lab <- set_names(x_lab$xlab, x_lab$x)
  
  res <- plt_dat %>%
    filter(name %in% gns) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    ggplot(aes(x, med, color = tm)) +
    geom_segment(
      aes(x = x, xend = x, y = q1, yend = q3),
      linewidth = pt_size, color = ln_col
    ) +
    geom_point(aes(size = !!sym(x)))
  
  if (draw_line) {
    res <- res +
      geom_smooth(
        aes(x = as.numeric(as.factor(!!sym(x)))),
        method = "lm", linewidth = 0.25, linetype = 2,
        se = FALSE, formula = y ~ x
      )
  }
  
  res <- res +
    geom_point(
      aes(y = y),
      data = filter(p_dat, name %in% gns, p < 0.05),
      position = position_nudge(y = 0.2),
      color = "black", shape = 6, stroke = 1, size = pt_size
    ) +
    facet_grid(name ~ tm, scales = "free", switch = "y") +
    scale_size_manual(values = c(pt_size, pt_size * 1.25, pt_size * 1.25)) +
    scale_color_manual(values = plt_clrs) +
    scale_y_continuous(breaks = ~ c(ceiling(min(.x)), floor(max(.x)))) +
    scale_x_discrete(labels = x_lab) +
    base_theme +
    theme(
      aspect.ratio    = 1,
      legend.position = "none",
      panel.border    = element_rect(color = "grey75"),
      strip.placement = "outside",
      axis.title      = element_blank(),
      axis.text.x     = element_text(angle = 45, hjust = 1)
    )
  
  res
}

create_sig_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            pt_size = 0.15, pt_stroke = 0.6) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = grp_col,
      outline     = TRUE,
      plot_colors = clrs,
      panel_nrow  = 1,
      size        = pt_size,
      stroke      = pt_stroke,
      label_params = list(size = ttl_pt2)
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = 18),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_grp_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            lvls = c("Ag-competent", "Ag-low", "Ag-high", "other"),
                            pt_size = 0.25, pt_stroke = 0.8, ...) {
  so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col   = grp_col,
      outline     = TRUE,
      plot_colors = clrs,
      plot_lvls   = lvls,
      panel_nrow  = 1,
      size        = pt_size,
      stroke      = pt_stroke,
      color       = ln_col,
      label_params = list(size = ttl_pt2),
      trace_position = "bottom",
      ...
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F"),
                         max_gns = 75) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(pred_grp = fct_relevel(pred_grp, lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = "pred_grp", values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character() %>%
    head(max_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(pred_grp, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, sort_gns = "up",
                               lvls = names(pred_clrs), n_gns = 100,
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", "lec_type", "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(lec_type == "cLEC") %>%
    group_by(treatment, name, lec_type) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  if (identical(sort_gns, "down")) gn_lvls <- rev(gn_lvls)
  
  gn_lvls <- head(gn_lvls, n_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, lec_type) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ lec_type) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.75
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL, clrs = pred_clrs, ...) {
  typ <- str_remove(dat_col, "_[a-zA-Z]+$")
  
  dat <- df_in %>%
    filter(tm == "24hpi", lec_type == typ)
  
  if (nrow(dat) == 0) return(NULL)
  
  res <- dat %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, ...
    ) +
    facet_wrap(~ lec_type, nrow = 1, scales = "free_y") +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = clrs) +
    labs(title = ttl) +
    base_theme +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      # * overall fold enrichment scores for each cell type were not used
      #   in the final version of the GO heatmaps since the overall enrichment
      #   scores are on a much different scale as the other enrichement scores
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  # this is very slow
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}
```

```{r "RF Ag class", eval = run_rf}
# Set Ag-low/high classes for classifier
# * split for each cell type from each mouse
# * set subtype cutoff for all mice using d14 cutoff
ag_clmns <- set_names(
  c("Ag_score", "Ag_score_3", "Ag_score_6"),
  c(rf_dat_clmn, "Ag_class_3wk", "Ag_class_6wk")
)

ag_clmns %>%
  iwalk(~ {
    lec_so <- lec_so %>%
      mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
      cluster_signal(
        data_column  = .x,
        grp_column   = "mouse_type",
        clust_column = .y,
        method       = "km"
      )
    
    # The threshold will be the same for each column since this is set using
    # only the d14 mouse
    threshold <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, !!sym(.y) == "high") %>%
      group_by(subtype) %>%
      summarize(threshold = min(!!sym(.x)), .groups = "drop")
    
    threshold <- set_names(threshold$threshold, threshold$subtype)
    
    lec_so <<- lec_so %>%
      mutate_meta(
        mutate,
        !!sym(.y) := ifelse(!!sym(.x) >= threshold[subtype], "high", "low")
      )
  })

# Identify double-positive cells for the 6wk-3wk mouse
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    Ag_class_dual = case_when(
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" & Ag_class_6wk == "high") ~ "double-high",
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" | Ag_class_6wk == "high") ~ "single-high",
      # mouse == "6wk-3wk" & Ag_class_6wk == "high"                            ~ "6wk-single",
      # mouse == "6wk-3wk" & Ag_class_3wk == "high"                            ~ "3wk-single",
      mouse == "6wk"     & Ag_class_6wk == "high"                            ~ "6wk-high",
      mouse == "3wk"     & Ag_class_3wk == "high"                            ~ "3wk-high",
      # mouse == "6wk-3wk" & (Ag_class_3wk == "low" & Ag_class_6wk == "low")   ~ "double-low",
      TRUE                                                                   ~ "low"
    )
  )

# Select LEC subsets to use for RF
rf_typs <- lec_so@meta.data %>%
  filter(mouse == rf_mouse) %>%
  group_by(subtype, !!sym(rf_dat_clmn)) %>%
  summarize(n = n(), .groups = "drop") %>%
  group_by(subtype) %>%
  filter(all(n > 60)) %>%
  summarize(n = sum(n), .groups = "drop") %>%
  arrange(desc(n)) %>%
  pull(subtype) %>%
  unique()
```

```{r "identify Ag DEGs", eval = run_rf}
# Identify Ag markers for all LECs for each mouse
fc <- 0

deg_so <- lec_so %>%
  SplitObject("mouse")

degs_1 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = "all", mouse = .y) %>%
      arrange(padj)
  })

# Identify Ag markers for subtype
deg_so <- lec_so %>%
  SplitObject("subtype")

degs_2 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y, mouse = "all") %>%
      arrange(padj)
  })

rm(deg_so)

# Identify markers for subtype and mouse
degs_3 <- lec_so@meta.data %>%
  distinct(subtype, mouse) %>%
  pmap_dfr(~ {
    res <- lec_so %>%
      subset(subtype == ..1 & mouse == ..2)
    
    if (n_distinct(res[[rf_dat_clmn]]) < 2) return(NULL)
    
    res <- res %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = ..1, mouse = ..2) %>%
      arrange(padj)
  })

degs <- bind_rows(degs_1, degs_2, degs_3) %>%
  filter(
    padj < 0.05, logFC > fc,
    !grepl("^(mt-|R[pls])", feature),
    feature != "Malat1"
  )

# Write table
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "train RF models", eval = run_rf}
# Test parameters and calculate stats for each LEC subtype
rf_stats <- rf_typs %>%
  map_dfr(~ {
    feats <- degs %>%
      filter(subtype == .x) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == .x & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    all_dat <- lec_so %>%
      subset(subtype == .x & mouse != rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, "mouse", feats))) %>%
      as_tibble(rownames = ".cell_id") %>%
      rename_with(~ str_replace_all(.x, "-", "_")) %>%
      rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
      rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
      column_to_rownames(".cell_id") %>%
      split(.$mouse)
    
    # Set RF params to test every combination
    max_mtry <- min(length(feats), 1000)
    
    param_lst <- list(
      mtry          = seq(1, max_mtry, floor(max_mtry / 15)),
      min.node.size = seq(1, 10, 2),
      num.trees     = seq(50, 1200, 100),
      low           = seq(1, 5, 1),
      high          = seq(1, 5, 1)
    )
    
    # Train model
    res <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = param_lst,
        df_list         = all_dat[names(all_dat) != rf_mouse],
        scale_data      = FALSE,
        include_objects = FALSE
      )
    
    if (is.null(res)) return(res)  # If mtry is too high
    
    # Identify best models
    target_frac <- sum(rf_dat[[rf_dat_clmn]] == "high") / nrow(rf_dat)
    
    res <- res %>%
      arrange(desc(F1)) %>%
      mutate(
        subtype     = .x,
        target_frac = target_frac,
        rank        = row_number()
      )
      
    res
  })

# Train models based on best parameters
# sort based on balanced accuracy and F1 score
rf_mods <- rf_stats %>%
  group_by(subtype) %>%
  filter(abs(target_frac - frac_high_mean) < 0.05) %>%
  slice_max(`Balanced Accuracy`, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  split(.$subtype)

rf_mods <- rf_mods %>%
  imap_dfr(~ {
    feats <- degs %>%
      filter(subtype == .y) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == .y & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
        
        rf_dat %>%
          train_rf(
            data_clmn       = rf_dat_clmn,
            param_lst       = args[stats],
            include_objects = TRUE
          ) %>%
          mutate(subtype = args$subtype)
      })
  })

# Save RF models
rf_stats %>%
  write_tsv(here(params$mod_dir, "ag-high_models.tsv.gz"))
```

```{r "load CHIKV data", eval = run_rf}
# Load CHIKV data
chikv_so <- qread(here(params$chikv_dir, "so_lec.qs"))

chikv_feats <- degs %>%
  pull(feature) %>%
  unique()

chikv_clmns <- c(
  "orig.ident", "rep", "treatment", "tm",
  "cell_type_2", "cell_type", "lec_type", "subtype",
  "UMAP_1", "UMAP_2"
)

chikv_dat <- chikv_so %>%
  FetchData(c(chikv_clmns, chikv_feats))

# Add zeros for missing genes
missing_gns <- chikv_feats[!chikv_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))
```

```{r "OLD MODELS 58d69d9", eval = FALSE}
## CODE USED FOR 2023-11-01 MODELS ##
# https://github.com/sheridar/antigen-exchange/blob/58d69d9974d5779cfcdc38f7ec19dfc48686f0b4/results/tamburini-ml.Rmd

# Identify top models for each cell type
# !! stats in rf_stats do not match stats produced during model training !!
# !! a key difference is the number of test and training cells           !!
# rf_stats <- read_tsv(here(params$mod_dir, "ag-high_stats.tsv.gz"))
rf_stats <- rf_stats %>%
  distinct(high / low, F1, `Balanced Accuracy`, .keep_all = TRUE) %>%
  group_by(subtype) %>%
  slice_max(`Balanced Accuracy`, prop = 0.2) %>%
  slice_max(F1, n = 100, with_ties = FALSE) %>%
  ungroup()

# Format CHIKV RF data
# need to add zeros for missing genes
chikv_so <- qread(params$chikv_so) %>%
  subset(treatment == "mock" & tm == "24hpi" & rep == 1)

chikv_feats <- degs %>%
  pull(feature) %>%
  unique()

chikv_dat <- chikv_so %>%
  FetchData(c("lec_type", chikv_feats))

missing_gns <- chikv_feats[!chikv_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Check model performance using some CHIKV data
# assess fold change in module score for one mock CHIKV replicate
# CLEAN THIS UP
rf_stats <- rf_stats %>%
  pmap_dfr(~ {
    args <- list(...)
    
    # Train model
    feats <- degs %>%
      filter(subtype == args$subtype) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
    
    mod <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = args[stats],
        include_objects = TRUE
      ) %>%
      mutate(subtype = args$subtype)
    
    # Pull top features
    mod_feats <- mod$feats[[1]] %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    mod_feats <- degs %>%
      filter(feature %in% mod_feats) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
    
    # Predict using models for each LEC subset
    chikv_dat <- chikv_dat %>%
      filter(lec_type == mod$subtype) %>%
      dplyr::select(-lec_type)
    
    chikv_preds <- mod$mod[[1]] %>%
      rf_predict(
        dat = chikv_dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
    
    chikv_so <- chikv_so %>%
      subset(lec_type == mod$subtype) %>%
      AddMetaData(chikv_preds)
    
    # Add module scores
    clmn_nms <- names(mod_feats)
    
    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      names(mod_feats)
    )
    
    chikv_so <- chikv_so %>%
      AddModuleScore(
        features = mod_feats,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
    
    # Calculate fold change for low and high groups
    chikv_stats <- chikv_so@meta.data %>%
      mutate(
        min_val = min(c(high, low)),
        across(c(high, low), ~ ifelse(min_val < 0, .x + abs(min_val), .x)),  # correct negative values
        
        high_mod_p = wilcox.test(                                            # calculate p-values
          high[pred == "high"], high[pred == "low"],
          alternative = "greater"
        )$p.value,
        low_mod_p = wilcox.test(
          low[pred == "high"], low[pred == "low"], 
          alternative = "less"
        )$p.value
      ) %>%
      group_by(pred, high_mod_p, low_mod_p) %>%                              # calculate median
      summarize(across(c(high, low), median), .groups = "drop") %>%
      summarize(                                                             # calculate fold change
        across(ends_with("_mod_p"), unique),
        high_mod_fc = high[pred == "high"] / high[pred == "low"],
        low_mod_fc  = low[pred == "high"]  / low[pred == "low"]
      )
    
    # Return stats
    res <- mod %>%
      bind_cols(chikv_stats)
    
    res
  })

## KEY DIFFERENCE WITH THIS VERSION IS FILTERING BASED ON CHIKV PERFORMANCE ##
# Select best model
# train models based on best parameters
# sort based on fold change in module score
rf_mods <- rf_stats %>%
  filter(high_mod_fc >= 1.2, low_mod_fc < 0.9) %>%
  arrange(desc(F1), desc(high_mod_fc), low_mod_fc) %>%
  group_by(subtype) %>%
  dplyr::slice(1) %>%
  ungroup()
```

```{r "assess model performance using CHIKV data", eval = run_rf}
# Identify top models for each cell type
# !! stats in rf_stats do not match stats produced during model training !!
# !! a key difference is the number of test and training cells           !!
# rf_stats <- read_tsv(here(params$mod_dir, "ag-high_stats.tsv.gz"))
rf_mods <- rf_stats %>%
  distinct(high / low, abs(target_frac - frac_high_mean), F1, `Balanced Accuracy`, .keep_all = TRUE) %>%
  group_by(subtype) %>%
  slice_max(`Balanced Accuracy`, n = 50, with_ties = FALSE) %>%
  ungroup()

# Format CHIKV RF data
chikv_rf_so <- chikv_so %>%
  subset(treatment == "mock" & tm == "24hpi" & rep == 1)

chikv_rf_dat <- chikv_dat[Cells(chikv_rf_so), ]

### CLEAN THIS UP ###
# Check model performance using some CHIKV data
# assess fold change in module score for one mock CHIKV replicate
# rf_stats <- rf_stats %>%
rf_mods <- rf_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    # Train model
    feats <- degs %>%
      filter(subtype == args$subtype) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
    
    mod <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = args[stats],
        include_objects = TRUE
      ) %>%
      mutate(subtype = args$subtype)
    
    # Pull top features
    mod_feats <- mod$feats[[1]] %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    mod_feats <- degs %>%
      filter(feature %in% mod_feats) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
    
    # Predict using models for each LEC subset
    chikv_dat <- chikv_dat %>%
      filter(lec_type == mod$subtype) %>%
      dplyr::select(-lec_type)
    
    chikv_preds <- mod$mod[[1]] %>%
      rf_predict(
        dat = chikv_dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
    
    chikv_rf_so <- chikv_rf_so %>%
      subset(lec_type == mod$subtype) %>%
      AddMetaData(chikv_preds)
    
    # Add module scores
    clmn_nms <- names(mod_feats)
    
    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      names(mod_feats)
    )
    
    chikv_rf_so <- chikv_rf_so %>%
      AddModuleScore(
        features = mod_feats,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
    
    # Calculate fold change for low and high groups
    chikv_stats <- chikv_rf_so@meta.data %>%
      mutate(
        min_val = min(c(high, low)),
        across(c(high, low), ~ ifelse(min_val < 0, .x + abs(min_val), .x)),  # correct negative values
        
        high_mod_p = wilcox.test(                                            # calculate p-values
          high[pred == "high"], high[pred == "low"],
          alternative = "greater"
        )$p.value,
        low_mod_p = wilcox.test(
          low[pred == "high"], low[pred == "low"], 
          alternative = "less"
        )$p.value
      ) %>%
      group_by(pred, high_mod_p, low_mod_p) %>%                              # calculate median
      summarize(across(c(high, low), median), .groups = "drop") %>%
      summarize(                                                             # calculate fold change
        across(ends_with("_mod_p"), unique),
        high_mod_fc = high[pred == "high"] / high[pred == "low"],
        low_mod_fc  = low[pred == "high"]  / low[pred == "low"]
      )
    
    # Return stats
    res <- mod %>%
      bind_cols(chikv_stats)
    
    res
  })

# Select best model
# train models based on best parameters
# sort based on fold change in module score
rf_mods_best <- rf_mods %>%
  # filter(
  #   high_mod_fc >= 1.2, low_mod_fc < 0.9,
  #   high_mod_p < 0.05,  low_mod_p < 0.05
  # ) %>%
  arrange(desc(`Balanced Accuracy`), desc(high_mod_fc), low_mod_fc) %>%
  group_by(subtype) %>%
  dplyr::slice(1) %>%
  ungroup()

rf_mods_best <- rf_mods_best %>%
  split(.$subtype) %>%
  imap_dfr(~ {
    feats <- degs %>%
      filter(subtype == .y) %>%
      pull(feature) %>%
      unique()

    rf_dat <- lec_so %>%
      subset(subtype == .y & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))

    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        stats <- c("mtry", "min.node.size", "num.trees", "low", "high")

        rf_dat %>%
          train_rf(
            data_clmn       = rf_dat_clmn,
            param_lst       = args[stats],
            include_objects = TRUE
          ) %>%
          mutate(subtype = args$subtype)
      })
  })

# Save filtered models
rf_mods_best %>%
  qsave(here(params$mod_dir, "ag-high_models.qs"))

# Remove CHIKV objects
rm(chikv_so, chikv_rf_so, chikv_rf_dat)
```

```{r "RF MODEL STACKING", eval = FALSE}
feats <- degs %>%
  pull(feature) %>%
  unique()

rf_dat <- lec_so %>%
  subset(mouse == rf_mouse) %>%
  FetchData(unique(c(rf_dat_clmn, feats)))

rf_split <- initial_split(rf_dat, prop = 0.5)
rf_train <- training(rf_split)
rf_test  <- testing(rf_split)

en <- ensemble(
  training = rf_train,
  testing  = rf_test,
  outcomeName = rf_dat_clmn,
  BaseModels = rf_mods_best$mod
)
```

```{r "RF features", eval = run_rf}
# Pull best features
rf_feats <- rf_mods_best %>%
  pmap(~ {
    args <- list(...)
    
    fts <- args$feats %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    degs %>%
      filter(feature %in% fts) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
  })

names(rf_feats) <- rf_mods_best$subtype

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Save top features
rf_feats %>%
  qsave(here(params$mod_dir, "ag-high_features.qs"))
```

```{r "predict Ag class", eval = run_rf}
# # Predict Ag class
# # remove cells used to train models
# train_cells <- unlist(rf_mods_best$training_bcs)
# keep_cells  <- Cells(lec_so)
# keep_cells  <- keep_cells[!keep_cells %in% train_cells]

### SHOULD TRAINING CELLS BE EXCLUDED ##

info_clmns <- c("subtype", "mouse")

pred_dat <- lec_so %>%
  # subset(cells = keep_cells) %>%
  FetchData(unique(c(rf_dat_clmn, info_clmns, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  mutate(mouse = as.character(mouse)) %>%
  column_to_rownames(".cell_id")

rf_preds <- rf_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Predict Ag class for all subsets using cLEC model
rf_preds_2 <- rf_mods_best %>%
  filter(subtype == rf_cell_type) %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = args$mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Write table with predictions
rf_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz"))

rf_preds_2 %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_cLEC_preds.tsv.gz"))
```

```{r "predict CHIKV", eval = run_rf}
# Predict using models for each LEC subset
chikv_preds <- rf_mods_best %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- chikv_dat %>%
      filter(lec_type == args$subtype) %>%
      dplyr::select(-all_of(chikv_clmns))
    
    args$mod %>%
      rf_predict(
        dat = dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
  })

# Save predictions
chikv_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz"))
```

```{r "load models"}
# Load saved objects
rf_mods <- qread(here(params$mod_dir, "ag-high_models.qs"))
degs    <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

rf_preds <- read_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")

rf_feats <- qread(here(params$mod_dir, "ag-high_features.qs"))

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Load CHIKV predictions
chikv_preds <- read_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")
```




```{r "AG CLASS 2", eval = FALSE}
# Try splitting into Ag-low/high separately for each cell type
lec_so <- lec_so %>%
  subset(mouse != "d2") %>%
  mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
  cluster_signal(
    data_column  = "Ag_score",
    grp_column   = "mouse_type",
    clust_column = "Ag_class_2",
    method       = "km"
  )
```