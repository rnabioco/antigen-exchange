
```{r "RF setup", include = FALSE}
# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 300
)

# Colors
pred_clrs <- c(
  `Ag-low`       = "#6A51A3",
  `Ag-competent` = "#E69F00",
  `Ag-high`      = "#D7301F"
)

# RF parameters
rf_dat_clmn  <- "Ag_class_ml"
rf_cell_type <- "cLEC"
rf_mouse     <- "d14"
rf_typs      <- c("cLEC", "fLEC", "Collecting")

# Cell type column for CHIKV data
chikv_type_clmn <- "lec_subtype"

# Check for RF predictions
run_rf <- !file.exists(here(params$mod_dir, "ag-high_preds.tsv.gz"))
```

```{r "RF functions"}
# Function to predict
rf_predict <- function(mod, dat, data_clmn = NULL, return_stats = TRUE,
                       prob = FALSE) {
  
  prds <- mod %>%
    predict(dat, seed = 42) %>%
    ranger::predictions()
  
  if (prob) {
    classes <- colnames(prds)
    
    prds <- prds %>%
      as.data.frame() %>%
      mutate(pred = ifelse(!!sym(classes[1]) > 0.5, classes[1], classes[2])) %>%
      pull(pred)
  }
  
  res <- dat %>%
    as_tibble(rownames = ".cell_id") %>%
    mutate(pred = prds)
  
  if (is.null(data_clmn)) return(res)
  
  res <- res %>%
    mutate(!!sym(data_clmn) := fct_relevel(!!sym(data_clmn), levels(prds)))
  
  res <- res %>%
    dplyr::select(.cell_id, all_of(data_clmn), pred) %>%
    mutate(correct = pred == !!sym(data_clmn)) %>%
    group_by(pred) %>%
    mutate(frac_correct = sum(correct) / n()) %>%
    ungroup()
  
  if (!return_stats) return(column_to_rownames(res, ".cell_id"))
  
  # Calculate F1 score
  stats <- caret::confusionMatrix(
    data      = res$pred,
    reference = res[[data_clmn]],
    positive  = "high"
  )
  
  stats <- as_tibble(as.list(stats$byClass))
    
  stats
}

#' Generate RF models using given data and parameters
#' 
#' @param df_in data.frame containing features as columns and observations as
#' rows
#' @param data_clmn column in df_in containing response variable
#' @param param_lst list of RF parameters to expand and test
#' @param feat_p p-value cutoff for selecting best features
#' @param min_feats minimum number of features to allow after feature selection
#' @param min_cells minimum number of cells required for each group in data_clmn
#' @param select_feats should features be filtered based on p-value
#' @param training_split fraction of cells that should be used for training,
#' by default this is 1 since assessing accuracy using 10-fold cross validation
#' @param df_list list of data.frames containing data for each mouse to use for
#' comparing the fraction of predicted Ag-high cells. Want a model where the
#' fraction of predicted Ag-high cells is roughly the same for all samples.
#' @param pos_grp group in data_clmn to consider as a 'positive' case
#' @param include_objects in output tibble include ranger object, top features,
#' and cell barcodes for training data
#' @param ... additional parameters to pass to ranger::ranger()
train_rf <- function(df_in, data_clmn, param_lst,
                     feat_p = 0.05, min_feats = 20, min_cells = 30,
                     select_feats = TRUE, training_split = 1,
                     df_list = NULL, pos_grp = "high",
                     include_objects = FALSE, ...) {
  
  # Format input data
  rf_dat <- df_in %>%
    dplyr::select(
      all_of(data_clmn),
      where(~ !all(.x == 0))
    ) %>%
    mutate(!!sym(data_clmn) := factor(!!sym(data_clmn))) %>%
    rename_with(~ str_replace_all(.x, "-", "_")) %>%
    rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
    rename_with(~ str_c("x", .x), matches("^[0-9]"))
  
  classes    <- as.character(unique(rf_dat[[data_clmn]]))
  train_seed <- param_lst$seed %||% 42
  
  # Set default training and testing groups
  rf_train <- rf_dat
  
  if (training_split < 1) {
    set.seed(train_seed)
    
    rf_split <- initial_split(rf_dat, prop = training_split)
    rf_train <- training(rf_split)
  }
  
  class_sizes <- table(rf_train[[rf_dat_clmn]])
  
  # Set parameters to test
  # if class weights are provided, remove repetitive combinations
  grid_vars <- c("mtry", "min.node.size", "splitrule")
  
  if (any(!grid_vars %in% names(param_lst))) {
    cli_abort("param_lst must include {grid_vars}.")
  }
  
  rf_params <- expand.grid(param_lst)
  rf_params <- bind_cols(rf_params, list(...))
  
  weight_classes <- all(classes %in% names(param_lst))
  
  if (weight_classes) {
    clmns <- colnames(rf_params)
    clmns <- clmns[!clmns %in% classes]
    
    rf_params <- rf_params %>%
      mutate(frac = !!sym(classes[1]) / !!sym(classes[2])) %>%
      distinct(!!!syms(clmns), frac, .keep_all = TRUE) %>%
      dplyr::select(-frac)
  }
  
  n_params           <- nrow(rf_params)
  rf_params$param_id <- 1:n_params
  
  # Train models
  res <- pmap_dfr(rf_params, ~ {
    args <- list(...)
    
    grid_params <- as.data.frame(args[grid_vars])
    caret_args  <- args[!names(args) %in% c(grid_vars, classes, "param_id")]
    
    # Select training sample
    # if class weights are passed, downsample training data accordingly
    # if either class weight is NA, skip. Passing an NA is how the user can
    # specify to use the data asis
    if (weight_classes && all(!is.na(args[classes]))) {
      
      # Keep class weights and training class sizes ordered      
      class_wts   <- set_names(as.numeric(args[classes]), classes)
      class_wts   <- sort(class_wts, decreasing = TRUE)
      class_sizes <- class_sizes[names(class_wts)]
      
      ratio  <- class_wts[[1]] / class_wts[[2]]
      new_sz <- floor(class_sizes[[1]] / ratio)
      new_sz <- max(new_sz, min_cells)
      
      if (new_sz > class_sizes[[2]]) {
        new_sz <- floor(class_sizes[[2]] * ratio)
        new_sz <- max(new_sz, min_cells)
        
        class_sizes[1] <- new_sz
        
      } else {
        class_sizes[2] <- new_sz
      }
      
      rf_train <- rf_train %>%
        rownames_to_column(".cell_id") %>%
        split(.[[data_clmn]]) %>%
        imap_dfr(~ {
          sz <- class_sizes[[.y]]
          
          set.seed(train_seed)
          
          .x %>%
            slice_sample(n = sz, replace = FALSE) %>%
            column_to_rownames(".cell_id")
        })
      
      if (any(duplicated(rownames(rf_train)))) {
        cli_abort(
          "Some cells are duplicated after downsampling.",
          .internal = TRUE
        )
      }
    }

    # RF parameters
    # mtry cannot be greater than the number of features
    # For shorter run time do not use cv for initial model
    if (args$mtry > (ncol(rf_train) - 1)) {
      cli::cli_warn("mtry ({args$mtry}) is greater than the number of features")
      
      return(NULL)
    }
    
    caret_control <- trainControl(method = "none")  # this produces warning
    
    predictors <- rf_train %>%
      dplyr::select(-all_of(data_clmn))
    
    outcome <- rf_train[[data_clmn]]
    
    caret_args$x          <- predictors
    caret_args$y          <- outcome
    caret_args$method     <- "ranger"
    caret_args$trControl  <- caret_control
    caret_args$tuneGrid   <- grid_params
    caret_args$importance <- caret_args$importance %||% "impurity_corrected"
    caret_args$seed       <- train_seed
    caret_args$verbose    <- caret_args$verbose %||% FALSE

    # Train initial model to identify key features
    set.seed(train_seed)
    
    mod <- lift_dl(train)(caret_args)
    
    key_feats <- importance_pvalues(mod$finalModel)
    
    key_feats <- key_feats %>%
      as_tibble(rownames = "gene") %>%
      arrange(pvalue, desc(importance))
    
    # Feature selection
    # identify most important features, filter, re-train
    if (select_feats) {
      max_p <- key_feats %>%
        head(min_feats) %>%
        pull(pvalue) %>%
        max()
      
      feat_p <- max(max_p, feat_p)
      
      key_feats <- key_feats %>%
        filter(pvalue < feat_p)
      
      n_feats <- nrow(key_feats)
      
      if (feat_p > 0.05) {
        cli_warn(
          "Due to the low number of significant features,
           a p-value cutoff of {round(feat_p, 2)} was used for feature
           selection"
        )
      }
      
      caret_args$tuneGrid$mtry <- min(caret_args$tuneGrid$mtry, n_feats)
      caret_args$x             <- predictors[, key_feats$gene]
    }
    
    # Re-train model
    # calculate performance metrics using 10-fold cross validation
    # use filtered features and do not calculate impurity corrected importance
    # impurity corrected importance results in a worse model for prediction
    calc_training_stats <- function(data, lev = NULL, model = NULL) {
      res <- confusionMatrix(
        data$pred, data$obs,
        positive = pos_grp
      )
      
      c(res$overall, res$byClass)
    }
    
    caret_control$method          <- "cv"
    caret_control$number          <- 10
    caret_control$seeds           <- as.list(1:11)
    caret_control$summaryFunction <- calc_training_stats
    
    caret_args$trControl  <- caret_control
    caret_args$importance <- "none"
    
    set.seed(train_seed)
    
    mod <- lift_dl(train)(caret_args)
    
    # Compare fraction predicted groups for additional data
    # this is useful if expecting the proportion of predicted groups to be
    # consistent between different datasets
    res <- mod$results
    
    if (!is.null(df_list)) {
      frac_clmn <- str_c("frac_", pos_grp)
      
      frac_stats <- df_list %>%
        imap_dfr(~ {
          mod$finalModel %>%
            rf_predict(
              .x,
              data_clmn    = data_clmn,
              return_stats = FALSE
            ) %>%
            mutate(sample = .y)
        }) %>%
        group_by(sample) %>%
        summarize(
          !!sym(frac_clmn) := sum(pred == pos_grp) / n(),
          .groups = "drop"
        ) %>%
        summarize(across(all_of(frac_clmn), list(mean = mean, sd = sd))) %>%
        mutate(
          frac_actual_high = sum(rf_dat[[data_clmn]] == pos_grp) / nrow(rf_dat)
        )
      
      res <- bind_cols(res, frac_stats)
    }
    
    # Format output table
    res <- tibble(
      n_cells = nrow(rf_dat),
      n_train = nrow(rf_train),
      !!!args[!names(args) %in% grid_vars],
      n_feats = nrow(key_feats)
    ) %>%
      bind_cols(res)
    
    if (include_objects) {
      res <- res %>%
        mutate(
          mod          = list(mod),
          feats        = list(key_feats),
          training_bcs = list(rownames(rf_train))
        )
    }
    
    cli_alert_info("Training: {args$param_id} / {n_params}")
    
    res
  })
  
  if (nrow(res) == 0) return(NULL)  # If mtry is too high
  
  res <- res %>%
    arrange(desc(Kappa))
  
  res
}

create_gn_plots <- function(so_in, ag_high_gns = NULL, ag_low_gns = NULL,
                            x = "pred_grp", plt_clrs, x_lvls, p_alt = NULL,
                            n_gns = 10, top_gns = NULL,
                            p_test = wilcox.test, draw_line = TRUE, pt_size = 1,
                            sort = TRUE) {
  
  # Set gene lists
  ag_high_gns <- head(ag_high_gns, n_gns)
  ag_low_gns  <- head(ag_low_gns, n_gns)
  
  gns <- c(ag_high_gns, ag_low_gns)
  
  if (any(duplicated(gns))) cli_abort("Provided genes cannot be duplicated")
  if (is.null(gns))         cli_abort("Must provide Ag-high or -low genes")
  
  # alt_high <- alt_low <- p_alt
  # alt_high <- alt_high %||% "greater"
  # alt_low  <- alt_low  %||% "less"
  # 
  # alt_key <- set_names(
  #   c(rep(alt_high, length(ag_high_gns)), rep(alt_low, length(ag_low_gns))),
  #   gns
  # )
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  gn_dat <- so_in %>%
    FetchData(c("mouse", "tm", "subtype", x, "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(
      name      = fct_relevel(name, gns),
      tm        = str_c("day ", tm),
      x         = str_c(!!sym(x), "-", tm),
      !!sym(x) := fct_relevel(!!sym(x), x_lvls),
      # p_alt     = alt_key[name]                            # order boxes for
    ) %>%                                                  # each timepoint
    arrange(!!sym(x)) %>%
    mutate(x = fct_inorder(x))
  
  plt_dat <- gn_dat %>%
    group_by(name, mouse, tm, subtype, !!sym(x), x) %>%
    summarize(
      n   = n_distinct(.cell_id),
      med = median(value),
      q1  = quantile(value, 0.25),
      q3  = quantile(value, 0.75),
      .groups = "drop"
    ) %>%
    group_by(name, mouse, tm, subtype) %>%
    
    # filter(sum(med) > 0) %>%  # remove genes where median is 0 for all
    mutate(cor = cor(as.numeric(!!sym(x)), med)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse) == n_mice) %>%
    ungroup() %>%
    
    mutate(gene_type = case_when(
      name %in% ag_high_gns ~ "Ag-high",
      name %in% ag_low_gns  ~ "Ag-low"
    ))
  
  # # Calculate p-values
  # # adjust p-values based on number of plotted genes
  # clmn2 <- x_lvls[2]
  # clmn3 <- x_lvls[3]
  # 
  # p_clmns <- c(clmn2, clmn3)
  # 
  # p_dat <- gn_dat %>%
  #   group_by(mouse, tm, subtype, !!sym(x), x, name, p_alt) %>%
  #   mutate(y = quantile(value, 0.75)) %>%
  #   group_by(mouse, tm, subtype, name, p_alt) %>%
  #   summarize(
  #     y = max(y),
  #     n = n(),
  #     
  #     !!sym(clmn2) := p_test(
  #       value[!!sym(x) == clmn2], value[!!sym(x) == "Ag-low"],
  #       alternative = unique(p_alt)
  #     )$p.value,
  #     !!sym(clmn3) := p_test(
  #       value[!!sym(x) == clmn3], value[!!sym(x) == "Ag-low"],
  #       alternative = unique(p_alt)
  #     )$p.value,
  #     .groups = "drop"
  #   ) %>%
  #   group_by(name) %>%
  #   mutate(y = max(y)) %>%
  #   
  #   group_by(mouse, tm, subtype) %>%
  #   mutate(across(all_of(p_clmns), ~ p.adjust(.x, method = "bonferroni"))) %>%
  #   ungroup() %>%
  #   
  #   pivot_longer(all_of(p_clmns), names_to = x, values_to = "p") %>%
  #   mutate(
  #     top = name %in% top_gns,
  #     x   = str_c(!!sym(x), "-", tm)
  #   )
  
  # # Rank genes by number of significant p-values
  # gns <- p_dat %>%
  #   group_by(name, top, p_alt) %>%
  #   summarize(n = sum(p < 0.05), .groups = "drop") %>%
  #   filter(name %in% plt_dat$name) %>%
  #   mutate(p_alt = fct_relevel(p_alt, unique(alt_key))) %>%
  #   arrange(p_alt, desc(top), desc(n)) %>%
  #   group_by(p_alt) %>%
  #   dplyr::slice(1:n_gns) %>%
  #   
  #   arrange(p_alt, desc(n)) %>%
  #   
  #   pull(name) %>%
  #   as.character()
  
  # Create plots
  # names(plt_clrs) <- str_c("day ", names(plt_clrs))
  
  x_lab <- plt_dat %>%
    mutate(xlab = str_c(!!sym(x), " (n = ", scales::label_comma()(n), ")")) %>%
    distinct(xlab, x)
  
  x_lab <- set_names(x_lab$xlab, x_lab$x)
  
  plt_dat <- plt_dat %>%
    filter(name %in% gns) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    split(.$gene_type)
    
  res <- plt_dat %>%
    imap(~ {
      .x <- .x %>%
        ggplot(aes(x, med, color = pred_grp)) +
        geom_segment(
          aes(x = x, xend = x, y = q1, yend = q3),
          linewidth = pt_size, color = ln_col
        ) +
        geom_point(aes(size = !!sym(x)))
      
      if (draw_line) {
        .x <- .x +
          geom_smooth(
            aes(x = as.numeric(as.factor(!!sym(x)))),
            method = "lm", linewidth = 0.25, linetype = 2,
            se = FALSE, formula = y ~ x
          )
      }
      
      .x <- .x +
        # geom_point(
        #   aes(y = y),
        #   data = filter(p_dat, name %in% gns, p < 0.05),
        #   position = position_nudge(y = 0.2),
        #   color = "black", shape = 6, stroke = 1, size = pt_size
        # ) +
        facet_grid(name ~ tm, scales = "free", switch = "y") +
        scale_size_manual(values = c(pt_size, pt_size * 1.25, pt_size * 1.25)) +
        scale_color_manual(values = plt_clrs) +
        scale_y_continuous(breaks = ~ c(ceiling(min(.x)), floor(max(.x)))) +
        scale_x_discrete(labels = x_lab) +
        base_theme +
        theme(
          aspect.ratio    = 1,
          legend.position = "none",
          panel.border    = element_rect(color = "grey75"),
          strip.placement = "outside",
          axis.title      = element_blank(),
          axis.text.x     = element_text(angle = 45, hjust = 1)
        )
      
      if (.y == dplyr::first(names(plt_dat))) {
        .x <- .x +
          theme(
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank()
          )
        
      } else {
        .x <- .x +
          theme(strip.text.x = element_blank())
      }
      
      .x
    })
  
  res <- plot_grid(
    plotlist = res,
    ncol  = 1,
    align = "v",
    axis  = "rl"
  )
  
  res
}

create_sig_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            pt_size = 0.15, pt_stroke = 0.6,
                            scale_limits = NULL, outline = TRUE) {
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      outline      = outline,
      plot_colors  = clrs,
      panel_nrow   = 1,
      size         = pt_size,
      stroke       = pt_stroke,
      label_params = list(size = ttl_pt2)
    ) +
    guides(fill = guide_colorbar(
      ticks = FALSE, title.position = "top",
      barheight = unit(6, "pt"), barwidth = unit(120, "pt"), 
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = 18),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  if (!is.null(scale_limits)) {
    res <- res +
      scale_fill_gradientn(colours = clrs, limits = scale_limits)
  }
  
  res
}

create_grp_umap <- function(so_in, dat_col, grp_col = "mouse", clrs,
                            lvls = c("Ag-competent", "Ag-low", "Ag-high", "other"),
                            ...) {
  
  res <- so_in %>%
    plot_scatter(
      dat_col,
      "hUMAP_1", "hUMAP_2",
      group_col    = grp_col,
      plot_colors  = clrs,
      plot_lvls    = lvls,
      panel_nrow   = 1,
      label_params = list(size = ttl_pt2),
      ...
    ) +
    guides(fill = guide_legend(
      label.position = "bottom", reverse = TRUE,
      override.aes = list(size = 4)
    )) +
    base_theme +
    theme(
      plot.margin     = margin(),
      plot.title      = element_text(size = ttl_pt2),
      legend.margin   = margin(),
      legend.position = "bottom",
      legend.title    = element_blank(),
      axis.title      = element_blank(),
      axis.ticks      = element_blank(),
      axis.text       = element_blank(),
      aspect.ratio    = 0.9
    )
  
  res
}

create_heats <- function(so_in, gns, sort_gns = "up", lvls = names(pred_clrs),
                         plt_clrs = c("lightblue", "white", "#D7301F"),
                         max_gns = 75) {
  
  # Format data
  n_mice <- n_distinct(so_in$mouse)
  
  heat_dat <- so_in %>%
    FetchData(c("mouse", "subtype", "pred_grp", "training_data", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    filter(!training_data) %>%
    pivot_longer(all_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name) %>%
    filter(n_distinct(mouse[value > 0]) == n_mice) %>%
    ungroup() %>%
    
    group_by(name, mouse, subtype, pred_grp) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(pred_grp = fct_relevel(pred_grp, lvls))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    pivot_wider(names_from = "pred_grp", values_from = value) %>%
    mutate(
      fc_1 = !!sym(lvls[2]) / !!sym(lvls[1]),
      fc_2 = !!sym(lvls[3]) / !!sym(lvls[1])
    ) %>%
    group_by(name) %>%
    summarize(
      across(c(fc_1, fc_2), ~ sum(.x > 1), .names = "{.col}_up"),
      across(c(fc_1, fc_2), ~ sum(.x < 1), .names = "{.col}_dwn"),
      .groups = "drop"
    ) %>%
    arrange(name)
  
  if (identical(sort_gns, "up")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_up, fc_2_up, name)

  } else if (identical(sort_gns, "down")) {
    gn_lvls <- gn_lvls %>%
      arrange(fc_1_dwn, fc_2_dwn, name)
  }
  
  gn_lvls <- gn_lvls %>%
    pull(name) %>%
    as.character() %>%
    head(max_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, mouse, subtype) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(pred_grp, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(~ mouse) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_mice * 0.6
    )
  
  res
}

create_chikv_heats <- function(so_in, gns, sort_gns = "up", type_clmn = chikv_type_clmn,
                               lvls = names(pred_clrs), n_gns = 100,
                               plt_clrs = c("lightblue", "white", "#6A51A3")) {
  
  # Format data
  heat_dat <- so_in %>%
    FetchData(c("treatment", "orig.ident", "rep", type_clmn, "pred", gns)) %>%
    as_tibble(rownames = ".cell_id") %>%
    pivot_longer(any_of(gns)) %>%
    mutate(name = fct_relevel(name, gns)) %>%
    
    group_by(name, treatment, orig.ident, rep, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    mutate(
      treat_rep = str_c(treatment, "-", rep),
      treatment = fct_relevel(treatment, names(treat_clrs))
    ) %>%
    arrange(treatment, rep) %>%
    mutate(treat_rep = fct_inorder(treat_rep))
  
  # Sort genes
  gn_lvls <- heat_dat %>%
    filter(!!sym(type_clmn) == "cLEC") %>%
    group_by(treatment, name, !!sym(type_clmn)) %>%
    summarize(value = mean(value), .groups = "drop") %>%
    pivot_wider(names_from = "treatment", values_from = value) %>%
    mutate(fc = CHIKV / mock) %>%
    arrange(desc(fc)) %>%
    pull(name) %>%
    unique() %>%
    as.character()
  
  if (identical(sort_gns, "down")) gn_lvls <- rev(gn_lvls)
  
  gn_lvls <- head(gn_lvls, n_gns)
  
  # Create heatmaps
  res <- heat_dat %>%
    filter(name %in% gn_lvls) %>%
    group_by(name, !!sym(type_clmn)) %>%
    mutate(
      value = as.numeric(scale(value)),
      name = fct_relevel(name, gn_lvls)
    ) %>%
    
    ggplot(aes(treat_rep, name, fill = value)) +
    geom_tile(color = "white") +
    scale_fill_gradientn(colours = plt_clrs) +
    facet_grid(as.formula(str_c("~", type_clmn))) +
    guides(fill = guide_colorbar(ticks = FALSE, barwidth = unit(10, "pt"))) +
    base_theme +
    theme(
      legend.title = element_blank(),
      axis.title   = element_blank(),
      axis.text.y  = element_text(color = "black"),
      axis.text.x  = element_text(angle = 45, hjust = 1, color = "black"),
      panel.border = element_rect(color = "black"),
      aspect.ratio = length(gn_lvls) / n_distinct(heat_dat$treat_rep) * 0.75
    )
  
  res
}

create_chikv_boxes <- function(df_in, dat_col, ttl = NULL,
                               type_clmn = chikv_type_clmn, clrs = pred_clrs,
                               ...) {
  
  typ <- str_remove(dat_col, "_[a-zA-Z]+$")
  
  dat <- df_in %>%
    filter(tm == "24hpi", !!sym(type_clmn) == typ)
  
  if (nrow(dat) == 0) return(NULL)
  
  res <- dat %>%
    ggplot(aes(treatment, !!sym(dat_col), fill = pred)) +
    geom_boxplot(
      outlier.size = 0.1, fatten = 1,
      key_glyph = draw_key_point, alpha = 0.9, ...
    ) +
    facet_wrap(
      as.formula(str_c("~", type_clmn)),
      nrow = 1, scales = "free_y"
    ) +
    guides(
      alpha = "none",
      fill = guide_legend(
        override.aes = list(shape = 22, size = 4),
        title = "predicted\nAg group", title.position = "top"
      )
    ) +
    scale_fill_manual(values = clrs) +
    labs(title = ttl) +
    base_theme +
    theme(
      aspect.ratio    = 1.2,
      plot.title      = element_text(size = ttl_pt2, hjust = 0.5),
      legend.position = "right",
      # legend.title    = element_text(),
      axis.title      = element_blank(),
      plot.margin     = margin()
    )
  
  res
}

#' Fill the upper triangular matrix completely
#' 
#' FROM ENRICHPLOT
#'
#' @param x termsim similarity matrix
#' @param keep GO terms to keep
#' @return a data.frame
#' @noRd
fill_termsim <- function(x, keep = NULL) {
  if (!is.null(keep)) termsim <- x[keep, keep]
  else                termsim <- x
  
  termsim[which(is.na(termsim))] <- 0
  
  termsim2 <- termsim + t(termsim)
  
  for ( i in seq_len(nrow(termsim2))) termsim2[i, i] <- 1
  
  termsim2
}

#' Fetch genes for the provided annotations
fetch_genes <- function(terms, mart) {
  att  <- c("ensembl_gene_id", "external_gene_name")
  names(terms) <- names(terms) %||% rep("go_parent_name", length(terms))
  names(terms)[names(terms) == ""] <- "go_parent_name"

  res <- terms %>%
    imap(~ {
      biomaRt::getBM(
        attributes = att,
        filters    = .y,
        values     = .x,
        mart       = mart
      ) %>%
        pull(external_gene_name)
    }) %>%
    reduce(c) %>%
    unique()

  res
}

#' Identify GO terms
#' 
#' By default all expressed genes are used as background for the cell type
#' This will include results for all terms with any overlap regardless of
#' significance, we need all terms for plotting enrichment scores
#' 
#' Terms with no overlap will not be included in results
#' 
#' @param genes Named list of differentially expressed genes for each cell type,
#' names should correspond to cell type labels found in type_clmn
#' @param so_in Seurat object so use for determining background gene set, if
#' `NULL` all genes are used
#' @param type_clmn Column in Seurat object containing cell types, these should
#' match the cell types provided by genes
#' @param max_term_size Maximum term size to include in results
#' @param min_term_size Minimum term size to include in results
#' @param db GO database to use, specify 'ALL' to use all three
#' @param simplify_terms Should GO terms be simplified to removed redundant
#' results, this has a significant effect on performance
#' @param n_bkgd Number of top expressed genes to include for the background
#' gene set
#' @param exclude_genes Regular expression to use for removing genes before
#' performing GO analysis, by default ribo protein and mito genes are excluded
#' @param org_db Bioconductor organism annotation database, should be class
#' OrgDb
#' @param sim_data Similarity data to use for simplifying GO terms, generated
#' using [clusterProfiler::godata()]
#' @param file Path to output file for saving results
get_go <- function(genes, so_in, type_clmn = "subtype", max_term_size = 750,
                   min_term_size = 10, db = "BP", simplify_terms = TRUE,
                   n_bkgd = Inf, exclude_genes = "^(Rp[sl]|mt-)",
                   org_db = org.Mm.eg.db, sim_data = go_sim_data, file = NULL) {
  
  # Check for save GO file
  # this function will save a tsv and a GO object
  obj_file <- str_c(file, ".qs")
  tbl_file <- str_c(file, ".tsv")
  
  if (!is.null(file) && file.exists(obj_file)) {
    cli::cli_alert("Loading file {.file {obj_file}}")
    
    return(qread(obj_file))
  }
  
  # Identify background gene set for each cell type
  # this includes all genes with >0 counts for any cell
  bkgd <- genes %>%
    imap(~ {
      bkgd <- NULL
      
      # so_in is required to determine background gene list
      # if genes is not named, all cells in so_in will be used
      if (!is.null(so_in)) {
        if (is.character(.y)) bkgd <- subset(so_in, !!sym(type_clmn) == .y)
        else                  bkgd <- so_in
        
        bkgd <- bkgd@assays$RNA@data %>%
          rowMeans() %>%
          sort(decreasing = TRUE) %>%
          head(n_bkgd)
        
        bkgd <- names(bkgd[bkgd > 0])
        
      } else {
        cli::cli_warn(
          "Background gene set can only be determined if so_in is provided"
        )
      }
      
      bkgd
    })
  
  # Identify GO terms for each gene list
  # exclude specified genes
  go <- genes %>%
    imap(~ {
      .x <- .x[!grepl(exclude_genes, .x)]
      
      g <- .x %>%
        enrichGO(
          keyType      = "SYMBOL",
          OrgDb        = org_db,
          universe     = bkgd[[.y]],
          maxGSSize    = max_term_size,
          minGSSize    = min_term_size,
          pvalueCutoff = 1.1,
          qvalueCutoff = 1.1,
          ont          = db
        )
      
      # Add background genes for each term to object
      # * this column is formatted in the same way as the geneID column
      # * these genes could be used to calculate overall fold enrichment for
      #   each cell type for GO clusters, i.e. determine total number of unique
      #   background genes overlapping all terms in the cluster
      # * overall fold enrichment scores for each cell type were not used
      #   in the final version of the GO heatmaps since the overall enrichment
      #   scores are on a much different scale as the other enrichement scores
      bkgd_gns <- g@result$ID %>%
        clusterProfiler::bitr(         # used to fetch gene symbols for GO terms
          fromType = "GOALL", toType = "SYMBOL",
          OrgDb = org.Mm.eg.db
        ) %>%
        filter(SYMBOL %in% bkgd[[.y]]) %>%
        split(.$GOALL)
      
      bkgd_gns <- bkgd_gns %>%
        map_chr(~ {
          .x$SYMBOL %>%
            unique() %>%
            str_c(collapse = "/")
        })
      
      g %>%
        mutate(bgID = bkgd_gns[ID])
    })
  
  # Merge GO objects  
  if (!is.null(names(go))) {
    go <- merge_result(go)
    
    go@fun <- "enrichGO"
    
  } else if (length(go) == 1) {
    go <- go[[1]]
  }
  
  # Simplify terms
  # this collapses terms that are very similar
  # this is very slow
  if (simplify_terms) {
    go <- go %>%
      clusterProfiler::simplify(semData = sim_data)
  }
  
  # Calculate enrichment scores
  go <- go %>%
    mutate(
      n_ovlp       = as.numeric(str_extract(GeneRatio, "^[0-9]+")),
      tot_genes    = as.numeric(str_extract(GeneRatio, "[0-9]+$")),
      n_bg_ovlp    = as.numeric(str_extract(BgRatio,   "^[0-9]+")),
      tot_bg_genes = as.numeric(str_extract(BgRatio,   "[0-9]+$")),
      enrichment   = (n_ovlp / tot_genes) / (n_bg_ovlp / tot_bg_genes)
    )
  
  # Save results
  if (!is.null(file)) {
    qsave(go, obj_file)
    
    go@compareClusterResult %>%
      write_tsv(tbl_file)
  }
  
  go
}

#' Cluster GO terms
#' 
#' @param go_in Object containing GO results
#' @param k Number of clusters to identify
#' @param pval Cutoff for filtering terms based on adjusted p-value, only
#' significant terms are used for clustering
#' @param qval Cutoff for filtering terms based on q-value
#' @param n_overlap Minimum number of genes needed to overlap term for it to be
#' included for clustering
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included for clustering
#' @param sim_data Similarity data to use for clustering GO terms, generated
#' using [clusterProfiler::godata()]
#' @param min_term_size Minimum number of genes for term to be included
#' @param max_term_size Maximum number of genes for term to be included
#' @param exclude_cell_types Cell types to exclude from GO clustering
get_go_clusters <- function(go_in, k = 3, pval = 0.05, qval = 0.2, n_overlap = 3,
                            n_shared = 1, sim_data = go_sim_data,
                            min_term_size = -Inf, max_term_size = Inf,
                            exclude_cell_types = NULL) {
  
  # Identify significant GO terms
  go_in <- go_in %>%
    filter(
      p.adjust < pval, qvalue < qval,
      Count >= n_overlap,
      !Cluster %in% exclude_cell_types
    )
  
  # Calculate summary stats for each term
  # filter by min/max term size and number of cell types sharing the term
  # sort by number of cell types that share the term
  # these are the terms that will be used for clustering
  top_terms <- go_in@compareClusterResult %>%
    filter(                              # filter based on term size
      n_bg_ovlp >= min_term_size,
      n_bg_ovlp <= max_term_size
    ) %>%
    
    group_by(Description, ID) %>%
    summarize(
      n_cell_types = n_distinct(Cluster),  # number of cell types with term
      enrichment   = mean(enrichment),     # mean enrichment score
      p.adjust     = mean(p.adjust),       # mean p-value across cell types
      qvalue       = mean(qvalue),         # mean q-value across cell types
      .groups      = "drop"          
    ) %>%
    arrange(desc(n_cell_types), p.adjust) %>%
    dplyr::filter(n_cell_types >= n_shared)

  # Set number of clusters
  # must average > 2 terms per cluster
  if (nrow(top_terms) < 2) return(NULL)
  
  k <- min(k, floor(nrow(top_terms) / 2))
  
  # Calculate similarity metric for top terms
  # fill in upper triangle of matrix and filter terms
  # use top_terms determined previously
  go_dist <- go_in %>%
    pairwise_termsim(semData = sim_data) %>%
    .@termsim %>%
    fill_termsim(keep = top_terms$Description)
  
  # Cluster terms
  # use ward.D method to avoid overlapping ancestor nodes of each group
  hc <- stats::hclust(
    stats::as.dist(1 - go_dist),
    method = "ward.D"
  )
  
  clst_obj <- stats::cutree(hc, k)
  
  clsts <- tibble(
    Description = names(clst_obj),
    cluster     = unname(clst_obj)
  )
  
  # Format output object
  res <- clsts %>%
    left_join(top_terms, by = "Description") %>%
  
    arrange(cluster, desc(n_cell_types), p.adjust) %>%
    group_by(cluster) %>%
    mutate(
      cluster_n_terms = n_distinct(Description),
      cluster_mean_p  = mean(p.adjust)
    ) %>%
    ungroup() %>%
    arrange(cluster, desc(n_cell_types), p.adjust)
  
  res <- list(
    clusters = res,             # data.frame with cluster stats/assignments
    object   = hc,              # hclust object
    clusters_object = clst_obj  # vector of cluster assignments
  )
  
  res
}

#' Create heatmaps summarizing GO clusters for each cell type
#' 
#' @param df_in data.frame containing clustering results generated with
#' get_clusters(), this provides the terms and cluster assignments to plot
#' @param go_in Object containing GO results, this is used to plot p-values and
#' GeneRatio for each cell type
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param pval Adjusted p-value cutoff for marking significant terms, this
#' cutoff should match the cutoff used for clustering GO terms
#' @param qval q-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_genes Minimum number of DEGs for cell type to be included on plot
#' @param clrs Colors to use for each cluster
#' @param n_col Number of columns to use for organizing facets (each cluster is
#' plotted as a separate facet)
#' @param clusters Which clusters to plot, this overrides n_clusters
#' @param include_overall_score Include row in heatmap showing combined
#' enrichment score for each cell type
#' @param free_y Allow height of each heatmap to differ based on the number of
#' rows
#' @param cluster_labels Vector containing descriptive labels for each cluster
#' @param exclude_cell_types Cell types to exclude from plot
create_go_heatmap <- function(df_in, go_in, n_clusters = 2, n_terms = 5,
                              pval = 0.05, qval = 0.2, n_overlap = 3,
                              n_genes = 3,
                              clrs = c("orange", "lightblue", "red"), n_col = 1,
                              clusters = NULL, include_overall_score = FALSE,
                              free_y = FALSE, cluster_labels = NULL,
                              exclude_cell_types = NULL) {
  
  # Top GO clusters to show
  # selected based on number of terms belonging to each cluster
  top_clusters <- clusters %||%
    df_in$cluster %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(n_clusters) %>%
    names()
  
  # Data for heatmap
  # filter cell types (Cluster column)
  cluster_ids <- df_in %>%
    dplyr::select(Description, cluster, n_cell_types)
  
  dat <- go_in@compareClusterResult %>%
    as_tibble() %>%
    left_join(cluster_ids, by = "Description") %>%
    filter(
      cluster %in% top_clusters,
      !Cluster %in% exclude_cell_types
    ) %>%
    mutate(
      significant = p.adjust < pval & qvalue < qval & n_ovlp >= n_overlap,
      enriched    = ifelse(significant, "Significant", "NS")  # this is used to add diamond
    )
  
  # Top GO terms to plot
  # df_in includes combined GO terms identified across all cell types
  # sorted based on number of cell types sharing term, then mean enrichment
  terms <- dat %>%
    filter(significant) %>%
    group_by(Description, ID, cluster) %>%
    summarize(                               # recalculate since some cell types
      n_cell_types = n_distinct(Cluster),    # removed with exclude_cell_types
      enrichment   = mean(enrichment),
      .groups = "drop"
    ) %>%
    arrange(cluster, desc(n_cell_types), desc(enrichment)) %>%
    group_by(cluster) %>%
    dplyr::slice(1:n_terms) %>%
    ungroup()
  
  term_lvls <- rev(terms$Description)
  
  dat <- dat %>%
    filter(ID %in% terms$ID)
  
  # Sort cell types based on number of significant terms and max enrichment
  # score
  typ_lvls <- dat %>%
    group_by(Cluster) %>%
    summarize(
      n_terms = length(ID[significant]),
      max_enr = max(enrichment),
      .groups = "drop"
    ) %>%
    arrange(desc(n_terms), desc(max_enr)) %>%
    pull(Cluster) %>%
    as.character()
  
  # Format term labels
  dat <- dat %>%
    mutate(Description = fct_relevel(Description, term_lvls)) %>%
    arrange(Description) %>%
    mutate(
      Description = str_trunc(
        as.character(Description), width = 70, side = "right"
      ),
      Description = str_wrap(Description, width = 40),
      Description = fct_inorder(Description),
      Cluster     = fct_relevel(Cluster, typ_lvls)
    )
  
  # Create heatmap
  if (length(clrs) == 1) scale_clr <- clrs
  else                   scale_clr <- "black"
  
  al_scale <- list(range = c(0, 1))
  
  if (max(dat$enrichment) < 70) al_scale$breaks <- seq(0, 70, 15)
  
  res <- dat %>%
    ggplot(aes(Cluster, Description, fill = as.character(cluster), alpha = enrichment)) +
    geom_tile() +
    geom_point(
      aes(color = enriched, fill = NULL),
      data   = ~ filter(.x, significant),
      alpha  = 1,
      shape  = 5,
      size   = 3,
      stroke = 1.2
    ) +
    scale_color_manual(values = "black") +
    scale_fill_manual(values = clrs) +
    lift_dl(scale_alpha_continuous)(al_scale) +
    scale_x_discrete(labels = ~ str_replace(.x, "_", " ")) +
    guides(
      alpha = guide_legend(
        keyheight      = unit(7, "pt"),
        label.position = "bottom",
        order          = 1,
        title          = "Enrichment Score",
        title.position = "top",
        nrow           = 1,
        override.aes   = list(fill = scale_clr)
      ),
      color = guide_legend(
        title          = NULL,
        label.position = "top",
        label.theme    = element_text(size = ttl_pt2),
        label.vjust    = 0.45,
        override.aes   = list(size = 4.5, stroke = 1.7),
      ),
      fill = "none"
    ) +
    base_theme +
    theme(
      legend.position    = "bottom",
      legend.title.align = 0.5,
      legend.key.width   = unit(25, "pt"),
      axis.title         = element_blank(),
      axis.text.x        = element_text(angle = 45, hjust = 1),
      strip.clip         = "off"
    )
  
  if (free_y) {
    res <- res +
      facet_grid(
        rows = "cluster",
        scales = "free_y", space = "free_y",
        labeller = cluster_labels %||% "label_value"
      )
  } else {
    n_terms <- terms %>%
      group_by(cluster) %>%
      summarize(n = n_distinct(Description), .groups = "drop") %>%
      pull(n) %>%
      max()
    
    res <- res +
      facet_wrap(
        ~ cluster, ncol = n_col, scales = "free_y",
        labeller = cluster_labels %||% "label_value"
      ) +
      theme(aspect.ratio = n_terms / n_distinct(dat$Cluster))
  }
  
  res <- list(
    heatmap = res,
    terms = terms
  )
  
  res
}

#' Create expanded GO summary plots
#' 
#' @param go_in data.frame containing GO results (compareClusterResult)
#' @param degs_in data.frame containing DEG results, this is used to select
#' the top differentially expressed genes for go_in
#' @param all_exp_data Named list of Seurat objects containing all expression
#' data wanting to plot
#' @param all_degs_data Named list of data.frames containing DEGs, this is used to
#' determine which genes are upregulated for each cell type and timepoint. DEGs
#' need to be provided for each Seurat object provided to all_exp_data
#' @param n_clusters Number of top GO clusters to plot, clusters are sorted by
#' number of terms, with the top clusters having the most terms
#' @param n_terms The number of top terms to show for each cluster, terms are
#' sorted by the number of cell types that share the term and the overall mean
#' p-value for the term (averaged across all cell types)
#' @param n_genes Number of top genes to plot for each GO cluster
#' @param pval Adjusted p-value cutoff for marking significant terms
#' @param n_overlap Minimum number of genes needed to overlap the term for it to
#' be marked as significant
#' @param n_shared Minimum number of cell types that term has to be shared with
#' for it to be included
#' @param exclude_cell_types Cell types to exclude from plots
create_go_summary_plots <- function(go_in, degs_in,
                                    all_exp_data = list(
                                      "8hpi" = so_8, "24hpi" = so_merge
                                    ),
                                    all_degs_data = list(
                                      "8hpi"  = degs[["so_8-up_lectype"]],
                                      "24hpi" = degs[["so_merge-up_lectype"]]
                                    ),
                                    n_clusters = 5, n_terms = 6, n_genes = 4,
                                    pval = 0.05, n_overlap = 3, n_shared = 1,
                                    only_show_upreg = TRUE,
                                    exclude_cell_types = NULL
                                    ) {
  
  # Cluster GO terms
  clsts <- go_in %>%
    get_go_clusters(
      k         = n_clusters,
      pval      = pval,
      n_overlap = n_overlap,
      n_shared  = n_shared,
      exclude_cell_types = NULL
    )
  
  if (is.null(clsts)) return(NULL)
  
  # Create tree
  clst_ids <- as.character(unique(sort(clsts$clusters$cluster)))
  
  clst_clrs <- set_names(
    unname(type_cols)[1:n_distinct(clst_ids)],
    clst_ids
  )
  
  cl <- split(
    names(clsts$clusters_object),
    clsts$clusters_object
  )
  
  tr <- ggtree(clsts$object, linewidth = 1)
  
  clades <- cl %>%
    map_int(~ MRCA(tr, .x))
  
  tr <- groupClade(tr, clades, group_name = "cluster") +
    aes(color = cluster) +
    scale_color_manual(values = clst_clrs) +
    geom_tiplab(angle = 90, hjust = 1, nudge_x = -0.1) +
    layout_dendrogram() +
    theme(
      legend.position = "none",
      plot.margin = margin(6, 6, 250, 6)
    )
  
  # Create heatmaps
  heat <- clsts$clusters %>%
    create_go_heatmap(
      go_in      = go_in,
      n_overlap  = n_overlap,
      n_clusters = n_clusters,
      n_genes    = 0,           # Min genes represented on plot for cell type
      n_terms    = n_terms,     # to be shown on plot
      n_col      = 1,
      free_y     = FALSE,
      clrs       = clst_clrs,
      exclude_cell_types = exclude_cell_types
    )
  
  heat$heatmap <- heat$heatmap +
    theme(axis.text = element_text(size = 10))
  
  # Example genes to plot
  heat_terms <- heat$terms %>%
    dplyr::select(Description, cluster, ID)
  
  gns <- get_go_genes(
    go_in    = go_in@compareClusterResult,
    degs_in  = degs_in,
    clust_in = heat_terms,
    genes    = n_genes,
    exclude_cell_types = exclude_cell_types
  )
  
  # Create gene plots
  gn_plts <- create_go_gene_plots(
    all_exp_data       = all_exp_data,
    all_degs_data      = all_degs_data,
    genes              = gns,
    cell_types         = Inf,
    clrs               = clst_clrs,
    only_show_upreg    = only_show_upreg,
    exclude_cell_types = exclude_cell_types
  ) +
    theme(
      plot.margin = margin(6, 40, 6, 40, unit = "pt"),
      axis.text   = element_text(size = 7),
      strip.text  = element_text(size = 8)
    )
  
  # Create final figure
  bot <- plot_grid(
    heat$heatmap + theme(plot.margin = margin(6, 40, 6, 40, unit = "pt")),
    gn_plts,
    nrow = 1,
    labels = c("B", "C"),
    rel_widths = c(0.9, 1),
    align = "h",
    axis  = "tb"
  )
  
  res <- plot_grid(
    tr, bot,
    ncol = 1,
    rel_heights = c(0.3, 1),
    labels = "A"
  )
  
  res
}
```

```{r "RF Ag class", eval = run_rf}
# Set Ag-low/high classes for classifier
# * split for each cell type from each mouse
# * set subtype cutoff for all mice using d14 cutoff
ag_clmns <- set_names(
  c("Ag_score", "Ag_score_3", "Ag_score_6"),
  c(rf_dat_clmn, "Ag_class_3wk", "Ag_class_6wk")
)

ag_clmns %>%
  iwalk(~ {
    lec_so <- lec_so %>%
      mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
      cluster_signal(
        data_column  = .x,
        grp_column   = "mouse_type",
        clust_column = .y,
        method       = "km"
      )
    
    # The threshold will be the same for each column since this is set using
    # only the d14 mouse
    threshold <- lec_so@meta.data %>%
      filter(mouse == rf_mouse, !!sym(.y) == "high") %>%
      group_by(subtype) %>%
      summarize(threshold = min(!!sym(.x)), .groups = "drop")
    
    threshold <- set_names(threshold$threshold, threshold$subtype)
    
    lec_so <<- lec_so %>%
      mutate_meta(
        mutate,
        !!sym(.y) := ifelse(!!sym(.x) >= threshold[subtype], "high", "low")
      )
  })

# Identify double-positive cells for the 6wk-3wk mouse
lec_so <- lec_so %>%
  mutate_meta(
    mutate,
    Ag_class_dual = case_when(
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" & Ag_class_6wk == "high") ~ "double-high",
      mouse == "6wk-3wk" & (Ag_class_3wk == "high" | Ag_class_6wk == "high") ~ "single-high",
      # mouse == "6wk-3wk" & Ag_class_6wk == "high"                            ~ "6wk-single",
      # mouse == "6wk-3wk" & Ag_class_3wk == "high"                            ~ "3wk-single",
      mouse == "6wk"     & Ag_class_6wk == "high"                            ~ "6wk-high",
      mouse == "3wk"     & Ag_class_3wk == "high"                            ~ "3wk-high",
      # mouse == "6wk-3wk" & (Ag_class_3wk == "low" & Ag_class_6wk == "low")   ~ "double-low",
      TRUE                                                                   ~ "low"
    )
  )

# Save LEC object with Ag classifications
lec_so %>%
  qsave(here(params$so_dir, "lec_so.qs"))
```

```{r "identify Ag DEGs", eval = run_rf}
# Identify Ag markers for all LECs for each mouse
fc <- 0

deg_so <- lec_so %>%
  SplitObject("mouse")

degs_1 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = "all", mouse = .y) %>%
      arrange(padj)
  })

# Identify Ag markers for each subtype separately
deg_so <- lec_so %>%
  SplitObject("subtype")

degs_2 <- deg_so %>%
  imap_dfr(~ {
    res <- .x %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = .y, mouse = "all") %>%
      arrange(padj)
  })

rm(deg_so)

# Identify markers for each subtype and mouse separately
degs_3 <- lec_so@meta.data %>%
  distinct(subtype, mouse) %>%
  pmap_dfr(~ {
    res <- lec_so %>%
      subset(subtype == ..1 & mouse == ..2)
    
    if (n_distinct(res[[rf_dat_clmn]]) < 2) return(NULL)
    
    res <- res %>%
      wilcoxauc(group_by = rf_dat_clmn)

    if (nrow(res) == 0) return(NULL)

    res %>%
      mutate(subtype = ..1, mouse = ..2) %>%
      arrange(padj)
  })

degs <- bind_rows(degs_1, degs_2, degs_3) %>%
  filter(
    padj < 0.05, logFC > fc,
    !grepl("^(mt-|R[pls])", feature),
    feature != "Malat1"
  )

# Write table
degs %>%
  write_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))
```

```{r "train RF models", eval = run_rf}
# Test parameters and calculate stats for each LEC subtype
rf_stats <- rf_typs %>%
  map_dfr(~ {
    feats <- degs %>%
      filter(subtype %in% .x) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == .x & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    all_dat <- lec_so %>%
      subset(subtype == .x & mouse != rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, "mouse", feats))) %>%
      as_tibble(rownames = ".cell_id") %>%
      rename_with(~ str_replace_all(.x, "-", "_")) %>%
      rename_with(~ str_replace_all(.x, "\\(|\\)", "_")) %>%
      rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
      column_to_rownames(".cell_id") %>%
      split(.$mouse)
    
    # Set RF params to test every combination
    max_mtry <- min(length(feats), 1000)
    mid_mtry <- min(200, max_mtry)
    rep_mtry <- floor(sqrt(max_mtry))

    # # 2024-02-02    
    # param_lst <- list(
    #   mtry          = c(seq(1, mid_mtry, rep_mtry), seq(mid_mtry, max_mtry, 150)),
    #   min.node.size = c(1:4, 10),
    #   splitrule     = c("gini", "hellinger"),
    #   num.trees     = c(100, 500, 900, 1200),
    #   low           = 1:5,           # include NAs so original class
    #   high          = c(5, NA),      # distributions are also tested
    #   num.threads   = 8
    # )
    # # 2024-02-03
    # # extratrees seems consistently better, original class weights seems consistently bad
    # param_lst <- list(
    #   mtry          = seq(1, 100, 15),
    #   min.node.size = 1:5,
    #   splitrule     = c("gini", "hellinger", "extratrees"),
    #   num.trees     = c(800, 1000, 2000),
    #   low           = 4:7,           # include NAs so original class
    #   high          = c(5, NA),      # distributions are also tested
    #   num.threads   = 8
    # )
    # 2024-02-04
    param_lst <- list(
      mtry          = seq(1, 150, 10),
      min.node.size = 1:5,
      splitrule     = "extratrees",
      num.trees     = c(1000, 1200, 1500, 2000),
      low           = 2:7,
      high          = 5,
      num.threads   = 8
    )
    
    # Train model
    res <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = param_lst,
        df_list         = all_dat[names(all_dat) != rf_mouse],
        include_objects = FALSE
      )
    
    if (is.null(res)) return(res)  # If mtry is too high will return NULL
    
    res <- res %>%
      arrange(desc(Kappa)) %>%
      mutate(
        subtype = .x,
        rank    = row_number()
      )
    
    res %>%
      write_tsv(here(params$mod_dir, str_c(.x, "_models.tsv.gz")))
      
    res
  })

# Train models based on best parameters
# sort based on Kappa
rf_mods <- rf_stats %>%
  group_by(subtype) %>%
  slice_max(Kappa, n = 50, with_ties = FALSE) %>%
  ungroup()

rf_mods <- rf_mods %>%
  split(.$subtype) %>%
  imap_dfr(~ {
    feats <- degs %>%
      filter(subtype == .y) %>%
      pull(feature) %>%
      unique()

    rf_dat <- lec_so %>%
      subset(subtype == .y & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))

    .x %>%
      pmap_dfr(~ {
        args <- list(...)
        
        stats <- c(
          "mtry", "min.node.size", "num.trees",
          "splitrule", "low", "high"
        )

        rf_dat %>%
          train_rf(
            data_clmn       = rf_dat_clmn,
            param_lst       = args[stats],
            include_objects = TRUE
          ) %>%
          mutate(subtype = args$subtype)
      })
  })

# Save RF models
rf_stats %>%
  write_tsv(here(params$mod_dir, "ag-high_models.tsv.gz"))
```

```{r "load CHIKV data", eval = run_rf}
# Load CHIKV data
chikv_so <- qread(here(params$chikv_dir, "so_lec.qs"))

chikv_feats <- degs %>%
  pull(feature) %>%
  unique()

chikv_clmns <- c(
  "orig.ident", "rep", "treatment", "tm",
  chikv_type_clmn,
  "UMAP_1", "UMAP_2"
)

chikv_dat <- chikv_so %>%
  FetchData(c(chikv_clmns, chikv_feats))

# Add zeros for missing genes
missing_gns <- chikv_feats[!chikv_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))
```

```{r "assess model performance using CHIKV data", eval = run_rf}
# Format CHIKV RF data
chikv_rf_so <- chikv_so %>%
  subset(treatment == "mock" & tm == "24hpi" & rep == 1)

chikv_rf_dat <- chikv_dat[Cells(chikv_rf_so), ]

# Check model performance using some CHIKV data
# assess fold change in module score for one mock CHIKV replicate
rf_mods <- rf_mods %>%
  pmap_dfr(~ {
    args <- list(...)
    
    # Train model
    feats <- degs %>%
      filter(subtype == args$subtype) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    stats <- c(
      "mtry", "min.node.size", "num.trees",
      "splitrule", "low", "high"
    )
    
    mod <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = args[stats],
        include_objects = TRUE
      ) %>%
      mutate(subtype = args$subtype)
    
    # Pull top features
    mod_feats <- mod$feats[[1]] %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    mod_feats <- degs %>%
      filter(feature %in% mod_feats) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
    
    # Predict using models for each LEC subset
    chikv_dat <- chikv_dat %>%
      filter(!!sym(chikv_type_clmn) == mod$subtype) %>%
      dplyr::select(-all_of(chikv_type_clmn))
    
    chikv_preds <- mod$mod[[1]]$finalModel %>%
      rf_predict(
        dat = chikv_dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
    
    chikv_rf_so <- chikv_rf_so %>%
      subset(!!sym(chikv_type_clmn) == mod$subtype) %>%
      AddMetaData(chikv_preds)
    
    # Add module scores
    clmn_nms <- names(mod_feats)
    
    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      names(mod_feats)
    )
    
    chikv_rf_so <- chikv_rf_so %>%
      AddModuleScore(
        features = mod_feats,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
    
    # Calculate fold change for low and high groups
    chikv_stats <- chikv_rf_so@meta.data %>%
      mutate(
        min_val = min(c(high, low)),
        across(c(high, low), ~ ifelse(min_val < 0, .x + abs(min_val), .x)),  # correct negative values
        
        high_mod_p = wilcox.test(                                            # calculate p-values
          high[pred == "high"], high[pred == "low"],
          alternative = "greater"
        )$p.value,
        low_mod_p = wilcox.test(
          low[pred == "high"], low[pred == "low"], 
          alternative = "less"
        )$p.value
      ) %>%
      group_by(pred, high_mod_p, low_mod_p) %>%                              # calculate median
      summarize(across(c(high, low), median), .groups = "drop") %>%
      summarize(                                                             # calculate fold change
        across(ends_with("_mod_p"), unique),
        high_mod_fc = high[pred == "high"] / high[pred == "low"],
        low_mod_fc  = low[pred == "high"]  / low[pred == "low"]
      )
    
    # Return stats
    res <- mod %>%
      bind_cols(chikv_stats)
    
    res
  })

# Select best model
rf_mods_best <- rf_mods %>%
  group_by(subtype) %>%
  slice_max(Kappa, n = 1, with_ties = FALSE) %>%
  ungroup()

# Save models
rf_mods %>%
  qsave(here(params$mod_dir, "ag-high_models.qs"))

rf_mods_best %>%
  qsave(here(params$mod_dir, "ag-high_best_models.qs"))

# Remove CHIKV objects
rm(chikv_so, chikv_rf_so, chikv_rf_dat)
```

```{r "RF features", eval = run_rf}
# Pull best features
rf_feats <- rf_mods_best %>%
  pmap(~ {
    args <- list(...)
    
    fts <- args$feats %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    degs %>%
      filter(feature %in% fts) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
  })

names(rf_feats) <- rf_mods_best$subtype

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Save top features
rf_feats %>%
  qsave(here(params$mod_dir, "ag-high_features.qs"))
```

```{r "predict Ag class", eval = run_rf}
# Predict Ag class
# predictions are made separately for each mouse IS THIS NECESSARY??
info_clmns <- c("subtype", "mouse")

pred_dat <- lec_so %>%
  FetchData(unique(c(rf_dat_clmn, info_clmns, all_feats))) %>%
  as_tibble(rownames = ".cell_id") %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]")) %>%
  mutate(mouse = as.character(mouse)) %>%
  column_to_rownames(".cell_id")

rf_preds <- rf_mods_best %>%
  pmap_dfr(~ {
    args <- list(...)
    
    dat <- pred_dat %>%
      filter(subtype == args$subtype) %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    mod <- args$mod
    
    if (identical("train", class(mod))) mod <- mod$finalModel
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Predict Ag class for all subsets using cLEC model
rf_preds_2 <- rf_mods_best %>%
  filter(subtype == rf_cell_type) %>%
  pmap_dfr(~ {
    args <- list(...)
    mod  <- args$mod
    
    if (identical("train", class(mod))) mod <- mod$finalModel
    
    dat <- pred_dat %>%
      split(.$mouse) %>%
      map(dplyr::select, -all_of(info_clmns))
    
    dat %>%
      imap_dfr(~ {
        rf_predict(
          mod          = mod,
          dat          = .x,
          data_clmn    = rf_dat_clmn,
          return_stats = FALSE
        ) %>%
          dplyr::select(pred, correct)
      })
  })

# Write table with predictions
rf_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz"))

rf_preds_2 %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, str_c("ag-high_", rf_cell_type, "_preds.tsv.gz")))
```

```{r "predict CHIKV", eval = run_rf}
# Predict using models for each LEC subset
chikv_preds <- rf_mods_best %>%
  pmap_dfr(~ {
    args <- list(...)
    mod  <- args$mod
    
    if (identical("train", class(mod))) mod <- mod$finalModel
    
    dat <- chikv_dat %>%
      filter(!!sym(chikv_type_clmn) == args$subtype) %>%
      dplyr::select(-all_of(chikv_clmns))
    
    mod %>%
      rf_predict(
        dat = dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
  })

# Save predictions
chikv_preds %>%
  rownames_to_column(".cell_id") %>%
  write_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz"))
```

```{r "load models"}
# Load saved objects
rf_mods_best <- qread(here(params$mod_dir, "ag-high_best_models.qs"))
degs         <- read_tsv(here(params$mod_dir, "ag-high_degs.tsv.gz"))

rf_preds <- read_tsv(here(params$mod_dir, "ag-high_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")

rf_feats <- qread(here(params$mod_dir, "ag-high_features.qs"))

all_feats <- rf_feats %>%
  unlist(use.names = FALSE) %>%
  unique()

# Load CHIKV predictions
chikv_preds <- read_tsv(here(params$mod_dir, "ag-high_chikv_preds.tsv.gz")) %>%
  column_to_rownames(".cell_id")
```



```{r "OLD MODELS 58d69d9", eval = FALSE}
## CODE USED FOR 2023-11-01 MODELS ##
# https://github.com/sheridar/antigen-exchange/blob/58d69d9974d5779cfcdc38f7ec19dfc48686f0b4/results/tamburini-ml.Rmd

# Identify top models for each cell type
# !! stats in rf_stats do not match stats produced during model training !!
# !! a key difference is the number of test and training cells           !!
# rf_stats <- read_tsv(here(params$mod_dir, "ag-high_stats.tsv.gz"))
rf_stats <- rf_stats %>%
  distinct(high / low, F1, `Balanced Accuracy`, .keep_all = TRUE) %>%
  group_by(subtype) %>%
  slice_max(`Balanced Accuracy`, prop = 0.2) %>%
  slice_max(F1, n = 100, with_ties = FALSE) %>%
  ungroup()

# Format CHIKV RF data
# need to add zeros for missing genes
chikv_so <- qread(params$chikv_so) %>%
  subset(treatment == "mock" & tm == "24hpi" & rep == 1)

chikv_feats <- degs %>%
  pull(feature) %>%
  unique()

chikv_dat <- chikv_so %>%
  FetchData(c("lec_type", chikv_feats))

missing_gns <- chikv_feats[!chikv_feats %in% colnames(chikv_dat)]

chikv_dat[, missing_gns] <- 0

chikv_dat <- chikv_dat %>%
  rename_with(~ str_replace_all(.x, "-", "_")) %>%
  rename_with(~ str_c("x", .x), matches("^[0-9]"))

# Check model performance using some CHIKV data
# assess fold change in module score for one mock CHIKV replicate
# CLEAN THIS UP
rf_stats <- rf_stats %>%
  pmap_dfr(~ {
    args <- list(...)
    
    # Train model
    feats <- degs %>%
      filter(subtype == args$subtype) %>%
      pull(feature) %>%
      unique()
    
    rf_dat <- lec_so %>%
      subset(subtype == args$subtype & mouse == rf_mouse) %>%
      FetchData(unique(c(rf_dat_clmn, feats)))
    
    stats <- c("mtry", "min.node.size", "num.trees", "low", "high")
    
    mod <- rf_dat %>%
      train_rf(
        data_clmn       = rf_dat_clmn,
        param_lst       = args[stats],
        include_objects = TRUE
      ) %>%
      mutate(subtype = args$subtype)
    
    # Pull top features
    mod_feats <- mod$feats[[1]] %>%
      unlist(use.names = FALSE) %>%
      str_replace_all("_", "-") %>%
      str_remove("^x")
    
    mod_feats <- degs %>%
      filter(feature %in% mod_feats) %>%
      mutate(label_rank = case_when(
        subtype == args$subtype & mouse == rf_mouse ~ 1,
        subtype == args$subtype                     ~ 2,
        mouse   == rf_mouse                         ~ 3,
        TRUE                                        ~ 4
      )) %>%
      group_by(feature) %>%
      filter(label_rank == min(label_rank)) %>%
      ungroup() %>%
      split(.$group) %>%
      map(~ unique(pull(.x, feature)))
    
    # Predict using models for each LEC subset
    chikv_dat <- chikv_dat %>%
      filter(lec_type == mod$subtype) %>%
      dplyr::select(-lec_type)
    
    chikv_preds <- mod$mod[[1]] %>%
      rf_predict(
        dat = chikv_dat,
        return_stats = FALSE
      ) %>%
      dplyr::select(.cell_id, pred) %>%
      column_to_rownames(".cell_id")
    
    chikv_so <- chikv_so %>%
      subset(lec_type == mod$subtype) %>%
      AddMetaData(chikv_preds)
    
    # Add module scores
    clmn_nms <- names(mod_feats)
    
    clmn_nms <- set_names(
      str_c(clmn_nms, seq_along(clmn_nms)),
      names(mod_feats)
    )
    
    chikv_so <- chikv_so %>%
      AddModuleScore(
        features = mod_feats,
        name     = names(clmn_nms)
      ) %>%
      mutate_meta(dplyr::rename, !!!syms(clmn_nms))
    
    # Calculate fold change for low and high groups
    chikv_stats <- chikv_so@meta.data %>%
      mutate(
        min_val = min(c(high, low)),
        across(c(high, low), ~ ifelse(min_val < 0, .x + abs(min_val), .x)),  # correct negative values
        
        high_mod_p = wilcox.test(                                            # calculate p-values
          high[pred == "high"], high[pred == "low"],
          alternative = "greater"
        )$p.value,
        low_mod_p = wilcox.test(
          low[pred == "high"], low[pred == "low"], 
          alternative = "less"
        )$p.value
      ) %>%
      group_by(pred, high_mod_p, low_mod_p) %>%                              # calculate median
      summarize(across(c(high, low), median), .groups = "drop") %>%
      summarize(                                                             # calculate fold change
        across(ends_with("_mod_p"), unique),
        high_mod_fc = high[pred == "high"] / high[pred == "low"],
        low_mod_fc  = low[pred == "high"]  / low[pred == "low"]
      )
    
    # Return stats
    res <- mod %>%
      bind_cols(chikv_stats)
    
    res
  })

## KEY DIFFERENCE WITH THIS VERSION IS FILTERING BASED ON CHIKV PERFORMANCE ##
# Select best model
# train models based on best parameters
# sort based on fold change in module score
rf_mods <- rf_stats %>%
  filter(high_mod_fc >= 1.2, low_mod_fc < 0.9) %>%
  arrange(desc(F1), desc(high_mod_fc), low_mod_fc) %>%
  group_by(subtype) %>%
  dplyr::slice(1) %>%
  ungroup()
```

```{r "RF MODEL STACKING", eval = FALSE}
feats <- degs %>%
  pull(feature) %>%
  unique()

rf_dat <- lec_so %>%
  subset(mouse == rf_mouse) %>%
  FetchData(unique(c(rf_dat_clmn, feats)))

rf_split <- initial_split(rf_dat, prop = 0.5)
rf_train <- training(rf_split)
rf_test  <- testing(rf_split)

en <- ensemble(
  training = rf_train,
  testing  = rf_test,
  outcomeName = rf_dat_clmn,
  BaseModels = rf_mods_best$mod
)
```

```{r "CROSS VALIDATION", eval = FALSE}
library(caret)
library(ranger)

# Format data
mod <- rf_mods %>%
  filter(subtype == "cLEC")

feats <- purrr::reduce(rf_feats$cLEC, c)

dat <- lec_so %>%
  subset(cells = mod$training_bcs[[1]])

predictors <- dat %>%
  FetchData(feats)

outcome <- factor(dat$Ag_class, c("high", "low"))

mod_params <- list(
  mtry          = seq(1, length(feats), floor(length(feats) / 15)),
  min.node.size = seq(1, 10, 2),
  splitrule     = c("gini", "extratrees")
) %>%
  expand.grid()
  
# Train model
control <- trainControl(method = "cv", number = 10)  # 10-fold cross-validation

set.seed(42)

model <- train(
  predictors, outcome,
  method        = "ranger",
  trControl     = control,
  tuneGrid      = mod_params,
  num.trees     = mod$num.trees
  # mtry          = mod$mtry,
  # min.node.size = mod$min.node.size,
  # num.trees     = mod$num.tress
)
```

```{r "AG CLASS 2", eval = FALSE}
# Try splitting into Ag-low/high separately for each cell type
lec_so <- lec_so %>%
  subset(mouse != "d2") %>%
  mutate_meta(mutate, mouse_type = str_c(subtype, "_", mouse)) %>%
  cluster_signal(
    data_column  = "Ag_score",
    grp_column   = "mouse_type",
    clust_column = "Ag_class_2",
    method       = "km"
  )
```

```{r "RF PARAMS PLOTS", eval = FALSE}
rf_stats <- read_tsv(here(params$mod_dir, "ag-high_models.tsv.gz"))

rf_params <- c(
  "mtry", "min.node.size", "splitrule",
  "num.trees", "low"
)

rf_params %>%
  map(~ {
    rf_stats %>%
      ggplot(aes(!!sym(.x), Kappa, color = subtype)) +
      geom_point(size = 0.1, alpha = 0.1) +
      facet_wrap(~ subtype) +
      base_theme
  }) %>%
  plot_grid(plotlist = .)

```